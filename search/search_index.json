{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"RobotLab","text":"<p>[!CAUTION] This gem is under active development. APIs and features may change without notice. See the CHANGELOG for details.</p> \"Build robots. Solve problems.\"  RobotLab is a Ruby gem that enables you to build sophisticated AI applications using multiple specialized robots (LLM agents) that work together to accomplish complex tasks. Each robot has its own system prompt, tools, and capabilities. Robots can be orchestrated through networks with customizable routing logic, share information through a hierarchical memory system, and connect to external tools via the Model Context Protocol (MCP)."},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p> Multi-Robot Architecture</p> <p>Build applications with multiple specialized AI agents, each with unique capabilities and personalities.</p> <p> Learn more</p> </li> <li> <p> Network Orchestration</p> <p>Connect robots in networks with flexible routing to handle complex, multi-step workflows.</p> <p> Creating Networks</p> </li> <li> <p> Extensible Tools</p> <p>Give robots custom tools to interact with external systems, databases, and APIs.</p> <p> Using Tools</p> </li> <li> <p> MCP Integration</p> <p>Connect to Model Context Protocol servers to extend robot capabilities with external tools.</p> <p> MCP Guide</p> </li> <li> <p> Shared Memory</p> <p>Robots can share information through a hierarchical memory system with namespaced scopes.</p> <p> Memory System</p> </li> <li> <p> Conversation History</p> <p>Persist and restore conversation threads for long-running interactions.</p> <p> History Guide</p> </li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>require \"robot_lab\"\n\n# Configure RobotLab\nRobotLab.configure do |config|\n  config.anthropic_api_key = ENV[\"ANTHROPIC_API_KEY\"]\n  config.default_model = \"claude-sonnet-4\"\nend\n\n# Create a simple robot\nrobot = RobotLab.build do\n  name \"assistant\"\n  description \"A helpful AI assistant\"\n  template &lt;&lt;~PROMPT\n    You are a helpful assistant. Answer questions clearly and concisely.\n  PROMPT\nend\n\n# Create a network with the robot\nnetwork = RobotLab.create_network do\n  name \"simple_network\"\n  add_robot robot\nend\n\n# Run the network\nstate = RobotLab.create_state(message: \"What is the capital of France?\")\nresult = network.run(state: state)\n\nputs result.last_result.output.first.content\n# =&gt; \"The capital of France is Paris.\"\n</code></pre>"},{"location":"#supported-llm-providers","title":"Supported LLM Providers","text":"<p>RobotLab supports multiple LLM providers through the ruby_llm library:</p> Provider Models Anthropic Claude 4, Claude Sonnet, Claude Haiku OpenAI GPT-4o, GPT-4, GPT-3.5 Turbo Google Gemini Pro, Gemini Ultra Azure OpenAI All Azure-hosted OpenAI models Bedrock Claude models via AWS Bedrock Ollama Local models via Ollama"},{"location":"#installation","title":"Installation","text":"<p>Add RobotLab to your Gemfile:</p> <pre><code>gem \"robot_lab\"\n</code></pre> <p>Or install directly:</p> <pre><code>gem install robot_lab\n</code></pre> <p> Full Installation Guide</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p> Quick Start</p> <p>Get up and running in 5 minutes</p> </li> <li> <p> Concepts</p> <p>Understand the core concepts</p> </li> <li> <p> Examples</p> <p>See RobotLab in action</p> </li> <li> <p> API Reference</p> <p>Detailed API documentation</p> </li> </ul>"},{"location":"#license","title":"License","text":"<p>RobotLab is released under the MIT License.</p>"},{"location":"concepts/","title":"Core Concepts","text":"<p>Understanding the fundamental concepts in RobotLab will help you build effective AI applications.</p>"},{"location":"concepts/#robot","title":"Robot","text":"<p>A Robot is an LLM-powered agent with a specific personality, capabilities, and tools. Each robot has:</p> <ul> <li>Name: A unique identifier within a network</li> <li>Description: What the robot does (used for routing decisions)</li> <li>Template/System Prompt: Instructions that define the robot's behavior</li> <li>Model: The LLM model to use (e.g., <code>claude-sonnet-4</code>)</li> <li>Tools: Custom functions the robot can call</li> </ul> <pre><code>robot = RobotLab.build do\n  name \"support_agent\"\n  description \"Handles customer support inquiries\"\n  model \"claude-sonnet-4\"\n  template \"You are a friendly customer support agent...\"\n\n  tool :lookup_order do\n    description \"Look up order details by order ID\"\n    parameter :order_id, type: :string, required: true\n    handler { |order_id:| Order.find(order_id).to_h }\n  end\nend\n</code></pre>"},{"location":"concepts/#network","title":"Network","text":"<p>A Network is a collection of robots orchestrated using SimpleFlow pipelines. Networks provide:</p> <ul> <li>Task-Based Orchestration: Define tasks with dependencies and routing</li> <li>Parallel Execution: Tasks with the same dependencies run concurrently</li> <li>Optional Task Activation: Dynamic routing based on robot output</li> <li>Per-Task Configuration: Each task can have its own context, tools, and MCP servers</li> </ul> <pre><code>network = RobotLab.create_network(name: \"customer_service\") do\n  task :classifier, classifier_robot, depends_on: :none\n  task :billing, billing_robot,\n       context: { department: \"billing\" },\n       depends_on: :optional\n  task :technical, technical_robot,\n       context: { department: \"technical\" },\n       depends_on: :optional\nend\n</code></pre>"},{"location":"concepts/#task","title":"Task","text":"<p>A Task wraps a robot for use in a network pipeline with per-task configuration:</p> <ul> <li>Context: Task-specific context deep-merged with network run params</li> <li>MCP: MCP servers available to this task</li> <li>Tools: Tools available to this task</li> <li>Memory: Task-specific memory</li> <li>Dependencies: <code>:none</code>, <code>[:task1, :task2]</code>, or <code>:optional</code></li> </ul> <pre><code>task :billing, billing_robot,\n     context: { department: \"billing\", escalation_level: 2 },\n     tools: [RefundTool, InvoiceTool],\n     depends_on: :optional\n</code></pre>"},{"location":"concepts/#simpleflowresult","title":"SimpleFlow::Result","text":"<p>Networks use <code>SimpleFlow::Result</code> for data flow between tasks:</p> <pre><code>result.value      # Current task's output (RobotResult)\nresult.context    # Accumulated context from all tasks\nresult.halted?    # Whether execution stopped early\nresult.continued? # Whether execution continues\n</code></pre>"},{"location":"concepts/#result-methods","title":"Result Methods","text":"Method Purpose <code>continue(value)</code> Continue to next tasks <code>halt(value)</code> Stop pipeline execution <code>with_context(key, val)</code> Add data to context <code>activate(task_name)</code> Enable optional task"},{"location":"concepts/#tool","title":"Tool","text":"<p>Tools are functions that robots can call to interact with external systems:</p> <pre><code>tool = RobotLab::Tool.new(\n  name: \"get_weather\",\n  description: \"Get current weather for a location\",\n  parameters: {\n    location: { type: \"string\", description: \"City name\" }\n  },\n  handler: -&gt;(location:, **_context) {\n    WeatherService.current(location)\n  }\n)\n</code></pre>"},{"location":"concepts/#message-types","title":"Message Types","text":"<p>RobotLab uses several message types to represent conversation content:</p> Type Purpose <code>TextMessage</code> User or assistant text content <code>ToolMessage</code> Tool definition with name and parameters <code>ToolCallMessage</code> Request from LLM to execute a tool <code>ToolResultMessage</code> Result returned from tool execution"},{"location":"concepts/#memory","title":"Memory","text":"<p>Memory provides persistent storage across robot executions:</p> <pre><code># Robot with inherent memory\nrobot = RobotLab.build(name: \"assistant\", system_prompt: \"You are helpful.\")\nrobot.run(message: \"My name is Alice\")\nrobot.run(message: \"What's my name?\")  # Memory persists\n\n# Access robot's memory\nrobot.memory[:user_id] = 123\nrobot.memory.data[:category] = \"billing\"\n\n# Runtime memory injection\nrobot.run(message: \"Help me\", memory: { session_id: \"abc123\" })\n\n# Reset memory\nrobot.reset_memory\n</code></pre>"},{"location":"concepts/#mcp-model-context-protocol","title":"MCP (Model Context Protocol)","text":"<p>MCP allows robots to connect to external tool servers:</p> <pre><code>robot = RobotLab.build(\n  name: \"developer\",\n  mcp: [\n    { name: \"filesystem\", transport: { type: \"stdio\", command: \"mcp-server-filesystem\" } },\n    { name: \"github\", transport: { type: \"stdio\", command: \"mcp-server-github\" } }\n  ]\n)\n</code></pre>"},{"location":"concepts/#execution-flow","title":"Execution Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Network\n    participant Pipeline\n    participant Task\n    participant Robot\n    participant LLM\n    participant Tool\n\n    User-&gt;&gt;Network: run(message, context)\n    Network-&gt;&gt;Pipeline: call(initial_result)\n    Pipeline-&gt;&gt;Task: call(result)\n    Task-&gt;&gt;Robot: call(enhanced_result)\n    Robot-&gt;&gt;LLM: inference(messages, tools)\n\n    alt Tool Call\n        LLM--&gt;&gt;Robot: tool_call\n        Robot-&gt;&gt;Tool: execute(params)\n        Tool--&gt;&gt;Robot: result\n        Robot-&gt;&gt;LLM: continue with result\n    end\n\n    LLM--&gt;&gt;Robot: response\n    Robot--&gt;&gt;Task: RobotResult\n    Task--&gt;&gt;Pipeline: result.continue(value)\n\n    alt Optional Task Activated\n        Pipeline-&gt;&gt;Task: call activated task\n    end\n\n    Pipeline--&gt;&gt;Network: final result\n    Network--&gt;&gt;User: SimpleFlow::Result</code></pre>"},{"location":"concepts/#conditional-routing","title":"Conditional Routing","text":"<p>Use custom Robot subclasses to implement intelligent routing:</p> <pre><code>class ClassifierRobot &lt; RobotLab::Robot\n  def call(result)\n    robot_result = run(**extract_run_context(result))\n\n    new_result = result\n      .with_context(@name.to_sym, robot_result)\n      .continue(robot_result)\n\n    # Activate appropriate specialist\n    category = robot_result.last_text_content.to_s.downcase\n    case category\n    when /billing/ then new_result.activate(:billing)\n    when /technical/ then new_result.activate(:technical)\n    else new_result.activate(:general)\n    end\n  end\nend\n</code></pre>"},{"location":"concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Build your first robot</li> <li>Building Robots - Detailed robot creation guide</li> <li>Creating Networks - Network orchestration patterns</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for RobotLab.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":"<p>The fundamental building blocks of RobotLab:</p> Class Description Robot LLM-powered agent with personality and tools Network Orchestrates multiple robots State Manages conversation and workflow data Tool Custom function robots can call Memory Shared key-value store"},{"location":"api/#messages","title":"Messages","text":"<p>Message types for LLM communication:</p> Class Description UserMessage User input with metadata TextMessage Assistant text response ToolCallMessage Tool execution request ToolResultMessage Tool execution result"},{"location":"api/#adapters","title":"Adapters","text":"<p>Provider-specific message conversion:</p> Class Description Anthropic Claude models adapter OpenAI GPT models adapter Gemini Google Gemini adapter"},{"location":"api/#mcp-model-context-protocol","title":"MCP (Model Context Protocol)","text":"<p>Connect to external tool servers:</p> Class Description Client MCP server connection Server Server configuration Transports Connection transports"},{"location":"api/#streaming","title":"Streaming","text":"<p>Real-time response streaming:</p> Class Description Context Streaming context Events Event utilities"},{"location":"api/#history","title":"History","text":"<p>Conversation persistence:</p> Class Description Config History configuration ThreadManager Thread lifecycle ActiveRecordAdapter Rails adapter"},{"location":"api/#module-methods","title":"Module Methods","text":""},{"location":"api/#robotlab","title":"RobotLab","text":"<pre><code># Configuration\nRobotLab.configuration\nRobotLab.configure { |config| ... }\n\n# Building\nRobotLab.build { ... }\nRobotLab.create_network { ... }\nRobotLab.create_state(...)\n</code></pre> <p>See individual class documentation for detailed method references.</p>"},{"location":"api/adapters/","title":"Adapters","text":"<p>LLM provider adapters for unified API access.</p>"},{"location":"api/adapters/#overview","title":"Overview","text":"<p>Adapters provide a consistent interface to different LLM providers, handling the translation between RobotLab's message format and provider-specific APIs.</p> <pre><code># Configure globally\nRobotLab.configure do |config|\n  config.default_model = \"claude-sonnet-4\"\n  # Adapter is selected automatically based on model\nend\n\n# Or configure per-robot\nrobot = RobotLab.build do\n  model \"gpt-4o\"  # Uses OpenAI adapter\nend\n</code></pre>"},{"location":"api/adapters/#adapter-selection","title":"Adapter Selection","text":"<p>Adapters are automatically selected based on model name:</p> Model Pattern Adapter <code>claude-*</code>, <code>anthropic/*</code> Anthropic <code>gpt-*</code>, <code>o1-*</code>, <code>openai/*</code> OpenAI <code>gemini-*</code>, <code>google/*</code> Gemini"},{"location":"api/adapters/#common-interface","title":"Common Interface","text":"<p>All adapters implement:</p> <pre><code>adapter.chat(\n  messages: messages,\n  model: model,\n  tools: tools,\n  system: system_prompt,\n  streaming: callback\n)\n# =&gt; Response with content and usage\n</code></pre>"},{"location":"api/adapters/#available-adapters","title":"Available Adapters","text":"Adapter Description Anthropic Claude models via Anthropic API OpenAI GPT models via OpenAI API Gemini Gemini models via Google AI"},{"location":"api/adapters/#configuration","title":"Configuration","text":""},{"location":"api/adapters/#api-keys","title":"API Keys","text":"<p>Set via environment variables:</p> <pre><code>export ANTHROPIC_API_KEY=\"sk-ant-...\"\nexport OPENAI_API_KEY=\"sk-...\"\nexport GOOGLE_AI_API_KEY=\"...\"\n</code></pre>"},{"location":"api/adapters/#custom-endpoints","title":"Custom Endpoints","text":"<pre><code>RobotLab.configure do |config|\n  config.adapter_options = {\n    anthropic: { base_url: \"https://custom.anthropic.endpoint\" },\n    openai: { base_url: \"https://custom.openai.endpoint\" }\n  }\nend\n</code></pre>"},{"location":"api/adapters/#creating-custom-adapters","title":"Creating Custom Adapters","text":"<p>Implement the adapter interface:</p> <pre><code>class MyAdapter\n  def chat(messages:, model:, tools: [], system: nil, streaming: nil)\n    # Translate messages to provider format\n    # Make API call\n    # Translate response back\n\n    Response.new(\n      content: content,\n      tool_calls: tool_calls,\n      usage: { input_tokens: x, output_tokens: y }\n    )\n  end\nend\n\n# Register the adapter\nRobotLab.register_adapter(:my_provider, MyAdapter)\n</code></pre>"},{"location":"api/adapters/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide</li> <li>Streaming Guide</li> </ul>"},{"location":"api/adapters/anthropic/","title":"Anthropic Adapter","text":"<p>Adapter for Claude models via Anthropic API.</p>"},{"location":"api/adapters/anthropic/#class-robotlabadaptersanthropic","title":"Class: <code>RobotLab::Adapters::Anthropic</code>","text":"<pre><code># Automatically used for Claude models\nrobot = RobotLab.build do\n  model \"claude-sonnet-4\"\nend\n</code></pre>"},{"location":"api/adapters/anthropic/#supported-models","title":"Supported Models","text":"Model Description <code>claude-sonnet-4</code> Latest Sonnet (recommended) <code>claude-opus-4</code> Most capable model <code>claude-3-5-sonnet-latest</code> Claude 3.5 Sonnet <code>claude-3-5-haiku-latest</code> Fast, efficient model"},{"location":"api/adapters/anthropic/#configuration","title":"Configuration","text":""},{"location":"api/adapters/anthropic/#api-key","title":"API Key","text":"<pre><code>export ANTHROPIC_API_KEY=\"sk-ant-api03-...\"\n</code></pre>"},{"location":"api/adapters/anthropic/#options","title":"Options","text":"<pre><code>RobotLab.configure do |config|\n  config.adapter_options = {\n    anthropic: {\n      base_url: \"https://api.anthropic.com\",\n      api_version: \"2024-01-01\",\n      timeout: 120,\n      max_tokens: 4096\n    }\n  }\nend\n</code></pre>"},{"location":"api/adapters/anthropic/#features","title":"Features","text":""},{"location":"api/adapters/anthropic/#streaming","title":"Streaming","text":"<pre><code>result = robot.run(state: state) do |event|\n  case event\n  when :text_delta\n    print event.text\n  when :tool_call\n    puts \"Calling: #{event.name}\"\n  end\nend\n</code></pre>"},{"location":"api/adapters/anthropic/#tool-use","title":"Tool Use","text":"<p>Tools are automatically converted to Anthropic's format:</p> <pre><code>robot = RobotLab.build do\n  model \"claude-sonnet-4\"\n\n  tool :search do\n    description \"Search the database\"\n    parameter :query, type: :string, required: true\n    handler { |query:, **_| Database.search(query) }\n  end\nend\n</code></pre>"},{"location":"api/adapters/anthropic/#extended-thinking","title":"Extended Thinking","text":"<p>For complex reasoning tasks:</p> <pre><code>robot = RobotLab.build do\n  model \"claude-sonnet-4\"\n  # Extended thinking is automatically enabled for supported models\nend\n</code></pre>"},{"location":"api/adapters/anthropic/#response-format","title":"Response Format","text":"<pre><code>{\n  content: [TextMessage, ...],\n  tool_calls: [ToolCallMessage, ...],\n  usage: {\n    input_tokens: 150,\n    output_tokens: 250,\n    cache_creation_input_tokens: 0,\n    cache_read_input_tokens: 0\n  },\n  stop_reason: \"end_turn\"\n}\n</code></pre>"},{"location":"api/adapters/anthropic/#error-handling","title":"Error Handling","text":"<pre><code>begin\n  result = robot.run(state: state)\nrescue RobotLab::Adapters::RateLimitError =&gt; e\n  sleep(e.retry_after)\n  retry\nrescue RobotLab::Adapters::APIError =&gt; e\n  logger.error(\"Anthropic API error: #{e.message}\")\nend\n</code></pre>"},{"location":"api/adapters/anthropic/#see-also","title":"See Also","text":"<ul> <li>Adapters Overview</li> <li>Streaming Guide</li> <li>Anthropic API Documentation</li> </ul>"},{"location":"api/adapters/gemini/","title":"Gemini Adapter","text":"<p>Adapter for Gemini models via Google AI API.</p>"},{"location":"api/adapters/gemini/#class-robotlabadaptersgemini","title":"Class: <code>RobotLab::Adapters::Gemini</code>","text":"<pre><code># Automatically used for Gemini models\nrobot = RobotLab.build do\n  model \"gemini-1.5-pro\"\nend\n</code></pre>"},{"location":"api/adapters/gemini/#supported-models","title":"Supported Models","text":"Model Description <code>gemini-1.5-pro</code> Most capable Gemini <code>gemini-1.5-flash</code> Fast, efficient model <code>gemini-1.5-flash-8b</code> Lightweight model <code>gemini-2.0-flash-exp</code> Experimental next-gen"},{"location":"api/adapters/gemini/#configuration","title":"Configuration","text":""},{"location":"api/adapters/gemini/#api-key","title":"API Key","text":"<pre><code>export GOOGLE_AI_API_KEY=\"...\"\n</code></pre>"},{"location":"api/adapters/gemini/#options","title":"Options","text":"<pre><code>RobotLab.configure do |config|\n  config.adapter_options = {\n    gemini: {\n      base_url: \"https://generativelanguage.googleapis.com\",\n      timeout: 120,\n      max_tokens: 8192\n    }\n  }\nend\n</code></pre>"},{"location":"api/adapters/gemini/#vertex-ai","title":"Vertex AI","text":"<pre><code>RobotLab.configure do |config|\n  config.adapter_options = {\n    gemini: {\n      base_url: \"https://us-central1-aiplatform.googleapis.com\",\n      project_id: \"your-project\",\n      location: \"us-central1\"\n    }\n  }\nend\n</code></pre>"},{"location":"api/adapters/gemini/#features","title":"Features","text":""},{"location":"api/adapters/gemini/#streaming","title":"Streaming","text":"<pre><code>result = robot.run(state: state) do |event|\n  case event\n  when :text_delta\n    print event.text\n  when :tool_call\n    puts \"Calling: #{event.name}\"\n  end\nend\n</code></pre>"},{"location":"api/adapters/gemini/#tool-use","title":"Tool Use","text":"<p>Tools are automatically converted to Gemini's format:</p> <pre><code>robot = RobotLab.build do\n  model \"gemini-1.5-pro\"\n\n  tool :search_products do\n    description \"Search product catalog\"\n    parameter :query, type: :string, required: true\n    parameter :category, type: :string\n    handler { |query:, category: nil, **_| Catalog.search(query, category) }\n  end\nend\n</code></pre>"},{"location":"api/adapters/gemini/#long-context","title":"Long Context","text":"<p>Gemini supports very long contexts:</p> <pre><code>robot = RobotLab.build do\n  model \"gemini-1.5-pro\"\n  # Supports up to 2M tokens context\nend\n</code></pre>"},{"location":"api/adapters/gemini/#response-format","title":"Response Format","text":"<pre><code>{\n  content: [TextMessage, ...],\n  tool_calls: [ToolCallMessage, ...],\n  usage: {\n    input_tokens: 150,\n    output_tokens: 250\n  },\n  stop_reason: \"STOP\"\n}\n</code></pre>"},{"location":"api/adapters/gemini/#error-handling","title":"Error Handling","text":"<pre><code>begin\n  result = robot.run(state: state)\nrescue RobotLab::Adapters::RateLimitError =&gt; e\n  sleep(e.retry_after || 60)\n  retry\nrescue RobotLab::Adapters::APIError =&gt; e\n  logger.error(\"Gemini API error: #{e.message}\")\nend\n</code></pre>"},{"location":"api/adapters/gemini/#see-also","title":"See Also","text":"<ul> <li>Adapters Overview</li> <li>Streaming Guide</li> <li>Google AI Documentation</li> </ul>"},{"location":"api/adapters/openai/","title":"OpenAI Adapter","text":"<p>Adapter for GPT models via OpenAI API.</p>"},{"location":"api/adapters/openai/#class-robotlabadaptersopenai","title":"Class: <code>RobotLab::Adapters::OpenAI</code>","text":"<pre><code># Automatically used for GPT models\nrobot = RobotLab.build do\n  model \"gpt-4o\"\nend\n</code></pre>"},{"location":"api/adapters/openai/#supported-models","title":"Supported Models","text":"Model Description <code>gpt-4o</code> Latest GPT-4 Omni <code>gpt-4o-mini</code> Fast, efficient GPT-4 <code>gpt-4-turbo</code> GPT-4 Turbo <code>o1-preview</code> Reasoning model <code>o1-mini</code> Fast reasoning model"},{"location":"api/adapters/openai/#configuration","title":"Configuration","text":""},{"location":"api/adapters/openai/#api-key","title":"API Key","text":"<pre><code>export OPENAI_API_KEY=\"sk-...\"\n</code></pre>"},{"location":"api/adapters/openai/#options","title":"Options","text":"<pre><code>RobotLab.configure do |config|\n  config.adapter_options = {\n    openai: {\n      base_url: \"https://api.openai.com/v1\",\n      organization: \"org-...\",\n      timeout: 120,\n      max_tokens: 4096\n    }\n  }\nend\n</code></pre>"},{"location":"api/adapters/openai/#azure-openai","title":"Azure OpenAI","text":"<pre><code>RobotLab.configure do |config|\n  config.adapter_options = {\n    openai: {\n      base_url: \"https://your-resource.openai.azure.com\",\n      api_key: ENV[\"AZURE_OPENAI_KEY\"],\n      api_version: \"2024-02-15-preview\"\n    }\n  }\nend\n</code></pre>"},{"location":"api/adapters/openai/#features","title":"Features","text":""},{"location":"api/adapters/openai/#streaming","title":"Streaming","text":"<pre><code>result = robot.run(state: state) do |event|\n  case event\n  when :text_delta\n    print event.text\n  when :tool_call\n    puts \"Calling: #{event.name}\"\n  end\nend\n</code></pre>"},{"location":"api/adapters/openai/#tool-use","title":"Tool Use","text":"<p>Tools are automatically converted to OpenAI's function calling format:</p> <pre><code>robot = RobotLab.build do\n  model \"gpt-4o\"\n\n  tool :get_weather do\n    description \"Get current weather\"\n    parameter :location, type: :string, required: true\n    handler { |location:, **_| WeatherAPI.fetch(location) }\n  end\nend\n</code></pre>"},{"location":"api/adapters/openai/#json-mode","title":"JSON Mode","text":"<pre><code>robot = RobotLab.build do\n  model \"gpt-4o\"\n  template \"Always respond with valid JSON.\"\n  # Response format is automatically configured\nend\n</code></pre>"},{"location":"api/adapters/openai/#response-format","title":"Response Format","text":"<pre><code>{\n  content: [TextMessage, ...],\n  tool_calls: [ToolCallMessage, ...],\n  usage: {\n    input_tokens: 150,\n    output_tokens: 250,\n    total_tokens: 400\n  },\n  stop_reason: \"stop\"\n}\n</code></pre>"},{"location":"api/adapters/openai/#error-handling","title":"Error Handling","text":"<pre><code>begin\n  result = robot.run(state: state)\nrescue RobotLab::Adapters::RateLimitError =&gt; e\n  sleep(e.retry_after || 60)\n  retry\nrescue RobotLab::Adapters::APIError =&gt; e\n  logger.error(\"OpenAI API error: #{e.message}\")\nend\n</code></pre>"},{"location":"api/adapters/openai/#see-also","title":"See Also","text":"<ul> <li>Adapters Overview</li> <li>Streaming Guide</li> <li>OpenAI API Documentation</li> </ul>"},{"location":"api/core/","title":"Core Classes","text":"<p>The fundamental classes that power RobotLab.</p>"},{"location":"api/core/#overview","title":"Overview","text":"<pre><code>classDiagram\n    class Robot {\n        +name: String\n        +description: String\n        +model: String\n        +template: String\n        +tools: Array~Tool~\n        +run(state, network)\n    }\n\n    class Network {\n        +name: String\n        +robots: Hash\n        +router: Proc\n        +run(state)\n    }\n\n    class State {\n        +data: StateProxy\n        +results: Array\n        +messages: Array\n        +memory: Memory\n    }\n\n    class Tool {\n        +name: String\n        +description: String\n        +parameters: Hash\n        +handler: Proc\n    }\n\n    class Memory {\n        +remember(key, value)\n        +recall(key)\n        +forget(key)\n        +scoped(namespace)\n    }\n\n    Network --&gt; Robot : contains\n    Robot --&gt; Tool : has\n    State --&gt; Memory : has\n    Network --&gt; State : uses</code></pre>"},{"location":"api/core/#classes","title":"Classes","text":"Class Purpose Robot LLM agent with personality, tools, and model configuration Network Container for robots with routing and orchestration State Conversation state with data, results, and memory Tool Callable function with parameters and handler Memory Namespaced key-value store for sharing data"},{"location":"api/core/#quick-examples","title":"Quick Examples","text":""},{"location":"api/core/#robot","title":"Robot","text":"<pre><code>robot = RobotLab.build do\n  name \"assistant\"\n  model \"claude-sonnet-4\"\n  template \"You are helpful.\"\n\n  tool :greet do\n    parameter :name, type: :string\n    handler { |name:, **_| \"Hello, #{name}!\" }\n  end\nend\n</code></pre>"},{"location":"api/core/#network","title":"Network","text":"<pre><code>network = RobotLab.create_network do\n  name \"my_network\"\n  add_robot robot\n  router -&gt;(args) { args.call_count.zero? ? :assistant : nil }\nend\n</code></pre>"},{"location":"api/core/#state","title":"State","text":"<pre><code>state = RobotLab.create_state(\n  message: \"Hello\",\n  data: { user_id: \"123\" }\n)\n</code></pre>"},{"location":"api/core/#tool","title":"Tool","text":"<pre><code>tool = RobotLab::Tool.new(\n  name: \"get_time\",\n  description: \"Get current time\",\n  handler: -&gt;(**, _) { Time.now.to_s }\n)\n</code></pre>"},{"location":"api/core/#memory","title":"Memory","text":"<pre><code>state.memory.remember(\"key\", \"value\")\nvalue = state.memory.recall(\"key\")\n</code></pre>"},{"location":"api/core/memory/","title":"Memory","text":"<p>Namespaced key-value store for sharing data between robots.</p>"},{"location":"api/core/memory/#class-robotlabmemory","title":"Class: <code>RobotLab::Memory</code>","text":"<pre><code>memory = state.memory\n\nmemory.remember(\"key\", \"value\")\nvalue = memory.recall(\"key\")\n</code></pre>"},{"location":"api/core/memory/#constants","title":"Constants","text":""},{"location":"api/core/memory/#shared_namespace","title":"SHARED_NAMESPACE","text":"<pre><code>Memory::SHARED_NAMESPACE  # =&gt; \"SHARED\"\n</code></pre> <p>Conventional namespace for cross-robot data.</p>"},{"location":"api/core/memory/#constructor","title":"Constructor","text":"<pre><code>memory = Memory.new(initial_data = {})\n</code></pre>"},{"location":"api/core/memory/#methods","title":"Methods","text":""},{"location":"api/core/memory/#remember","title":"remember","text":"<pre><code>memory.remember(key, value)\n</code></pre> <p>Store a value.</p> <p>Parameters:</p> Name Type Description <code>key</code> <code>String</code>, <code>Symbol</code> Storage key <code>value</code> <code>Object</code> Value to store"},{"location":"api/core/memory/#recall","title":"recall","text":"<pre><code>memory.recall(key)  # =&gt; Object | nil\n</code></pre> <p>Retrieve a value.</p> <p>Parameters:</p> Name Type Description <code>key</code> <code>String</code>, <code>Symbol</code> Storage key <p>Returns: Stored value or <code>nil</code>.</p>"},{"location":"api/core/memory/#exists","title":"exists?","text":"<pre><code>memory.exists?(key)  # =&gt; Boolean\n</code></pre> <p>Check if key exists.</p>"},{"location":"api/core/memory/#forget","title":"forget","text":"<pre><code>memory.forget(key)  # =&gt; Object | nil\n</code></pre> <p>Remove a key, returns the value.</p>"},{"location":"api/core/memory/#all","title":"all","text":"<pre><code>memory.all  # =&gt; Hash\n</code></pre> <p>Get all stored data.</p>"},{"location":"api/core/memory/#namespaces","title":"namespaces","text":"<pre><code>memory.namespaces  # =&gt; Array&lt;String&gt;\n</code></pre> <p>List all namespaces.</p>"},{"location":"api/core/memory/#clear","title":"clear","text":"<pre><code>memory.clear\n</code></pre> <p>Clear all data in current scope.</p>"},{"location":"api/core/memory/#clear_all","title":"clear_all","text":"<pre><code>memory.clear_all\n</code></pre> <p>Clear all data globally.</p>"},{"location":"api/core/memory/#search","title":"search","text":"<pre><code>memory.search(pattern)  # =&gt; Hash\n</code></pre> <p>Find keys matching pattern.</p> <p>Parameters:</p> Name Type Description <code>pattern</code> <code>String</code> Glob pattern (e.g., \"user:*\")"},{"location":"api/core/memory/#stats","title":"stats","text":"<pre><code>memory.stats  # =&gt; Hash\n</code></pre> <p>Get memory statistics.</p> <p>Returns:</p> <pre><code>{\n  total_keys: 15,\n  namespaces: [\"user\", \"session\"]\n}\n</code></pre>"},{"location":"api/core/memory/#scoped","title":"scoped","text":"<pre><code>scoped_memory = memory.scoped(namespace)  # =&gt; ScopedMemory\n</code></pre> <p>Create a scoped view.</p>"},{"location":"api/core/memory/#scopedmemory","title":"ScopedMemory","text":"<p>Scoped view with automatic key prefixing.</p>"},{"location":"api/core/memory/#methods_1","title":"Methods","text":"<p>All Memory methods are available:</p> <pre><code>scoped = memory.scoped(\"user:123\")\n\nscoped.remember(\"name\", \"Alice\")   # Key: \"user:123:name\"\nscoped.recall(\"name\")              # =&gt; \"Alice\"\nscoped.exists?(\"name\")             # =&gt; true\nscoped.forget(\"name\")\nscoped.all                         # Only \"user:123:*\" keys\nscoped.clear                       # Clear only this scope\n</code></pre>"},{"location":"api/core/memory/#nested-scopes","title":"Nested Scopes","text":"<pre><code>user = memory.scoped(\"user:123\")\nprefs = user.scoped(\"preferences\")\n\nprefs.remember(\"theme\", \"dark\")\n# Full key: \"user:123:preferences:theme\"\n</code></pre>"},{"location":"api/core/memory/#examples","title":"Examples","text":""},{"location":"api/core/memory/#basic-usage","title":"Basic Usage","text":"<pre><code>state.memory.remember(\"user_name\", \"Alice\")\nstate.memory.remember(\"order_count\", 5)\n\nname = state.memory.recall(\"user_name\")  # =&gt; \"Alice\"\ncount = state.memory.recall(\"order_count\")  # =&gt; 5\n</code></pre>"},{"location":"api/core/memory/#storing-objects","title":"Storing Objects","text":"<pre><code>state.memory.remember(\"user\", {\n  id: 123,\n  name: \"Alice\",\n  plan: \"pro\"\n})\n\nuser = state.memory.recall(\"user\")\nuser[:plan]  # =&gt; \"pro\"\n</code></pre>"},{"location":"api/core/memory/#scoped-organization","title":"Scoped Organization","text":"<pre><code># User-specific data\nuser = state.memory.scoped(\"user:#{user_id}\")\nuser.remember(\"last_login\", Time.now)\nuser.remember(\"preferences\", { theme: \"dark\" })\n\n# Session-specific data\nsession = state.memory.scoped(\"session:#{session_id}\")\nsession.remember(\"page_views\", 0)\n\n# Temporary working data\ntemp = state.memory.scoped(\"temp\")\ntemp.remember(\"intermediate_result\", calculation)\n</code></pre>"},{"location":"api/core/memory/#cross-robot-communication","title":"Cross-Robot Communication","text":"<pre><code># In classifier robot\nstate.memory.remember(\"SHARED:intent\", \"billing\")\nstate.memory.remember(\"SHARED:entities\", [\"order\", \"refund\"])\n\n# In handler robot\nintent = state.memory.recall(\"SHARED:intent\")\nentities = state.memory.recall(\"SHARED:entities\")\n</code></pre>"},{"location":"api/core/memory/#in-tool-handlers","title":"In Tool Handlers","text":"<pre><code>tool :update_preference do\n  handler do |key:, value:, state:, **_|\n    prefs = state.memory.scoped(\"preferences\")\n    old_value = prefs.recall(key)\n    prefs.remember(key, value)\n\n    {\n      success: true,\n      key: key,\n      old_value: old_value,\n      new_value: value\n    }\n  end\nend\n</code></pre>"},{"location":"api/core/memory/#search-and-iteration","title":"Search and Iteration","text":"<pre><code># Find all user keys\nuser_data = state.memory.search(\"user:*\")\n# =&gt; { \"user:123:name\" =&gt; \"Alice\", \"user:123:email\" =&gt; \"...\" }\n\n# Process all keys\nstate.memory.all.each do |key, value|\n  puts \"#{key}: #{value}\"\nend\n</code></pre>"},{"location":"api/core/memory/#cleanup","title":"Cleanup","text":"<pre><code># Clear temporary data\nstate.memory.scoped(\"temp\").clear\n\n# Clear specific namespace\nstate.memory.scoped(\"cache\").clear\n\n# Clear everything\nstate.memory.clear_all\n</code></pre>"},{"location":"api/core/memory/#caching-pattern","title":"Caching Pattern","text":"<pre><code>def cached_fetch(state, key, &amp;block)\n  cache = state.memory.scoped(\"cache\")\n  cached = cache.recall(key)\n  return cached if cached\n\n  result = block.call\n  cache.remember(key, result)\n  result\nend\n\n# Usage\ndata = cached_fetch(state, \"expensive:#{id}\") do\n  ExpensiveService.fetch(id)\nend\n</code></pre>"},{"location":"api/core/memory/#accumulating-results","title":"Accumulating Results","text":"<pre><code># In each robot, accumulate findings\nfindings = state.memory.recall(\"findings\") || []\nfindings &lt;&lt; { robot: robot.name, finding: new_finding }\nstate.memory.remember(\"findings\", findings)\n\n# In final robot, aggregate\nall_findings = state.memory.recall(\"findings\")\nsummary = all_findings.group_by { |f| f[:robot] }\n</code></pre>"},{"location":"api/core/memory/#see-also","title":"See Also","text":"<ul> <li>Memory Guide</li> <li>State</li> <li>State Management Architecture</li> </ul>"},{"location":"api/core/network/","title":"Network","text":"<p>Orchestrates multiple robots using SimpleFlow pipelines with DAG-based execution.</p>"},{"location":"api/core/network/#class-robotlabnetwork","title":"Class: <code>RobotLab::Network</code>","text":"<pre><code>network = RobotLab.create_network(name: \"support\") do\n  task :classifier, classifier_robot, depends_on: :none\n  task :billing, billing_robot, depends_on: :optional\nend\n</code></pre>"},{"location":"api/core/network/#attributes","title":"Attributes","text":""},{"location":"api/core/network/#name","title":"name","text":"<pre><code>network.name  # =&gt; String\n</code></pre> <p>Network identifier for logging and debugging.</p>"},{"location":"api/core/network/#robots","title":"robots","text":"<pre><code>network.robots  # =&gt; Hash&lt;String, Robot&gt;\n</code></pre> <p>Hash of robots keyed by name.</p>"},{"location":"api/core/network/#pipeline","title":"pipeline","text":"<pre><code>network.pipeline  # =&gt; SimpleFlow::Pipeline\n</code></pre> <p>The underlying SimpleFlow pipeline.</p>"},{"location":"api/core/network/#methods","title":"Methods","text":""},{"location":"api/core/network/#run","title":"run","text":"<pre><code>result = network.run(\n  message: \"Help me\",\n  customer_id: 123,\n  **context\n)\n# =&gt; SimpleFlow::Result\n</code></pre> <p>Execute the network pipeline.</p> <p>Parameters:</p> Name Type Description <code>message</code> <code>String</code> The input message <code>**context</code> <code>Hash</code> Additional context passed to all robots <p>Returns: <code>SimpleFlow::Result</code></p>"},{"location":"api/core/network/#task","title":"task","text":"<pre><code>network.task(name, robot, context: {}, mcp: :none, tools: :none, memory: nil, depends_on: :none)\n# =&gt; self\n</code></pre> <p>Add a task to the pipeline with optional per-task configuration.</p> <p>Parameters:</p> Name Type Description <code>name</code> <code>Symbol</code> Task identifier <code>robot</code> <code>Robot</code> Robot instance to execute <code>context</code> <code>Hash</code> Task-specific context (deep-merged with run params) <code>mcp</code> <code>:none</code>, Array MCP server config (<code>:none</code> or array of servers) <code>tools</code> <code>:none</code>, Array Tools config (<code>:none</code> or array of tools) <code>memory</code> <code>Memory</code>, <code>nil</code> Task-specific memory <code>depends_on</code> <code>:none</code>, <code>Array&lt;Symbol&gt;</code>, <code>:optional</code> Task dependencies <p>Dependency Types:</p> Value Description <code>:none</code> No dependencies, runs first <code>[:task1, :task2]</code> Waits for listed tasks to complete <code>:optional</code> Only runs when explicitly activated"},{"location":"api/core/network/#add_robot","title":"add_robot","text":"<pre><code>network.add_robot(robot)\n# =&gt; self\n</code></pre> <p>Add a robot without creating a pipeline task. Useful for robots referenced by other tasks.</p>"},{"location":"api/core/network/#robot","title":"robot / []","text":"<pre><code>network.robot(\"billing\")  # =&gt; Robot\nnetwork[\"billing\"]        # =&gt; Robot (alias)\n</code></pre> <p>Get robot by name.</p>"},{"location":"api/core/network/#available_robots","title":"available_robots","text":"<pre><code>network.available_robots  # =&gt; Array&lt;Robot&gt;\n</code></pre> <p>Returns all robot instances.</p>"},{"location":"api/core/network/#visualize","title":"visualize","text":"<pre><code>network.visualize  # =&gt; String\n</code></pre> <p>ASCII visualization of the pipeline.</p>"},{"location":"api/core/network/#to_mermaid","title":"to_mermaid","text":"<pre><code>network.to_mermaid  # =&gt; String\n</code></pre> <p>Mermaid diagram definition.</p>"},{"location":"api/core/network/#execution_plan","title":"execution_plan","text":"<pre><code>network.execution_plan  # =&gt; String\n</code></pre> <p>Human-readable execution plan.</p>"},{"location":"api/core/network/#to_h","title":"to_h","text":"<pre><code>network.to_h  # =&gt; Hash\n</code></pre> <p>Hash representation of network configuration.</p> <pre><code>{\n  name: \"support\",\n  robots: [\"classifier\", \"billing\", \"technical\"],\n  tasks: [\"classifier\", \"billing\", \"technical\"],\n  optional_tasks: [:billing, :technical]\n}\n</code></pre>"},{"location":"api/core/network/#simpleflowresult","title":"SimpleFlow::Result","text":"<p>When <code>run</code> is called, a <code>SimpleFlow::Result</code> is returned:</p>"},{"location":"api/core/network/#attributes_1","title":"Attributes","text":"<pre><code>result.value      # Final task's output (RobotResult)\nresult.context    # Hash of all task results\nresult.halted?    # Whether execution stopped early\nresult.continued? # Whether execution continues\n</code></pre>"},{"location":"api/core/network/#context-structure","title":"Context Structure","text":"<pre><code>result.context[:run_params]   # Original run parameters\nresult.context[:classifier]   # Classifier robot's RobotResult\nresult.context[:billing]      # Billing robot's RobotResult (if activated)\n</code></pre>"},{"location":"api/core/network/#builder-dsl","title":"Builder DSL","text":""},{"location":"api/core/network/#task_1","title":"task","text":"<pre><code>network = RobotLab.create_network(name: \"pipeline\") do\n  task :first, robot1, depends_on: :none\n  task :second, robot2, depends_on: [:first]\n  task :optional, robot3, depends_on: :optional\nend\n</code></pre>"},{"location":"api/core/network/#task-with-context","title":"task with context","text":"<pre><code>network = RobotLab.create_network(name: \"support\") do\n  task :classifier, classifier_robot, depends_on: :none\n  task :billing, billing_robot,\n       context: { department: \"billing\", escalation_level: 2 },\n       depends_on: :optional\n  task :technical, technical_robot,\n       context: { department: \"technical\" },\n       tools: [DebugTool, LogTool],\n       depends_on: :optional\nend\n</code></pre>"},{"location":"api/core/network/#examples","title":"Examples","text":""},{"location":"api/core/network/#sequential-pipeline","title":"Sequential Pipeline","text":"<pre><code>network = RobotLab.create_network(name: \"pipeline\") do\n  task :extract, extractor, depends_on: :none\n  task :transform, transformer, depends_on: [:extract]\n  task :load, loader, depends_on: [:transform]\nend\n\nresult = network.run(message: \"Process this document\")\nputs result.value.last_text_content\n</code></pre>"},{"location":"api/core/network/#parallel-execution","title":"Parallel Execution","text":"<pre><code>network = RobotLab.create_network(name: \"analysis\", concurrency: :threads) do\n  task :fetch, fetcher, depends_on: :none\n\n  # Run in parallel\n  task :sentiment, sentiment_bot, depends_on: [:fetch]\n  task :entities, entity_bot, depends_on: [:fetch]\n\n  # Wait for both\n  task :merge, merger, depends_on: [:sentiment, :entities]\nend\n</code></pre>"},{"location":"api/core/network/#conditional-routing","title":"Conditional Routing","text":"<pre><code>class ClassifierRobot &lt; RobotLab::Robot\n  def call(result)\n    robot_result = run(**extract_run_context(result))\n\n    new_result = result\n      .with_context(@name.to_sym, robot_result)\n      .continue(robot_result)\n\n    category = robot_result.last_text_content.to_s.downcase\n    case category\n    when /billing/ then new_result.activate(:billing)\n    when /technical/ then new_result.activate(:technical)\n    else new_result.activate(:general)\n    end\n  end\nend\n\nnetwork = RobotLab.create_network(name: \"support\") do\n  task :classifier, ClassifierRobot.new(name: \"classifier\", template: :classifier),\n       depends_on: :none\n  task :billing, billing_robot, depends_on: :optional\n  task :technical, technical_robot, depends_on: :optional\n  task :general, general_robot, depends_on: :optional\nend\n\nresult = network.run(message: \"I have a billing question\")\nputs result.value.last_text_content\n</code></pre>"},{"location":"api/core/network/#accessing-task-results","title":"Accessing Task Results","text":"<pre><code>result = network.run(message: \"Hello\")\n\n# Access individual task results\nclassifier_result = result.context[:classifier]\nputs \"Classification: #{classifier_result.last_text_content}\"\n\n# Check which optional task ran\nif result.context[:billing]\n  puts \"Billing handled the request\"\nelsif result.context[:technical]\n  puts \"Technical handled the request\"\nend\n</code></pre>"},{"location":"api/core/network/#see-also","title":"See Also","text":"<ul> <li>Creating Networks Guide</li> <li>Network Orchestration</li> <li>Robot</li> </ul>"},{"location":"api/core/robot/","title":"Robot","text":"<p>LLM-powered agent with personality, tools, and model configuration.</p>"},{"location":"api/core/robot/#class-robotlabrobot","title":"Class: <code>RobotLab::Robot</code>","text":"<pre><code>robot = RobotLab.build do\n  name \"assistant\"\n  description \"A helpful assistant\"\n  model \"claude-sonnet-4\"\n  template \"You are helpful.\"\nend\n</code></pre>"},{"location":"api/core/robot/#attributes","title":"Attributes","text":""},{"location":"api/core/robot/#name","title":"name","text":"<pre><code>robot.name  # =&gt; String\n</code></pre> <p>Unique identifier for the robot within a network.</p>"},{"location":"api/core/robot/#description","title":"description","text":"<pre><code>robot.description  # =&gt; String\n</code></pre> <p>Human-readable description of what the robot does.</p>"},{"location":"api/core/robot/#model","title":"model","text":"<pre><code>robot.model  # =&gt; String\n</code></pre> <p>LLM model identifier (e.g., \"claude-sonnet-4\", \"gpt-4o\").</p>"},{"location":"api/core/robot/#template","title":"template","text":"<pre><code>robot.template  # =&gt; String\n</code></pre> <p>System prompt that defines the robot's personality.</p>"},{"location":"api/core/robot/#local_tools","title":"local_tools","text":"<pre><code>robot.local_tools  # =&gt; Array&lt;Tool&gt;\n</code></pre> <p>Tools defined directly on the robot.</p>"},{"location":"api/core/robot/#mcp_clients","title":"mcp_clients","text":"<pre><code>robot.mcp_clients  # =&gt; Array&lt;MCP::Client&gt;\n</code></pre> <p>Connected MCP server clients.</p>"},{"location":"api/core/robot/#mcp_tools","title":"mcp_tools","text":"<pre><code>robot.mcp_tools  # =&gt; Array&lt;Tool&gt;\n</code></pre> <p>Tools discovered from MCP servers.</p>"},{"location":"api/core/robot/#mcp_config","title":"mcp_config","text":"<pre><code>robot.mcp_config  # =&gt; Symbol | Array\n</code></pre> <p>MCP configuration (<code>:inherit</code>, <code>:none</code>, or server array).</p>"},{"location":"api/core/robot/#tools_config","title":"tools_config","text":"<pre><code>robot.tools_config  # =&gt; Symbol | Array\n</code></pre> <p>Tools whitelist configuration (<code>:inherit</code>, <code>:none</code>, or tool names).</p>"},{"location":"api/core/robot/#methods","title":"Methods","text":""},{"location":"api/core/robot/#tools","title":"tools","text":"<pre><code>robot.tools  # =&gt; Array&lt;Tool&gt;\n</code></pre> <p>Returns all available tools (local + MCP, filtered by whitelist).</p>"},{"location":"api/core/robot/#run","title":"run","text":"<pre><code>result = robot.run(\n  state: state,\n  network: network,\n  streaming: nil,\n  **context\n)\n# =&gt; RobotResult\n</code></pre> <p>Execute the robot with the given state.</p> <p>Parameters:</p> Name Type Description <code>state</code> <code>State</code> Conversation state <code>network</code> <code>Network</code>, <code>NetworkRun</code>, <code>nil</code> Network context <code>streaming</code> <code>Proc</code>, <code>nil</code> Streaming callback <code>**context</code> <code>Hash</code> Additional context <p>Returns: <code>RobotResult</code></p>"},{"location":"api/core/robot/#disconnect","title":"disconnect","text":"<pre><code>robot.disconnect\n</code></pre> <p>Disconnect from all MCP servers.</p>"},{"location":"api/core/robot/#to_h","title":"to_h","text":"<pre><code>robot.to_h  # =&gt; Hash\n</code></pre> <p>Returns hash representation of the robot.</p>"},{"location":"api/core/robot/#builder-dsl","title":"Builder DSL","text":""},{"location":"api/core/robot/#name_1","title":"name","text":"<pre><code>name \"my_robot\"\n</code></pre> <p>Set the robot's name.</p>"},{"location":"api/core/robot/#description_1","title":"description","text":"<pre><code>description \"Handles customer inquiries\"\n</code></pre> <p>Set the robot's description.</p>"},{"location":"api/core/robot/#model_1","title":"model","text":"<pre><code>model \"claude-sonnet-4\"\n</code></pre> <p>Set the LLM model.</p>"},{"location":"api/core/robot/#template_1","title":"template","text":"<pre><code># Inline template\ntemplate \"You are a helpful assistant.\"\n\n# Template file (loads from template_path)\ntemplate \"support/system_prompt\"\n\n# Template file with variables\ntemplate \"support/system_prompt\", company: \"Acme\"\n</code></pre> <p>Set the system prompt.</p>"},{"location":"api/core/robot/#tool","title":"tool","text":"<pre><code>tool :tool_name do\n  description \"What the tool does\"\n  parameter :param, type: :string, required: true\n  handler { |param:, **_| do_something(param) }\nend\n</code></pre> <p>Define a tool for the robot.</p>"},{"location":"api/core/robot/#mcp","title":"mcp","text":"<pre><code>mcp :inherit  # Use network's MCP servers\nmcp :none     # No MCP servers\nmcp [         # Specific servers\n  { name: \"fs\", transport: { type: \"stdio\", command: \"mcp-fs\" } }\n]\n</code></pre> <p>Configure MCP servers.</p>"},{"location":"api/core/robot/#tools-whitelist","title":"tools (whitelist)","text":"<pre><code>tools :inherit            # Use network's tools\ntools :none               # No inherited tools\ntools %w[read_file write_file]  # Only these tools\n</code></pre> <p>Configure tool whitelist.</p>"},{"location":"api/core/robot/#examples","title":"Examples","text":""},{"location":"api/core/robot/#basic-robot","title":"Basic Robot","text":"<pre><code>robot = RobotLab.build do\n  name \"greeter\"\n  template \"You greet users warmly.\"\nend\n</code></pre>"},{"location":"api/core/robot/#robot-with-tools","title":"Robot with Tools","text":"<pre><code>robot = RobotLab.build do\n  name \"calculator\"\n  model \"claude-sonnet-4\"\n  template \"You help with math problems.\"\n\n  tool :add do\n    description \"Add two numbers\"\n    parameter :a, type: :number, required: true\n    parameter :b, type: :number, required: true\n    handler { |a:, b:, **_| a + b }\n  end\n\n  tool :multiply do\n    description \"Multiply two numbers\"\n    parameter :a, type: :number, required: true\n    parameter :b, type: :number, required: true\n    handler { |a:, b:, **_| a * b }\n  end\nend\n</code></pre>"},{"location":"api/core/robot/#robot-with-mcp","title":"Robot with MCP","text":"<pre><code>robot = RobotLab.build do\n  name \"developer\"\n  template \"You help with coding tasks.\"\n\n  mcp [\n    {\n      name: \"github\",\n      transport: { type: \"stdio\", command: \"mcp-server-github\" }\n    }\n  ]\n\n  tools %w[search_repositories create_issue]\nend\n</code></pre>"},{"location":"api/core/robot/#see-also","title":"See Also","text":"<ul> <li>Building Robots Guide</li> <li>Tool</li> <li>Network</li> </ul>"},{"location":"api/core/state/","title":"State","text":"<p>Manages conversation data, results, and memory.</p>"},{"location":"api/core/state/#class-robotlabstate","title":"Class: <code>RobotLab::State</code>","text":"<pre><code>state = RobotLab.create_state(\n  message: \"Hello\",\n  data: { user_id: \"123\" }\n)\n</code></pre>"},{"location":"api/core/state/#attributes","title":"Attributes","text":""},{"location":"api/core/state/#thread_id","title":"thread_id","text":"<pre><code>state.thread_id  # =&gt; String | nil\n</code></pre> <p>Conversation thread identifier for persistence.</p>"},{"location":"api/core/state/#memory","title":"memory","text":"<pre><code>state.memory  # =&gt; Memory\n</code></pre> <p>Shared key-value store.</p>"},{"location":"api/core/state/#methods","title":"Methods","text":""},{"location":"api/core/state/#data","title":"data","text":"<pre><code>state.data  # =&gt; StateProxy\n</code></pre> <p>Access workflow data as a proxy object.</p> <pre><code>state.data[:user_id]          # Hash access\nstate.data.user_id            # Method access\nstate.data[:status] = \"active\"\n</code></pre>"},{"location":"api/core/state/#results","title":"results","text":"<pre><code>state.results  # =&gt; Array&lt;RobotResult&gt;\n</code></pre> <p>All robot execution results.</p>"},{"location":"api/core/state/#messages","title":"messages","text":"<pre><code>state.messages  # =&gt; Array&lt;Message&gt;\n</code></pre> <p>Formatted conversation messages for LLM.</p>"},{"location":"api/core/state/#append_result","title":"append_result","text":"<pre><code>state.append_result(robot_result)\n</code></pre> <p>Add a robot result to history.</p>"},{"location":"api/core/state/#set_results","title":"set_results","text":"<pre><code>state.set_results(array_of_results)\n</code></pre> <p>Replace all results.</p>"},{"location":"api/core/state/#results_from","title":"results_from","text":"<pre><code>state.results_from(5)  # =&gt; Array&lt;RobotResult&gt;\n</code></pre> <p>Get results starting at index.</p>"},{"location":"api/core/state/#thread_id_1","title":"thread_id=","text":"<pre><code>state.thread_id = \"thread_123\"\n</code></pre> <p>Set the thread identifier.</p>"},{"location":"api/core/state/#format_history","title":"format_history","text":"<pre><code>state.format_history  # =&gt; Array&lt;Message&gt;\n</code></pre> <p>Format results as conversation history.</p>"},{"location":"api/core/state/#clone","title":"clone","text":"<pre><code>new_state = state.clone\n</code></pre> <p>Create a deep copy.</p>"},{"location":"api/core/state/#to_h","title":"to_h","text":"<pre><code>state.to_h  # =&gt; Hash\n</code></pre> <p>Hash representation.</p>"},{"location":"api/core/state/#to_json","title":"to_json","text":"<pre><code>state.to_json  # =&gt; String\n</code></pre> <p>JSON representation.</p>"},{"location":"api/core/state/#from_hash-class-method","title":"from_hash (class method)","text":"<pre><code>state = State.from_hash(hash)\n</code></pre> <p>Restore from hash.</p>"},{"location":"api/core/state/#stateproxy","title":"StateProxy","text":"<p>The <code>data</code> attribute is a <code>StateProxy</code>:</p> <pre><code>proxy = state.data\n\n# Hash-style access\nproxy[:key]\nproxy[:key] = value\n\n# Method-style access\nproxy.key\nproxy.key = value\n\n# Hash operations\nproxy.key?(:key)\nproxy.keys\nproxy.values\nproxy.each { |k, v| ... }\nproxy.merge!(other_hash)\nproxy.delete(:key)\nproxy.to_h\nproxy.empty?\nproxy.size\n</code></pre>"},{"location":"api/core/state/#creating-state","title":"Creating State","text":""},{"location":"api/core/state/#basic","title":"Basic","text":"<pre><code>state = RobotLab.create_state(message: \"Hello\")\n</code></pre>"},{"location":"api/core/state/#with-data","title":"With Data","text":"<pre><code>state = RobotLab.create_state(\n  message: \"Process order\",\n  data: {\n    user_id: \"user_123\",\n    order_id: \"ord_456\"\n  }\n)\n</code></pre>"},{"location":"api/core/state/#with-thread-id","title":"With Thread ID","text":"<pre><code># Via UserMessage\nmessage = UserMessage.new(\"Continue\", thread_id: \"thread_123\")\nstate = RobotLab.create_state(message: message)\n\n# Direct assignment\nstate = RobotLab.create_state(message: \"Continue\")\nstate.thread_id = \"thread_123\"\n</code></pre>"},{"location":"api/core/state/#with-existing-results","title":"With Existing Results","text":"<pre><code>state = RobotLab.create_state(\n  message: \"Follow up\",\n  results: previous_results\n)\n</code></pre>"},{"location":"api/core/state/#usermessage","title":"UserMessage","text":"<p>Enhanced message with metadata:</p> <pre><code>message = UserMessage.new(\n  \"What's my order status?\",\n  thread_id: \"thread_123\",\n  system_prompt: \"Respond in Spanish\",\n  metadata: { source: \"web\" }\n)\n\nmessage.content       # =&gt; \"What's my order status?\"\nmessage.thread_id     # =&gt; \"thread_123\"\nmessage.system_prompt # =&gt; \"Respond in Spanish\"\nmessage.metadata      # =&gt; { source: \"web\" }\nmessage.id            # =&gt; UUID\nmessage.created_at    # =&gt; Time\n</code></pre>"},{"location":"api/core/state/#examples","title":"Examples","text":""},{"location":"api/core/state/#accessing-data","title":"Accessing Data","text":"<pre><code>state = RobotLab.create_state(\n  message: \"Help\",\n  data: { user: { name: \"Alice\", plan: \"pro\" } }\n)\n\nstate.data[:user][:name]  # =&gt; \"Alice\"\nstate.data.to_h           # =&gt; { user: { name: \"Alice\", plan: \"pro\" } }\n</code></pre>"},{"location":"api/core/state/#working-with-results","title":"Working with Results","text":"<pre><code># After running network\nstate.results.size           # Number of results\nstate.results.last           # Most recent\nstate.results.map(&amp;:robot_name)  # [\"classifier\", \"support\"]\n</code></pre>"},{"location":"api/core/state/#using-memory","title":"Using Memory","text":"<pre><code>state.memory.remember(\"intent\", \"billing\")\nintent = state.memory.recall(\"intent\")\n\nscoped = state.memory.scoped(\"user:123\")\nscoped.remember(\"preference\", \"dark_mode\")\n</code></pre>"},{"location":"api/core/state/#serialization","title":"Serialization","text":"<pre><code># Save state\njson = state.to_json\nFile.write(\"state.json\", json)\n\n# Restore state\ndata = JSON.parse(File.read(\"state.json\"))\nstate = State.from_hash(data)\n</code></pre>"},{"location":"api/core/state/#see-also","title":"See Also","text":"<ul> <li>State Management Architecture</li> <li>Memory</li> <li>History Guide</li> </ul>"},{"location":"api/core/tool/","title":"Tool","text":"<p>Callable function that robots can use to interact with external systems.</p>"},{"location":"api/core/tool/#class-robotlabtool","title":"Class: <code>RobotLab::Tool</code>","text":"<pre><code>tool = RobotLab::Tool.new(\n  name: \"get_weather\",\n  description: \"Get weather for a location\",\n  parameters: { location: { type: \"string\", required: true } },\n  handler: -&gt;(location:, **_) { WeatherService.fetch(location) }\n)\n</code></pre>"},{"location":"api/core/tool/#constructor","title":"Constructor","text":"<pre><code>Tool.new(\n  name:,\n  description: nil,\n  parameters: {},\n  handler:,\n  mcp: false,\n  strict: false\n)\n</code></pre> <p>Parameters:</p> Name Type Description <code>name</code> <code>String</code> Tool identifier <code>description</code> <code>String</code> What the tool does <code>parameters</code> <code>Hash</code> Parameter definitions <code>handler</code> <code>Proc</code> Execution function <code>mcp</code> <code>Boolean</code> Is this an MCP tool? <code>strict</code> <code>Boolean</code> Strict parameter validation"},{"location":"api/core/tool/#attributes","title":"Attributes","text":""},{"location":"api/core/tool/#name","title":"name","text":"<pre><code>tool.name  # =&gt; String\n</code></pre> <p>Tool identifier.</p>"},{"location":"api/core/tool/#description","title":"description","text":"<pre><code>tool.description  # =&gt; String\n</code></pre> <p>Human-readable description.</p>"},{"location":"api/core/tool/#parameters","title":"parameters","text":"<pre><code>tool.parameters  # =&gt; Hash\n</code></pre> <p>Parameter schema.</p>"},{"location":"api/core/tool/#handler","title":"handler","text":"<pre><code>tool.handler  # =&gt; Proc\n</code></pre> <p>Function that executes the tool.</p>"},{"location":"api/core/tool/#mcp","title":"mcp","text":"<pre><code>tool.mcp  # =&gt; Boolean\n</code></pre> <p>Whether this is an MCP-sourced tool.</p>"},{"location":"api/core/tool/#strict","title":"strict","text":"<pre><code>tool.strict  # =&gt; Boolean\n</code></pre> <p>Whether to use strict parameter validation.</p>"},{"location":"api/core/tool/#methods","title":"Methods","text":""},{"location":"api/core/tool/#call","title":"call","text":"<pre><code>result = tool.call(\n  params,\n  robot: robot,\n  network: network,\n  state: state\n)\n</code></pre> <p>Execute the tool with parameters.</p>"},{"location":"api/core/tool/#to_h","title":"to_h","text":"<pre><code>tool.to_h  # =&gt; Hash\n</code></pre> <p>Hash representation.</p>"},{"location":"api/core/tool/#to_json","title":"to_json","text":"<pre><code>tool.to_json  # =&gt; String\n</code></pre> <p>JSON representation.</p>"},{"location":"api/core/tool/#to_json_schema","title":"to_json_schema","text":"<pre><code>tool.to_json_schema  # =&gt; Hash\n</code></pre> <p>JSON Schema representation for LLM.</p>"},{"location":"api/core/tool/#parameter-schema","title":"Parameter Schema","text":""},{"location":"api/core/tool/#basic-types","title":"Basic Types","text":"<pre><code>parameters: {\n  name: { type: \"string\" },\n  count: { type: \"integer\" },\n  price: { type: \"number\" },\n  active: { type: \"boolean\" },\n  tags: { type: \"array\" }\n}\n</code></pre>"},{"location":"api/core/tool/#required-parameters","title":"Required Parameters","text":"<pre><code>parameters: {\n  id: { type: \"string\", required: true }\n}\n</code></pre>"},{"location":"api/core/tool/#descriptions","title":"Descriptions","text":"<pre><code>parameters: {\n  query: {\n    type: \"string\",\n    description: \"Search query (supports wildcards)\"\n  }\n}\n</code></pre>"},{"location":"api/core/tool/#enums","title":"Enums","text":"<pre><code>parameters: {\n  status: {\n    type: \"string\",\n    enum: [\"pending\", \"active\", \"completed\"]\n  }\n}\n</code></pre>"},{"location":"api/core/tool/#defaults","title":"Defaults","text":"<pre><code>parameters: {\n  limit: {\n    type: \"integer\",\n    default: 10\n  }\n}\n</code></pre>"},{"location":"api/core/tool/#handler_1","title":"Handler","text":""},{"location":"api/core/tool/#basic-handler","title":"Basic Handler","text":"<pre><code>handler: -&gt;(param:, **_context) {\n  do_something(param)\n}\n</code></pre>"},{"location":"api/core/tool/#with-context","title":"With Context","text":"<pre><code>handler: -&gt;(param:, robot:, network:, state:) {\n  # robot - The executing Robot\n  # network - The NetworkRun\n  # state - Current State\n\n  user = state.data[:user_id]\n  state.memory.remember(\"last_action\", param)\n\n  perform_action(param, user)\n}\n</code></pre>"},{"location":"api/core/tool/#error-handling","title":"Error Handling","text":"<pre><code>handler: -&gt;(id:, **_) {\n  record = Record.find_by(id: id)\n\n  if record\n    { success: true, data: record.to_h }\n  else\n    { success: false, error: \"Not found\" }\n  end\nrescue StandardError =&gt; e\n  { success: false, error: e.message }\n}\n</code></pre>"},{"location":"api/core/tool/#builder-dsl","title":"Builder DSL","text":"<p>In robot builder:</p> <pre><code>tool :tool_name do\n  description \"What it does\"\n\n  parameter :param1, type: :string, required: true\n  parameter :param2, type: :integer, default: 10\n\n  handler do |param1:, param2:, **_context|\n    # Implementation\n  end\nend\n</code></pre>"},{"location":"api/core/tool/#toolmanifest","title":"ToolManifest","text":"<p>Wrap tools with modified metadata:</p> <pre><code>manifest = RobotLab::ToolManifest.new(\n  tool: original_tool,\n  name: \"custom_name\",\n  description: \"Custom description\"\n)\n\n# Original tool is used, metadata is overridden\n</code></pre>"},{"location":"api/core/tool/#attributes_1","title":"Attributes","text":"<ul> <li><code>tool</code> - The wrapped tool</li> <li><code>name</code> - Override name (or original)</li> <li><code>description</code> - Override description (or original)</li> <li><code>aliases</code> - Alternative names</li> </ul>"},{"location":"api/core/tool/#examples","title":"Examples","text":""},{"location":"api/core/tool/#simple-tool","title":"Simple Tool","text":"<pre><code>tool = Tool.new(\n  name: \"current_time\",\n  description: \"Get the current time\",\n  handler: -&gt;(**, _) { Time.now.iso8601 }\n)\n</code></pre>"},{"location":"api/core/tool/#tool-with-parameters","title":"Tool with Parameters","text":"<pre><code>tool = Tool.new(\n  name: \"search_users\",\n  description: \"Search users by criteria\",\n  parameters: {\n    query: {\n      type: \"string\",\n      description: \"Search query\",\n      required: true\n    },\n    limit: {\n      type: \"integer\",\n      description: \"Max results\",\n      default: 10\n    },\n    status: {\n      type: \"string\",\n      enum: [\"active\", \"inactive\", \"all\"],\n      default: \"active\"\n    }\n  },\n  handler: -&gt;(query:, limit:, status:, **_) {\n    User.search(query, limit: limit, status: status)\n  }\n)\n</code></pre>"},{"location":"api/core/tool/#api-integration-tool","title":"API Integration Tool","text":"<pre><code>tool = Tool.new(\n  name: \"fetch_stock_price\",\n  description: \"Get current stock price\",\n  parameters: {\n    symbol: { type: \"string\", required: true }\n  },\n  handler: -&gt;(symbol:, **_) {\n    response = HTTP.get(\"https://api.stocks.example/#{symbol}\")\n\n    if response.status.success?\n      JSON.parse(response.body)\n    else\n      { error: \"Failed to fetch\", status: response.status.code }\n    end\n  rescue HTTP::Error =&gt; e\n    { error: \"Network error: #{e.message}\" }\n  }\n)\n</code></pre>"},{"location":"api/core/tool/#database-tool","title":"Database Tool","text":"<pre><code>tool = Tool.new(\n  name: \"get_order\",\n  description: \"Get order details\",\n  parameters: {\n    order_id: { type: \"string\", required: true }\n  },\n  handler: -&gt;(order_id:, state:, **_) {\n    user_id = state.data[:user_id]\n    order = Order.find_by(id: order_id, user_id: user_id)\n\n    if order\n      order.as_json(include: [:items, :shipping])\n    else\n      { error: \"Order not found or unauthorized\" }\n    end\n  }\n)\n</code></pre>"},{"location":"api/core/tool/#see-also","title":"See Also","text":"<ul> <li>Using Tools Guide</li> <li>Robot</li> <li>MCP Integration</li> </ul>"},{"location":"api/history/","title":"History","text":"<p>Conversation persistence and thread management.</p>"},{"location":"api/history/#overview","title":"Overview","text":"<p>The history system enables persistent conversations by storing and retrieving conversation threads and results.</p> <pre><code>network = RobotLab.create_network do\n  name \"persistent_chat\"\n\n  history History::Config.new(\n    create_thread: -&gt;(state:, **) { Thread.create(id: SecureRandom.uuid) },\n    get: -&gt;(thread_id:, **) { Thread.find(thread_id).results },\n    append_results: -&gt;(thread_id:, new_results:, **) {\n      Thread.find(thread_id).results.concat(new_results)\n    }\n  )\n\n  add_robot assistant\nend\n</code></pre>"},{"location":"api/history/#components","title":"Components","text":"Component Description Config History configuration ThreadManager Thread lifecycle management ActiveRecordAdapter Rails integration"},{"location":"api/history/#quick-start","title":"Quick Start","text":""},{"location":"api/history/#basic-configuration","title":"Basic Configuration","text":"<pre><code>history = History::Config.new(\n  create_thread: -&gt;(state:, input:, **) {\n    { id: SecureRandom.uuid }\n  },\n  get: -&gt;(thread_id:, **) {\n    STORE[thread_id] || []\n  },\n  append_results: -&gt;(thread_id:, new_results:, **) {\n    STORE[thread_id] ||= []\n    STORE[thread_id].concat(new_results)\n  }\n)\n</code></pre>"},{"location":"api/history/#with-activerecord","title":"With ActiveRecord","text":"<pre><code>history = History::ActiveRecordAdapter.new(\n  thread_model: ConversationThread,\n  result_model: ConversationResult\n).to_config\n</code></pre>"},{"location":"api/history/#callbacks","title":"Callbacks","text":"Callback Purpose <code>create_thread</code> Create new conversation thread <code>get</code> Retrieve existing thread history <code>append_results</code> Add results to thread"},{"location":"api/history/#thread-lifecycle","title":"Thread Lifecycle","text":"<pre><code>sequenceDiagram\n    participant U as User\n    participant N as Network\n    participant H as History\n\n    U-&gt;&gt;N: Run with new message\n    N-&gt;&gt;H: get(thread_id)\n    H--&gt;&gt;N: Previous results\n    N-&gt;&gt;N: Execute robots\n    N-&gt;&gt;H: append_results(new_results)\n    H--&gt;&gt;N: Saved\n    N--&gt;&gt;U: Result with thread_id</code></pre>"},{"location":"api/history/#examples","title":"Examples","text":""},{"location":"api/history/#in-memory-store","title":"In-Memory Store","text":"<pre><code>THREADS = {}\n\nhistory = History::Config.new(\n  create_thread: -&gt;(state:, **) {\n    id = SecureRandom.uuid\n    THREADS[id] = []\n    { id: id }\n  },\n  get: -&gt;(thread_id:, **) {\n    THREADS[thread_id] || []\n  },\n  append_results: -&gt;(thread_id:, new_results:, **) {\n    THREADS[thread_id].concat(new_results)\n  }\n)\n</code></pre>"},{"location":"api/history/#redis-store","title":"Redis Store","text":"<pre><code>history = History::Config.new(\n  create_thread: -&gt;(state:, **) {\n    id = SecureRandom.uuid\n    Redis.current.set(\"thread:#{id}\", [].to_json)\n    { id: id }\n  },\n  get: -&gt;(thread_id:, **) {\n    data = Redis.current.get(\"thread:#{thread_id}\")\n    data ? JSON.parse(data) : []\n  },\n  append_results: -&gt;(thread_id:, new_results:, **) {\n    existing = JSON.parse(Redis.current.get(\"thread:#{thread_id}\") || \"[]\")\n    existing.concat(new_results.map(&amp;:to_h))\n    Redis.current.set(\"thread:#{thread_id}\", existing.to_json)\n  }\n)\n</code></pre>"},{"location":"api/history/#see-also","title":"See Also","text":"<ul> <li>History Guide</li> <li>State</li> </ul>"},{"location":"api/history/active-record-adapter/","title":"ActiveRecordAdapter","text":"<p>Rails ActiveRecord integration for conversation persistence.</p>"},{"location":"api/history/active-record-adapter/#class-robotlabhistoryactiverecordadapter","title":"Class: <code>RobotLab::History::ActiveRecordAdapter</code>","text":"<pre><code>adapter = History::ActiveRecordAdapter.new(\n  thread_model: ConversationThread,\n  result_model: ConversationResult\n)\n\nconfig = adapter.to_config\n</code></pre>"},{"location":"api/history/active-record-adapter/#constructor","title":"Constructor","text":"<pre><code>ActiveRecordAdapter.new(\n  thread_model:,\n  result_model:,\n  thread_factory: nil,\n  result_factory: nil\n)\n</code></pre> <p>Parameters:</p> Name Type Description <code>thread_model</code> <code>Class</code> ActiveRecord model for threads <code>result_model</code> <code>Class</code> ActiveRecord model for results <code>thread_factory</code> <code>Proc</code>, <code>nil</code> Custom thread creation <code>result_factory</code> <code>Proc</code>, <code>nil</code> Custom result creation"},{"location":"api/history/active-record-adapter/#methods","title":"Methods","text":""},{"location":"api/history/active-record-adapter/#to_config","title":"to_config","text":"<pre><code>config = adapter.to_config\n</code></pre> <p>Convert to <code>History::Config</code> for use with networks.</p>"},{"location":"api/history/active-record-adapter/#model-requirements","title":"Model Requirements","text":""},{"location":"api/history/active-record-adapter/#thread-model","title":"Thread Model","text":"<pre><code># db/migrate/xxx_create_conversation_threads.rb\ncreate_table :conversation_threads do |t|\n  t.string :external_id, null: false, index: { unique: true }\n  t.jsonb :metadata, default: {}\n  t.timestamps\nend\n\n# app/models/conversation_thread.rb\nclass ConversationThread &lt; ApplicationRecord\n  has_many :results, class_name: \"ConversationResult\",\n           foreign_key: :thread_id, dependent: :destroy\nend\n</code></pre>"},{"location":"api/history/active-record-adapter/#result-model","title":"Result Model","text":"<pre><code># db/migrate/xxx_create_conversation_results.rb\ncreate_table :conversation_results do |t|\n  t.references :thread, foreign_key: { to_table: :conversation_threads }\n  t.string :robot_name\n  t.jsonb :input, default: {}\n  t.jsonb :output, default: []\n  t.jsonb :tool_calls, default: []\n  t.jsonb :metadata, default: {}\n  t.integer :position\n  t.timestamps\nend\n\n# app/models/conversation_result.rb\nclass ConversationResult &lt; ApplicationRecord\n  belongs_to :thread, class_name: \"ConversationThread\"\n\n  def to_robot_result\n    RobotLab::RobotResult.from_hash(attributes)\n  end\nend\n</code></pre>"},{"location":"api/history/active-record-adapter/#examples","title":"Examples","text":""},{"location":"api/history/active-record-adapter/#basic-setup","title":"Basic Setup","text":"<pre><code>adapter = History::ActiveRecordAdapter.new(\n  thread_model: ConversationThread,\n  result_model: ConversationResult\n)\n\nnetwork = RobotLab.create_network do\n  name \"chat\"\n  history adapter.to_config\n  add_robot assistant\nend\n</code></pre>"},{"location":"api/history/active-record-adapter/#with-custom-factory","title":"With Custom Factory","text":"<pre><code>adapter = History::ActiveRecordAdapter.new(\n  thread_model: ConversationThread,\n  result_model: ConversationResult,\n  thread_factory: -&gt;(state:, input:, **context) {\n    ConversationThread.create!(\n      external_id: SecureRandom.uuid,\n      user_id: context[:user_id],\n      title: input.truncate(100),\n      metadata: { source: context[:source] }\n    )\n  }\n)\n</code></pre>"},{"location":"api/history/active-record-adapter/#with-user-scoping","title":"With User Scoping","text":"<pre><code>class ScopedAdapter\n  def initialize(thread_model:, result_model:)\n    @thread_model = thread_model\n    @result_model = result_model\n  end\n\n  def to_config\n    History::Config.new(\n      create_thread: method(:create_thread),\n      get: method(:get),\n      append_results: method(:append_results)\n    )\n  end\n\n  private\n\n  def create_thread(state:, input:, user_id:, **)\n    @thread_model.create!(\n      external_id: SecureRandom.uuid,\n      user_id: user_id,\n      title: input.truncate(100)\n    )\n  end\n\n  def get(thread_id:, user_id:, **)\n    thread = @thread_model.find_by(external_id: thread_id, user_id: user_id)\n    return [] unless thread\n    thread.results.order(:position).map(&amp;:to_robot_result)\n  end\n\n  def append_results(thread_id:, new_results:, user_id:, **)\n    thread = @thread_model.find_by!(external_id: thread_id, user_id: user_id)\n    position = thread.results.maximum(:position) || 0\n\n    @result_model.transaction do\n      new_results.each_with_index do |result, i|\n        thread.results.create!(\n          robot_name: result.robot_name,\n          input: result.input.to_h,\n          output: result.output.map(&amp;:to_h),\n          tool_calls: result.tool_calls.map(&amp;:to_h),\n          position: position + i + 1\n        )\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"api/history/active-record-adapter/#rails-generator","title":"Rails Generator","text":"<p>Use the Rails generator to create models:</p> <pre><code>rails generate robot_lab:history\n</code></pre> <p>This creates:</p> <ul> <li><code>ConversationThread</code> model</li> <li><code>ConversationResult</code> model</li> <li>Database migrations</li> <li>Initializer configuration</li> </ul>"},{"location":"api/history/active-record-adapter/#see-also","title":"See Also","text":"<ul> <li>History Overview</li> <li>Config</li> <li>Rails Integration Guide</li> </ul>"},{"location":"api/history/config/","title":"History::Config","text":"<p>Configuration for conversation persistence.</p>"},{"location":"api/history/config/#class-robotlabhistoryconfig","title":"Class: <code>RobotLab::History::Config</code>","text":"<pre><code>config = History::Config.new(\n  create_thread: create_proc,\n  get: get_proc,\n  append_results: append_proc\n)\n</code></pre>"},{"location":"api/history/config/#constructor","title":"Constructor","text":"<pre><code>Config.new(\n  create_thread:,\n  get:,\n  append_results:\n)\n</code></pre> <p>Parameters:</p> Name Type Description <code>create_thread</code> <code>Proc</code> Creates a new thread <code>get</code> <code>Proc</code> Retrieves thread history <code>append_results</code> <code>Proc</code> Appends results to thread"},{"location":"api/history/config/#callbacks","title":"Callbacks","text":""},{"location":"api/history/config/#create_thread","title":"create_thread","text":"<p>Called when a new conversation starts without a thread_id.</p> <pre><code>create_thread: -&gt;(state:, input:, **context) {\n  # Create and return thread info\n  { id: SecureRandom.uuid }\n}\n</code></pre> <p>Arguments:</p> Name Type Description <code>state</code> <code>State</code> Current state <code>input</code> <code>String</code> User input <code>**context</code> <code>Hash</code> Additional context <p>Returns: Hash with <code>:id</code> key.</p>"},{"location":"api/history/config/#get","title":"get","text":"<p>Called to retrieve existing conversation history.</p> <pre><code>get: -&gt;(thread_id:, **context) {\n  # Return array of previous results\n  Thread.find(thread_id).results\n}\n</code></pre> <p>Arguments:</p> Name Type Description <code>thread_id</code> <code>String</code> Thread identifier <code>**context</code> <code>Hash</code> Additional context <p>Returns: Array of <code>RobotResult</code> or hashes.</p>"},{"location":"api/history/config/#append_results","title":"append_results","text":"<p>Called after each network run to persist new results.</p> <pre><code>append_results: -&gt;(thread_id:, new_results:, **context) {\n  # Persist the new results\n  thread = Thread.find(thread_id)\n  new_results.each { |r| thread.results.create(r.to_h) }\n}\n</code></pre> <p>Arguments:</p> Name Type Description <code>thread_id</code> <code>String</code> Thread identifier <code>new_results</code> <code>Array&lt;RobotResult&gt;</code> Results to append <code>**context</code> <code>Hash</code> Additional context"},{"location":"api/history/config/#attributes","title":"Attributes","text":""},{"location":"api/history/config/#create_thread_1","title":"create_thread","text":"<pre><code>config.create_thread  # =&gt; Proc\n</code></pre>"},{"location":"api/history/config/#get_1","title":"get","text":"<pre><code>config.get  # =&gt; Proc\n</code></pre>"},{"location":"api/history/config/#append_results_1","title":"append_results","text":"<pre><code>config.append_results  # =&gt; Proc\n</code></pre>"},{"location":"api/history/config/#examples","title":"Examples","text":""},{"location":"api/history/config/#basic-config","title":"Basic Config","text":"<pre><code>STORE = {}\n\nconfig = History::Config.new(\n  create_thread: -&gt;(state:, **) {\n    id = SecureRandom.uuid\n    STORE[id] = { results: [] }\n    { id: id }\n  },\n\n  get: -&gt;(thread_id:, **) {\n    STORE.dig(thread_id, :results) || []\n  },\n\n  append_results: -&gt;(thread_id:, new_results:, **) {\n    STORE[thread_id][:results].concat(new_results.map(&amp;:to_h))\n  }\n)\n</code></pre>"},{"location":"api/history/config/#with-context","title":"With Context","text":"<pre><code>config = History::Config.new(\n  create_thread: -&gt;(state:, user_id:, **) {\n    Thread.create(user_id: user_id, started_at: Time.current)\n  },\n\n  get: -&gt;(thread_id:, user_id:, **) {\n    Thread.where(id: thread_id, user_id: user_id).first&amp;.results || []\n  },\n\n  append_results: -&gt;(thread_id:, new_results:, user_id:, **) {\n    thread = Thread.find_by(id: thread_id, user_id: user_id)\n    return unless thread\n    new_results.each { |r| thread.results.create(r.to_h) }\n  }\n)\n\n# Pass context when running\nnetwork.run(state: state, user_id: current_user.id)\n</code></pre>"},{"location":"api/history/config/#with-validation","title":"With Validation","text":"<pre><code>config = History::Config.new(\n  create_thread: -&gt;(state:, **) {\n    raise \"Invalid state\" unless state.data[:user_id]\n    Thread.create(user_id: state.data[:user_id])\n  },\n\n  get: -&gt;(thread_id:, **) {\n    thread = Thread.find_by(id: thread_id)\n    raise \"Thread not found\" unless thread\n    thread.results\n  },\n\n  append_results: -&gt;(thread_id:, new_results:, **) {\n    thread = Thread.find(thread_id)\n    Thread.transaction do\n      new_results.each { |r| thread.results.create!(r.to_h) }\n    end\n  }\n)\n</code></pre>"},{"location":"api/history/config/#see-also","title":"See Also","text":"<ul> <li>History Overview</li> <li>ThreadManager</li> <li>ActiveRecordAdapter</li> </ul>"},{"location":"api/history/thread-manager/","title":"ThreadManager","text":"<p>Manages conversation thread lifecycle.</p>"},{"location":"api/history/thread-manager/#class-robotlabhistorythreadmanager","title":"Class: <code>RobotLab::History::ThreadManager</code>","text":"<pre><code>manager = History::ThreadManager.new(config: history_config)\n</code></pre>"},{"location":"api/history/thread-manager/#constructor","title":"Constructor","text":"<pre><code>ThreadManager.new(config:)\n</code></pre> <p>Parameters:</p> Name Type Description <code>config</code> <code>Config</code> History configuration"},{"location":"api/history/thread-manager/#methods","title":"Methods","text":""},{"location":"api/history/thread-manager/#create_thread","title":"create_thread","text":"<pre><code>thread_info = manager.create_thread(state: state, input: input, **context)\n</code></pre> <p>Create a new conversation thread.</p> <p>Returns: Hash with <code>:id</code> and optional metadata.</p>"},{"location":"api/history/thread-manager/#get_history","title":"get_history","text":"<pre><code>results = manager.get_history(thread_id: id, **context)\n</code></pre> <p>Retrieve conversation history.</p> <p>Returns: Array of <code>RobotResult</code>.</p>"},{"location":"api/history/thread-manager/#append_results","title":"append_results","text":"<pre><code>manager.append_results(thread_id: id, new_results: results, **context)\n</code></pre> <p>Add results to a thread.</p>"},{"location":"api/history/thread-manager/#ensure_thread","title":"ensure_thread","text":"<pre><code>thread_id = manager.ensure_thread(state: state, input: input, **context)\n</code></pre> <p>Create thread if state doesn't have one, or return existing.</p>"},{"location":"api/history/thread-manager/#load_history","title":"load_history","text":"<pre><code>state = manager.load_history(state: state, **context)\n</code></pre> <p>Load history into state if thread_id exists.</p>"},{"location":"api/history/thread-manager/#examples","title":"Examples","text":""},{"location":"api/history/thread-manager/#basic-usage","title":"Basic Usage","text":"<pre><code>config = History::Config.new(...)\nmanager = History::ThreadManager.new(config: config)\n\n# Start new conversation\nstate = RobotLab.create_state(message: \"Hello\")\nthread_id = manager.ensure_thread(state: state, input: \"Hello\")\nstate.thread_id = thread_id\n\n# Run and save\nresult = network.run(state: state)\nmanager.append_results(thread_id: thread_id, new_results: result.new_results)\n\n# Continue conversation\nstate2 = RobotLab.create_state(message: \"Follow up\")\nstate2.thread_id = thread_id\nstate2 = manager.load_history(state: state2)\n# state2 now has previous results\n</code></pre>"},{"location":"api/history/thread-manager/#in-network","title":"In Network","text":"<pre><code># ThreadManager is used internally by Network\nnetwork = RobotLab.create_network do\n  history config\n  add_robot assistant\nend\n\n# First message - thread created automatically\nresult1 = network.run(state: state1)\nthread_id = result1.state.thread_id\n\n# Continue - history loaded automatically\nstate2 = RobotLab.create_state(\n  message: UserMessage.new(\"Continue\", thread_id: thread_id)\n)\nresult2 = network.run(state: state2)\n</code></pre>"},{"location":"api/history/thread-manager/#custom-thread-data","title":"Custom Thread Data","text":"<pre><code>manager = History::ThreadManager.new(\n  config: History::Config.new(\n    create_thread: -&gt;(state:, input:, metadata:, **) {\n      Thread.create(\n        title: input.truncate(50),\n        metadata: metadata,\n        created_at: Time.current\n      )\n    },\n    get: -&gt;(thread_id:, **) { Thread.find(thread_id).results },\n    append_results: -&gt;(thread_id:, new_results:, **) {\n      Thread.find(thread_id).results.concat(new_results)\n    }\n  )\n)\n\n# Pass metadata when creating thread\nthread = manager.create_thread(\n  state: state,\n  input: \"Help with billing\",\n  metadata: { source: \"web\", priority: \"high\" }\n)\n</code></pre>"},{"location":"api/history/thread-manager/#see-also","title":"See Also","text":"<ul> <li>History Overview</li> <li>Config</li> <li>ActiveRecordAdapter</li> </ul>"},{"location":"api/mcp/","title":"MCP (Model Context Protocol)","text":"<p>Integration with MCP servers for extended tool capabilities.</p>"},{"location":"api/mcp/#overview","title":"Overview","text":"<p>MCP allows robots to connect to external tool servers, extending their capabilities without modifying robot code.</p> <pre><code>robot = RobotLab.build do\n  name \"developer\"\n  template \"You help with coding tasks.\"\n\n  mcp [\n    {\n      name: \"filesystem\",\n      transport: { type: \"stdio\", command: \"npx @modelcontextprotocol/server-filesystem\" }\n    }\n  ]\nend\n</code></pre>"},{"location":"api/mcp/#components","title":"Components","text":"Component Description Client Connects to MCP servers Server Exposes tools via MCP Transports Communication methods"},{"location":"api/mcp/#quick-start","title":"Quick Start","text":""},{"location":"api/mcp/#using-mcp-tools","title":"Using MCP Tools","text":"<pre><code>network = RobotLab.create_network do\n  name \"with_mcp\"\n\n  mcp [\n    { name: \"github\", transport: { type: \"stdio\", command: \"mcp-server-github\" } }\n  ]\n\n  add_robot RobotLab.build {\n    name \"assistant\"\n    template \"You help with GitHub tasks.\"\n    mcp :inherit  # Use network's MCP servers\n  }\nend\n</code></pre>"},{"location":"api/mcp/#creating-an-mcp-server","title":"Creating an MCP Server","text":"<pre><code>server = RobotLab::MCP::Server.new(name: \"my_tools\")\n\nserver.add_tool(\n  name: \"get_user\",\n  description: \"Get user by ID\",\n  parameters: { id: { type: \"string\", required: true } },\n  handler: -&gt;(id:) { User.find(id).to_h }\n)\n\nserver.start(transport: :stdio)\n</code></pre>"},{"location":"api/mcp/#transport-types","title":"Transport Types","text":"Type Use Case <code>stdio</code> Local command execution <code>websocket</code> Real-time bidirectional <code>sse</code> Server-sent events <code>http</code> HTTP request/response"},{"location":"api/mcp/#configuration-levels","title":"Configuration Levels","text":""},{"location":"api/mcp/#network-level","title":"Network Level","text":"<pre><code>network = RobotLab.create_network do\n  mcp [\n    { name: \"server1\", transport: { type: \"stdio\", command: \"...\" } }\n  ]\nend\n</code></pre>"},{"location":"api/mcp/#robot-level","title":"Robot Level","text":"<pre><code>robot = RobotLab.build do\n  mcp :inherit  # Use network's servers\n  # or\n  mcp :none     # No MCP servers\n  # or\n  mcp [...]     # Specific servers\nend\n</code></pre>"},{"location":"api/mcp/#tool-filtering","title":"Tool Filtering","text":"<pre><code>robot = RobotLab.build do\n  mcp :inherit\n  tools %w[read_file write_file]  # Only allow these tools\nend\n</code></pre>"},{"location":"api/mcp/#see-also","title":"See Also","text":"<ul> <li>MCP Integration Guide</li> <li>Tool</li> </ul>"},{"location":"api/mcp/client/","title":"MCP Client","text":"<p>Connects to MCP servers and discovers tools.</p>"},{"location":"api/mcp/client/#class-robotlabmcpclient","title":"Class: <code>RobotLab::MCP::Client</code>","text":"<pre><code>client = RobotLab::MCP::Client.new(\n  name: \"filesystem\",\n  transport: { type: \"stdio\", command: \"mcp-server-filesystem\" }\n)\n\nclient.connect\ntools = client.list_tools\n</code></pre>"},{"location":"api/mcp/client/#constructor","title":"Constructor","text":"<pre><code>Client.new(name:, transport:)\n</code></pre> <p>Parameters:</p> Name Type Description <code>name</code> <code>String</code> Server identifier <code>transport</code> <code>Hash</code> Transport configuration"},{"location":"api/mcp/client/#attributes","title":"Attributes","text":""},{"location":"api/mcp/client/#name","title":"name","text":"<pre><code>client.name  # =&gt; String\n</code></pre> <p>Server identifier.</p>"},{"location":"api/mcp/client/#transport","title":"transport","text":"<pre><code>client.transport  # =&gt; Transport\n</code></pre> <p>The underlying transport connection.</p>"},{"location":"api/mcp/client/#connected","title":"connected?","text":"<pre><code>client.connected?  # =&gt; Boolean\n</code></pre> <p>Whether the client is connected.</p>"},{"location":"api/mcp/client/#methods","title":"Methods","text":""},{"location":"api/mcp/client/#connect","title":"connect","text":"<pre><code>client.connect\n</code></pre> <p>Establish connection to the MCP server.</p>"},{"location":"api/mcp/client/#disconnect","title":"disconnect","text":"<pre><code>client.disconnect\n</code></pre> <p>Close the connection.</p>"},{"location":"api/mcp/client/#list_tools","title":"list_tools","text":"<pre><code>client.list_tools  # =&gt; Array&lt;Tool&gt;\n</code></pre> <p>Discover available tools from the server.</p>"},{"location":"api/mcp/client/#call_tool","title":"call_tool","text":"<pre><code>result = client.call_tool(name, params)\n</code></pre> <p>Execute a tool on the server.</p> <p>Parameters:</p> Name Type Description <code>name</code> <code>String</code> Tool name <code>params</code> <code>Hash</code> Tool parameters"},{"location":"api/mcp/client/#list_resources","title":"list_resources","text":"<pre><code>client.list_resources  # =&gt; Array&lt;Resource&gt;\n</code></pre> <p>List available resources (if supported).</p>"},{"location":"api/mcp/client/#read_resource","title":"read_resource","text":"<pre><code>client.read_resource(uri)  # =&gt; Resource\n</code></pre> <p>Read a resource by URI.</p>"},{"location":"api/mcp/client/#transport-configuration","title":"Transport Configuration","text":""},{"location":"api/mcp/client/#stdio","title":"Stdio","text":"<pre><code>client = Client.new(\n  name: \"local\",\n  transport: {\n    type: \"stdio\",\n    command: \"npx\",\n    args: [\"@modelcontextprotocol/server-filesystem\", \"/path\"]\n  }\n)\n</code></pre>"},{"location":"api/mcp/client/#websocket","title":"WebSocket","text":"<pre><code>client = Client.new(\n  name: \"remote\",\n  transport: {\n    type: \"websocket\",\n    url: \"wss://mcp.example.com/ws\"\n  }\n)\n</code></pre>"},{"location":"api/mcp/client/#sse","title":"SSE","text":"<pre><code>client = Client.new(\n  name: \"streaming\",\n  transport: {\n    type: \"sse\",\n    url: \"https://mcp.example.com/sse\"\n  }\n)\n</code></pre>"},{"location":"api/mcp/client/#http","title":"HTTP","text":"<pre><code>client = Client.new(\n  name: \"http\",\n  transport: {\n    type: \"http\",\n    url: \"https://mcp.example.com/mcp\"\n  }\n)\n</code></pre>"},{"location":"api/mcp/client/#examples","title":"Examples","text":""},{"location":"api/mcp/client/#basic-usage","title":"Basic Usage","text":"<pre><code>client = Client.new(\n  name: \"github\",\n  transport: { type: \"stdio\", command: \"mcp-server-github\" }\n)\n\nclient.connect\n\n# List available tools\ntools = client.list_tools\ntools.each { |t| puts \"#{t.name}: #{t.description}\" }\n\n# Call a tool\nresult = client.call_tool(\"search_repositories\", { query: \"ruby mcp\" })\nputs result\n\nclient.disconnect\n</code></pre>"},{"location":"api/mcp/client/#in-robot","title":"In Robot","text":"<pre><code>robot = RobotLab.build do\n  name \"assistant\"\n\n  mcp [\n    { name: \"fs\", transport: { type: \"stdio\", command: \"mcp-fs\" } }\n  ]\nend\n\n# MCP tools are automatically available\nrobot.tools.each { |t| puts t.name }\n</code></pre>"},{"location":"api/mcp/client/#error-handling","title":"Error Handling","text":"<pre><code>begin\n  client.connect\n  result = client.call_tool(\"unknown_tool\", {})\nrescue RobotLab::MCP::ConnectionError =&gt; e\n  puts \"Failed to connect: #{e.message}\"\nrescue RobotLab::MCP::ToolError =&gt; e\n  puts \"Tool error: #{e.message}\"\nensure\n  client.disconnect\nend\n</code></pre>"},{"location":"api/mcp/client/#see-also","title":"See Also","text":"<ul> <li>MCP Overview</li> <li>Transports</li> <li>MCP Server</li> </ul>"},{"location":"api/mcp/server/","title":"MCP Server","text":"<p>Expose tools via Model Context Protocol.</p>"},{"location":"api/mcp/server/#class-robotlabmcpserver","title":"Class: <code>RobotLab::MCP::Server</code>","text":"<pre><code>server = RobotLab::MCP::Server.new(name: \"my_tools\")\n\nserver.add_tool(\n  name: \"get_time\",\n  description: \"Get current time\",\n  handler: -&gt;(**_) { Time.now.iso8601 }\n)\n\nserver.start(transport: :stdio)\n</code></pre>"},{"location":"api/mcp/server/#constructor","title":"Constructor","text":"<pre><code>Server.new(name:, version: \"1.0.0\")\n</code></pre> <p>Parameters:</p> Name Type Description <code>name</code> <code>String</code> Server name <code>version</code> <code>String</code> Server version"},{"location":"api/mcp/server/#attributes","title":"Attributes","text":""},{"location":"api/mcp/server/#name","title":"name","text":"<pre><code>server.name  # =&gt; String\n</code></pre> <p>Server identifier.</p>"},{"location":"api/mcp/server/#version","title":"version","text":"<pre><code>server.version  # =&gt; String\n</code></pre> <p>Server version.</p>"},{"location":"api/mcp/server/#tools","title":"tools","text":"<pre><code>server.tools  # =&gt; Array&lt;Tool&gt;\n</code></pre> <p>Registered tools.</p>"},{"location":"api/mcp/server/#methods","title":"Methods","text":""},{"location":"api/mcp/server/#add_tool","title":"add_tool","text":"<pre><code>server.add_tool(\n  name:,\n  description:,\n  parameters: {},\n  handler:\n)\n</code></pre> <p>Register a tool with the server.</p> <p>Parameters:</p> Name Type Description <code>name</code> <code>String</code> Tool name <code>description</code> <code>String</code> Tool description <code>parameters</code> <code>Hash</code> Parameter schema <code>handler</code> <code>Proc</code> Execution function"},{"location":"api/mcp/server/#remove_tool","title":"remove_tool","text":"<pre><code>server.remove_tool(name)\n</code></pre> <p>Unregister a tool.</p>"},{"location":"api/mcp/server/#start","title":"start","text":"<pre><code>server.start(transport: :stdio, **options)\n</code></pre> <p>Start the server.</p> <p>Transport Options:</p> Transport Options <code>:stdio</code> None <code>:websocket</code> <code>port:</code>, <code>host:</code> <code>:sse</code> <code>port:</code>, <code>host:</code>, <code>path:</code> <code>:http</code> <code>port:</code>, <code>host:</code>, <code>path:</code>"},{"location":"api/mcp/server/#stop","title":"stop","text":"<pre><code>server.stop\n</code></pre> <p>Stop the server.</p>"},{"location":"api/mcp/server/#examples","title":"Examples","text":""},{"location":"api/mcp/server/#basic-server","title":"Basic Server","text":"<pre><code>server = RobotLab::MCP::Server.new(name: \"utilities\")\n\nserver.add_tool(\n  name: \"echo\",\n  description: \"Echo back the input\",\n  parameters: {\n    message: { type: \"string\", required: true }\n  },\n  handler: -&gt;(message:) { message }\n)\n\nserver.start(transport: :stdio)\n</code></pre>"},{"location":"api/mcp/server/#database-tools-server","title":"Database Tools Server","text":"<pre><code>server = RobotLab::MCP::Server.new(name: \"database\")\n\nserver.add_tool(\n  name: \"query_users\",\n  description: \"Query users by criteria\",\n  parameters: {\n    status: { type: \"string\", enum: [\"active\", \"inactive\"] },\n    limit: { type: \"integer\", default: 10 }\n  },\n  handler: -&gt;(status: nil, limit: 10) {\n    scope = User.all\n    scope = scope.where(status: status) if status\n    scope.limit(limit).map(&amp;:to_h)\n  }\n)\n\nserver.add_tool(\n  name: \"get_user\",\n  description: \"Get user by ID\",\n  parameters: {\n    id: { type: \"string\", required: true }\n  },\n  handler: -&gt;(id:) {\n    user = User.find_by(id: id)\n    user ? user.to_h : { error: \"Not found\" }\n  }\n)\n\nserver.start(transport: :websocket, port: 8080)\n</code></pre>"},{"location":"api/mcp/server/#from-robot-tools","title":"From Robot Tools","text":"<pre><code># Convert existing robot tools to MCP server\nrobot = RobotLab.build do\n  name \"assistant\"\n\n  tool :calculate do\n    description \"Perform calculation\"\n    parameter :expression, type: :string, required: true\n    handler { |expression:, **_| eval(expression) }\n  end\nend\n\nserver = RobotLab::MCP::Server.from_robot(robot)\nserver.start(transport: :stdio)\n</code></pre>"},{"location":"api/mcp/server/#http-server","title":"HTTP Server","text":"<pre><code>server = RobotLab::MCP::Server.new(name: \"api_tools\")\n\nserver.add_tool(\n  name: \"fetch_data\",\n  description: \"Fetch data from API\",\n  parameters: {\n    endpoint: { type: \"string\", required: true }\n  },\n  handler: -&gt;(endpoint:) {\n    response = HTTP.get(\"https://api.example.com/#{endpoint}\")\n    JSON.parse(response.body)\n  }\n)\n\nserver.start(transport: :http, port: 3001, path: \"/mcp\")\n</code></pre>"},{"location":"api/mcp/server/#with-resources","title":"With Resources","text":"<pre><code>server = RobotLab::MCP::Server.new(name: \"files\")\n\nserver.add_resource(\n  uri: \"file://config\",\n  name: \"Configuration\",\n  description: \"Application configuration\",\n  handler: -&gt; { File.read(\"config.yml\") }\n)\n\nserver.start(transport: :stdio)\n</code></pre>"},{"location":"api/mcp/server/#see-also","title":"See Also","text":"<ul> <li>MCP Overview</li> <li>MCP Client</li> <li>Transports</li> </ul>"},{"location":"api/mcp/transports/","title":"MCP Transports","text":"<p>Communication methods for MCP connections.</p>"},{"location":"api/mcp/transports/#overview","title":"Overview","text":"<p>Transports handle the low-level communication between MCP clients and servers. RobotLab supports multiple transport types for different deployment scenarios.</p>"},{"location":"api/mcp/transports/#transport-types","title":"Transport Types","text":""},{"location":"api/mcp/transports/#stdio","title":"Stdio","text":"<p>Standard input/output for local process communication.</p> <pre><code>{\n  type: \"stdio\",\n  command: \"npx\",\n  args: [\"@modelcontextprotocol/server-filesystem\", \"/path\"],\n  env: { \"DEBUG\" =&gt; \"true\" }\n}\n</code></pre> <p>Options:</p> Option Type Description <code>command</code> <code>String</code> Executable command <code>args</code> <code>Array</code> Command arguments <code>env</code> <code>Hash</code> Environment variables <code>cwd</code> <code>String</code> Working directory <p>Use Cases:</p> <ul> <li>Local development</li> <li>CLI tools</li> <li>Subprocess servers</li> </ul>"},{"location":"api/mcp/transports/#websocket","title":"WebSocket","text":"<p>Bidirectional real-time communication.</p> <pre><code>{\n  type: \"websocket\",\n  url: \"wss://mcp.example.com/ws\",\n  headers: { \"Authorization\" =&gt; \"Bearer token\" }\n}\n</code></pre> <p>Options:</p> Option Type Description <code>url</code> <code>String</code> WebSocket endpoint <code>headers</code> <code>Hash</code> HTTP headers <code>ping_interval</code> <code>Integer</code> Keep-alive interval (seconds) <p>Use Cases:</p> <ul> <li>Remote servers</li> <li>Real-time applications</li> <li>Long-running connections</li> </ul>"},{"location":"api/mcp/transports/#sse-server-sent-events","title":"SSE (Server-Sent Events)","text":"<p>Unidirectional server-to-client streaming.</p> <pre><code>{\n  type: \"sse\",\n  url: \"https://mcp.example.com/sse\",\n  headers: { \"Authorization\" =&gt; \"Bearer token\" }\n}\n</code></pre> <p>Options:</p> Option Type Description <code>url</code> <code>String</code> SSE endpoint <code>headers</code> <code>Hash</code> HTTP headers <code>post_url</code> <code>String</code> Endpoint for client messages <p>Use Cases:</p> <ul> <li>Firewall-friendly connections</li> <li>Browser-based clients</li> <li>Streaming responses</li> </ul>"},{"location":"api/mcp/transports/#http","title":"HTTP","text":"<p>Request/response communication.</p> <pre><code>{\n  type: \"http\",\n  url: \"https://mcp.example.com/mcp\",\n  headers: { \"Authorization\" =&gt; \"Bearer token\" },\n  timeout: 30\n}\n</code></pre> <p>Options:</p> Option Type Description <code>url</code> <code>String</code> HTTP endpoint <code>headers</code> <code>Hash</code> HTTP headers <code>timeout</code> <code>Integer</code> Request timeout (seconds) <code>retry</code> <code>Integer</code> Retry attempts <p>Use Cases:</p> <ul> <li>Simple integrations</li> <li>Stateless operations</li> <li>Load-balanced servers</li> </ul>"},{"location":"api/mcp/transports/#examples","title":"Examples","text":""},{"location":"api/mcp/transports/#local-server-with-stdio","title":"Local Server with Stdio","text":"<pre><code>network = RobotLab.create_network do\n  mcp [\n    {\n      name: \"filesystem\",\n      transport: {\n        type: \"stdio\",\n        command: \"npx\",\n        args: [\"@modelcontextprotocol/server-filesystem\", \"/home/user/docs\"]\n      }\n    }\n  ]\nend\n</code></pre>"},{"location":"api/mcp/transports/#remote-server-with-websocket","title":"Remote Server with WebSocket","text":"<pre><code>network = RobotLab.create_network do\n  mcp [\n    {\n      name: \"remote_tools\",\n      transport: {\n        type: \"websocket\",\n        url: \"wss://tools.example.com/mcp\",\n        headers: {\n          \"Authorization\" =&gt; \"Bearer #{ENV['MCP_TOKEN']}\"\n        }\n      }\n    }\n  ]\nend\n</code></pre>"},{"location":"api/mcp/transports/#multiple-transports","title":"Multiple Transports","text":"<pre><code>network = RobotLab.create_network do\n  mcp [\n    # Local filesystem\n    {\n      name: \"fs\",\n      transport: { type: \"stdio\", command: \"mcp-fs\" }\n    },\n    # Remote API\n    {\n      name: \"api\",\n      transport: {\n        type: \"http\",\n        url: \"https://api.example.com/mcp\"\n      }\n    },\n    # Real-time service\n    {\n      name: \"realtime\",\n      transport: {\n        type: \"websocket\",\n        url: \"wss://realtime.example.com/mcp\"\n      }\n    }\n  ]\nend\n</code></pre>"},{"location":"api/mcp/transports/#custom-transport","title":"Custom Transport","text":"<pre><code>class CustomTransport\n  def initialize(options)\n    @options = options\n  end\n\n  def connect\n    # Establish connection\n  end\n\n  def disconnect\n    # Close connection\n  end\n\n  def send(message)\n    # Send message to server\n  end\n\n  def receive\n    # Receive message from server\n  end\nend\n\nRobotLab::MCP.register_transport(:custom, CustomTransport)\n\n# Use custom transport\n{\n  type: \"custom\",\n  option1: \"value1\"\n}\n</code></pre>"},{"location":"api/mcp/transports/#connection-lifecycle","title":"Connection Lifecycle","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant T as Transport\n    participant S as Server\n\n    C-&gt;&gt;T: connect()\n    T-&gt;&gt;S: Establish connection\n    S--&gt;&gt;T: Connection established\n    T--&gt;&gt;C: Connected\n\n    C-&gt;&gt;T: send(request)\n    T-&gt;&gt;S: Forward request\n    S--&gt;&gt;T: Response\n    T--&gt;&gt;C: receive() \u2192 response\n\n    C-&gt;&gt;T: disconnect()\n    T-&gt;&gt;S: Close connection</code></pre>"},{"location":"api/mcp/transports/#error-handling","title":"Error Handling","text":"<pre><code>begin\n  client.connect\nrescue RobotLab::MCP::ConnectionError =&gt; e\n  case e.transport\n  when \"stdio\"\n    puts \"Command failed: #{e.message}\"\n  when \"websocket\"\n    puts \"WebSocket error: #{e.message}\"\n  when \"http\"\n    puts \"HTTP error: #{e.status} - #{e.message}\"\n  end\nend\n</code></pre>"},{"location":"api/mcp/transports/#see-also","title":"See Also","text":"<ul> <li>MCP Overview</li> <li>MCP Client</li> <li>MCP Server</li> </ul>"},{"location":"api/messages/","title":"Messages","text":"<p>Message types for LLM conversation representation.</p>"},{"location":"api/messages/#overview","title":"Overview","text":"<p>RobotLab uses a structured message system to represent conversations between users, assistants, and tools.</p> <pre><code># User input\nuser_msg = UserMessage.new(\"Hello\", thread_id: \"123\")\n\n# Assistant response\ntext_msg = TextMessage.new(\"Hi there!\")\n\n# Tool interaction\ntool_call = ToolCallMessage.new(id: \"call_1\", name: \"get_weather\", input: { city: \"NYC\" })\ntool_result = ToolResultMessage.new(id: \"call_1\", result: { temp: 72 })\n</code></pre>"},{"location":"api/messages/#message-hierarchy","title":"Message Hierarchy","text":"<pre><code>Message (base)\n\u251c\u2500\u2500 UserMessage      - User input with metadata\n\u251c\u2500\u2500 TextMessage      - Assistant text response\n\u251c\u2500\u2500 ToolMessage      - Tool-related messages\n\u2502   \u251c\u2500\u2500 ToolCallMessage   - Tool invocation\n\u2502   \u2514\u2500\u2500 ToolResultMessage - Tool result\n\u2514\u2500\u2500 SystemMessage    - System prompts\n</code></pre>"},{"location":"api/messages/#common-interface","title":"Common Interface","text":"<p>All messages implement:</p> <pre><code>message.role       # =&gt; Symbol (:user, :assistant, :tool)\nmessage.content    # =&gt; String or structured data\nmessage.to_h       # =&gt; Hash representation\nmessage.to_json    # =&gt; JSON string\n</code></pre>"},{"location":"api/messages/#classes","title":"Classes","text":"Class Description UserMessage User input with thread and metadata TextMessage Assistant text response ToolCallMessage Tool invocation request ToolResultMessage Tool execution result"},{"location":"api/messages/#usage-in-state","title":"Usage in State","text":"<p>Messages are typically accessed through state:</p> <pre><code>state.messages  # =&gt; Array&lt;Message&gt;\n\n# Format for LLM\nstate.format_history  # =&gt; Array&lt;Hash&gt;\n</code></pre>"},{"location":"api/messages/#see-also","title":"See Also","text":"<ul> <li>State</li> <li>Message Flow Architecture</li> </ul>"},{"location":"api/messages/text-message/","title":"TextMessage","text":"<p>Assistant text response.</p>"},{"location":"api/messages/text-message/#class-robotlabtextmessage","title":"Class: <code>RobotLab::TextMessage</code>","text":"<pre><code>message = TextMessage.new(\"Hello! How can I help you today?\")\n</code></pre>"},{"location":"api/messages/text-message/#constructor","title":"Constructor","text":"<pre><code>TextMessage.new(content)\n</code></pre> <p>Parameters:</p> Name Type Description <code>content</code> <code>String</code> Response text"},{"location":"api/messages/text-message/#attributes","title":"Attributes","text":""},{"location":"api/messages/text-message/#content","title":"content","text":"<pre><code>message.content  # =&gt; String\n</code></pre> <p>The response text.</p>"},{"location":"api/messages/text-message/#role","title":"role","text":"<pre><code>message.role  # =&gt; :assistant\n</code></pre> <p>Always returns <code>:assistant</code>.</p>"},{"location":"api/messages/text-message/#methods","title":"Methods","text":""},{"location":"api/messages/text-message/#to_h","title":"to_h","text":"<pre><code>message.to_h  # =&gt; Hash\n</code></pre> <p>Hash representation.</p> <p>Returns:</p> <pre><code>{\n  role: :assistant,\n  content: \"Hello! How can I help you today?\"\n}\n</code></pre>"},{"location":"api/messages/text-message/#to_json","title":"to_json","text":"<pre><code>message.to_json  # =&gt; String\n</code></pre> <p>JSON representation.</p>"},{"location":"api/messages/text-message/#examples","title":"Examples","text":""},{"location":"api/messages/text-message/#basic-response","title":"Basic Response","text":"<pre><code>message = TextMessage.new(\"Your order has shipped!\")\n</code></pre>"},{"location":"api/messages/text-message/#in-robot-results","title":"In Robot Results","text":"<pre><code>result = robot.run(state: state)\n\n# Extract text messages\nresult.output.each do |msg|\n  if msg.is_a?(TextMessage)\n    puts msg.content\n  end\nend\n</code></pre>"},{"location":"api/messages/text-message/#filtering-text-content","title":"Filtering Text Content","text":"<pre><code># Get only text responses from results\ntext_responses = state.results.flat_map(&amp;:output).select do |msg|\n  msg.is_a?(TextMessage)\nend.map(&amp;:content)\n</code></pre>"},{"location":"api/messages/text-message/#see-also","title":"See Also","text":"<ul> <li>UserMessage</li> <li>ToolCallMessage</li> <li>Robot</li> </ul>"},{"location":"api/messages/tool-call-message/","title":"ToolCallMessage","text":"<p>Tool invocation request from the LLM.</p>"},{"location":"api/messages/tool-call-message/#class-robotlabtoolcallmessage","title":"Class: <code>RobotLab::ToolCallMessage</code>","text":"<pre><code>message = ToolCallMessage.new(\n  id: \"call_abc123\",\n  name: \"get_weather\",\n  input: { city: \"New York\", units: \"fahrenheit\" }\n)\n</code></pre>"},{"location":"api/messages/tool-call-message/#constructor","title":"Constructor","text":"<pre><code>ToolCallMessage.new(id:, name:, input:)\n</code></pre> <p>Parameters:</p> Name Type Description <code>id</code> <code>String</code> Unique call identifier <code>name</code> <code>String</code> Tool name <code>input</code> <code>Hash</code> Tool parameters"},{"location":"api/messages/tool-call-message/#attributes","title":"Attributes","text":""},{"location":"api/messages/tool-call-message/#id","title":"id","text":"<pre><code>message.id  # =&gt; String\n</code></pre> <p>Unique identifier for this tool call. Used to match with <code>ToolResultMessage</code>.</p>"},{"location":"api/messages/tool-call-message/#name","title":"name","text":"<pre><code>message.name  # =&gt; String\n</code></pre> <p>Name of the tool being invoked.</p>"},{"location":"api/messages/tool-call-message/#input","title":"input","text":"<pre><code>message.input  # =&gt; Hash\n</code></pre> <p>Parameters passed to the tool.</p>"},{"location":"api/messages/tool-call-message/#role","title":"role","text":"<pre><code>message.role  # =&gt; :assistant\n</code></pre> <p>Always returns <code>:assistant</code> (the LLM initiates tool calls).</p>"},{"location":"api/messages/tool-call-message/#methods","title":"Methods","text":""},{"location":"api/messages/tool-call-message/#to_h","title":"to_h","text":"<pre><code>message.to_h  # =&gt; Hash\n</code></pre> <p>Hash representation.</p> <p>Returns:</p> <pre><code>{\n  role: :assistant,\n  tool_call: {\n    id: \"call_abc123\",\n    name: \"get_weather\",\n    input: { city: \"New York\", units: \"fahrenheit\" }\n  }\n}\n</code></pre>"},{"location":"api/messages/tool-call-message/#to_json","title":"to_json","text":"<pre><code>message.to_json  # =&gt; String\n</code></pre> <p>JSON representation.</p>"},{"location":"api/messages/tool-call-message/#examples","title":"Examples","text":""},{"location":"api/messages/tool-call-message/#basic-tool-call","title":"Basic Tool Call","text":"<pre><code>call = ToolCallMessage.new(\n  id: \"call_1\",\n  name: \"search_orders\",\n  input: { user_id: \"123\", status: \"pending\" }\n)\n</code></pre>"},{"location":"api/messages/tool-call-message/#processing-tool-calls","title":"Processing Tool Calls","text":"<pre><code>result.output.each do |msg|\n  case msg\n  when ToolCallMessage\n    puts \"Tool called: #{msg.name}\"\n    puts \"Parameters: #{msg.input.inspect}\"\n  when ToolResultMessage\n    puts \"Result for #{msg.id}: #{msg.result}\"\n  end\nend\n</code></pre>"},{"location":"api/messages/tool-call-message/#in-tool-execution-flow","title":"In Tool Execution Flow","text":"<pre><code># LLM returns a tool call\ntool_call = ToolCallMessage.new(\n  id: \"call_weather_1\",\n  name: \"get_weather\",\n  input: { city: \"Seattle\" }\n)\n\n# Tool is executed\nresult = tool.call(tool_call.input, state: state)\n\n# Result is recorded\ntool_result = ToolResultMessage.new(\n  id: tool_call.id,\n  result: result\n)\n</code></pre>"},{"location":"api/messages/tool-call-message/#see-also","title":"See Also","text":"<ul> <li>ToolResultMessage</li> <li>Tool</li> <li>Using Tools Guide</li> </ul>"},{"location":"api/messages/tool-result-message/","title":"ToolResultMessage","text":"<p>Result from tool execution.</p>"},{"location":"api/messages/tool-result-message/#class-robotlabtoolresultmessage","title":"Class: <code>RobotLab::ToolResultMessage</code>","text":"<pre><code>message = ToolResultMessage.new(\n  id: \"call_abc123\",\n  result: { temperature: 72, conditions: \"sunny\" }\n)\n</code></pre>"},{"location":"api/messages/tool-result-message/#constructor","title":"Constructor","text":"<pre><code>ToolResultMessage.new(id:, result:)\n</code></pre> <p>Parameters:</p> Name Type Description <code>id</code> <code>String</code> Matching tool call ID <code>result</code> <code>Object</code> Tool execution result"},{"location":"api/messages/tool-result-message/#attributes","title":"Attributes","text":""},{"location":"api/messages/tool-result-message/#id","title":"id","text":"<pre><code>message.id  # =&gt; String\n</code></pre> <p>Identifier matching the corresponding <code>ToolCallMessage</code>.</p>"},{"location":"api/messages/tool-result-message/#result","title":"result","text":"<pre><code>message.result  # =&gt; Object\n</code></pre> <p>The result returned by the tool. Can be any serializable object.</p>"},{"location":"api/messages/tool-result-message/#role","title":"role","text":"<pre><code>message.role  # =&gt; :tool\n</code></pre> <p>Always returns <code>:tool</code>.</p>"},{"location":"api/messages/tool-result-message/#methods","title":"Methods","text":""},{"location":"api/messages/tool-result-message/#to_h","title":"to_h","text":"<pre><code>message.to_h  # =&gt; Hash\n</code></pre> <p>Hash representation.</p> <p>Returns:</p> <pre><code>{\n  role: :tool,\n  tool_result: {\n    id: \"call_abc123\",\n    result: { temperature: 72, conditions: \"sunny\" }\n  }\n}\n</code></pre>"},{"location":"api/messages/tool-result-message/#to_json","title":"to_json","text":"<pre><code>message.to_json  # =&gt; String\n</code></pre> <p>JSON representation.</p>"},{"location":"api/messages/tool-result-message/#examples","title":"Examples","text":""},{"location":"api/messages/tool-result-message/#basic-result","title":"Basic Result","text":"<pre><code>result = ToolResultMessage.new(\n  id: \"call_1\",\n  result: { success: true, order_id: \"ord_123\" }\n)\n</code></pre>"},{"location":"api/messages/tool-result-message/#string-result","title":"String Result","text":"<pre><code>result = ToolResultMessage.new(\n  id: \"call_time\",\n  result: \"2024-01-15T10:30:00Z\"\n)\n</code></pre>"},{"location":"api/messages/tool-result-message/#array-result","title":"Array Result","text":"<pre><code>result = ToolResultMessage.new(\n  id: \"call_search\",\n  result: [\n    { id: 1, name: \"Product A\" },\n    { id: 2, name: \"Product B\" }\n  ]\n)\n</code></pre>"},{"location":"api/messages/tool-result-message/#error-result","title":"Error Result","text":"<pre><code>result = ToolResultMessage.new(\n  id: \"call_order\",\n  result: { success: false, error: \"Order not found\" }\n)\n</code></pre>"},{"location":"api/messages/tool-result-message/#matching-with-tool-calls","title":"Matching with Tool Calls","text":"<pre><code># Process all tool interactions\nresult.output.each_cons(2) do |a, b|\n  if a.is_a?(ToolCallMessage) &amp;&amp; b.is_a?(ToolResultMessage)\n    if a.id == b.id\n      puts \"#{a.name}(#{a.input}) =&gt; #{b.result}\"\n    end\n  end\nend\n</code></pre>"},{"location":"api/messages/tool-result-message/#in-result-history","title":"In Result History","text":"<pre><code># Find all tool results from execution\ntool_results = state.results\n  .flat_map(&amp;:output)\n  .select { |m| m.is_a?(ToolResultMessage) }\n\ntool_results.each do |tr|\n  puts \"Tool result: #{tr.result}\"\nend\n</code></pre>"},{"location":"api/messages/tool-result-message/#see-also","title":"See Also","text":"<ul> <li>ToolCallMessage</li> <li>Tool</li> <li>Using Tools Guide</li> </ul>"},{"location":"api/messages/user-message/","title":"UserMessage","text":"<p>User input with conversation metadata.</p>"},{"location":"api/messages/user-message/#class-robotlabusermessage","title":"Class: <code>RobotLab::UserMessage</code>","text":"<pre><code>message = UserMessage.new(\n  \"What's my order status?\",\n  thread_id: \"thread_123\",\n  system_prompt: \"Be concise\",\n  metadata: { source: \"web\" }\n)\n</code></pre>"},{"location":"api/messages/user-message/#constructor","title":"Constructor","text":"<pre><code>UserMessage.new(content, thread_id: nil, system_prompt: nil, metadata: {})\n</code></pre> <p>Parameters:</p> Name Type Description <code>content</code> <code>String</code> Message text <code>thread_id</code> <code>String</code>, <code>nil</code> Conversation thread ID <code>system_prompt</code> <code>String</code>, <code>nil</code> Override system prompt <code>metadata</code> <code>Hash</code> Additional metadata"},{"location":"api/messages/user-message/#attributes","title":"Attributes","text":""},{"location":"api/messages/user-message/#content","title":"content","text":"<pre><code>message.content  # =&gt; String\n</code></pre> <p>The message text.</p>"},{"location":"api/messages/user-message/#thread_id","title":"thread_id","text":"<pre><code>message.thread_id  # =&gt; String | nil\n</code></pre> <p>Conversation thread identifier for history persistence.</p>"},{"location":"api/messages/user-message/#system_prompt","title":"system_prompt","text":"<pre><code>message.system_prompt  # =&gt; String | nil\n</code></pre> <p>Optional system prompt override for this message.</p>"},{"location":"api/messages/user-message/#metadata","title":"metadata","text":"<pre><code>message.metadata  # =&gt; Hash\n</code></pre> <p>Arbitrary metadata (source, timestamp, user info, etc.).</p>"},{"location":"api/messages/user-message/#id","title":"id","text":"<pre><code>message.id  # =&gt; String (UUID)\n</code></pre> <p>Unique message identifier.</p>"},{"location":"api/messages/user-message/#created_at","title":"created_at","text":"<pre><code>message.created_at  # =&gt; Time\n</code></pre> <p>Message creation timestamp.</p>"},{"location":"api/messages/user-message/#role","title":"role","text":"<pre><code>message.role  # =&gt; :user\n</code></pre> <p>Always returns <code>:user</code>.</p>"},{"location":"api/messages/user-message/#methods","title":"Methods","text":""},{"location":"api/messages/user-message/#to_h","title":"to_h","text":"<pre><code>message.to_h  # =&gt; Hash\n</code></pre> <p>Hash representation.</p> <p>Returns:</p> <pre><code>{\n  role: :user,\n  content: \"What's my order status?\",\n  id: \"uuid-here\",\n  thread_id: \"thread_123\",\n  created_at: \"2024-01-15T10:30:00Z\"\n}\n</code></pre>"},{"location":"api/messages/user-message/#to_json","title":"to_json","text":"<pre><code>message.to_json  # =&gt; String\n</code></pre> <p>JSON representation.</p>"},{"location":"api/messages/user-message/#examples","title":"Examples","text":""},{"location":"api/messages/user-message/#basic-message","title":"Basic Message","text":"<pre><code>message = UserMessage.new(\"Hello!\")\n</code></pre>"},{"location":"api/messages/user-message/#with-thread-id","title":"With Thread ID","text":"<pre><code>message = UserMessage.new(\n  \"Continue our conversation\",\n  thread_id: \"thread_abc123\"\n)\n</code></pre>"},{"location":"api/messages/user-message/#with-system-prompt-override","title":"With System Prompt Override","text":"<pre><code>message = UserMessage.new(\n  \"Translate this\",\n  system_prompt: \"You are a translator. Respond in Spanish.\"\n)\n</code></pre>"},{"location":"api/messages/user-message/#with-metadata","title":"With Metadata","text":"<pre><code>message = UserMessage.new(\n  \"Help with my account\",\n  metadata: {\n    source: \"mobile_app\",\n    user_id: \"user_123\",\n    session_id: \"sess_456\",\n    locale: \"en-US\"\n  }\n)\n</code></pre>"},{"location":"api/messages/user-message/#creating-state","title":"Creating State","text":"<pre><code>message = UserMessage.new(\"Help\", thread_id: \"thread_123\")\nstate = RobotLab.create_state(message: message)\n\nstate.thread_id  # =&gt; \"thread_123\"\n</code></pre>"},{"location":"api/messages/user-message/#see-also","title":"See Also","text":"<ul> <li>State</li> <li>TextMessage</li> </ul>"},{"location":"api/streaming/","title":"Streaming","text":"<p>Real-time response streaming from LLM providers.</p>"},{"location":"api/streaming/#overview","title":"Overview","text":"<p>Streaming allows you to receive LLM responses in real-time, token by token, enabling responsive user interfaces and progressive content display.</p> <pre><code>result = robot.run(state: state) do |event|\n  case event.type\n  when :text_delta\n    print event.text\n  when :tool_call\n    puts \"\\nCalling tool: #{event.name}\"\n  when :complete\n    puts \"\\nDone!\"\n  end\nend\n</code></pre>"},{"location":"api/streaming/#components","title":"Components","text":"Component Description Context Streaming context and state Events Event types and handling"},{"location":"api/streaming/#quick-start","title":"Quick Start","text":""},{"location":"api/streaming/#basic-streaming","title":"Basic Streaming","text":"<pre><code>robot.run(state: state) do |event|\n  print event.text if event.type == :text_delta\nend\n</code></pre>"},{"location":"api/streaming/#with-network","title":"With Network","text":"<pre><code>network.run(state: state) do |event|\n  case event.type\n  when :robot_start\n    puts \"Robot #{event.robot_name} starting...\"\n  when :text_delta\n    print event.text\n  when :robot_complete\n    puts \"\\nRobot #{event.robot_name} complete\"\n  end\nend\n</code></pre>"},{"location":"api/streaming/#event-types","title":"Event Types","text":"Event Description <code>:start</code> Streaming started <code>:text_delta</code> Text chunk received <code>:tool_call</code> Tool being called <code>:tool_result</code> Tool result received <code>:robot_start</code> Robot execution started <code>:robot_complete</code> Robot execution finished <code>:complete</code> All streaming finished <code>:error</code> Error occurred"},{"location":"api/streaming/#callback-patterns","title":"Callback Patterns","text":""},{"location":"api/streaming/#proclambda","title":"Proc/Lambda","text":"<pre><code>callback = -&gt;(event) {\n  print event.text if event.type == :text_delta\n}\n\nrobot.run(state: state, streaming: callback)\n</code></pre>"},{"location":"api/streaming/#block","title":"Block","text":"<pre><code>robot.run(state: state) do |event|\n  print event.text if event.type == :text_delta\nend\n</code></pre>"},{"location":"api/streaming/#object-with-call","title":"Object with <code>call</code>","text":"<pre><code>class StreamHandler\n  def call(event)\n    case event.type\n    when :text_delta\n      broadcast(event.text)\n    when :error\n      log_error(event.error)\n    end\n  end\nend\n\nrobot.run(state: state, streaming: StreamHandler.new)\n</code></pre>"},{"location":"api/streaming/#see-also","title":"See Also","text":"<ul> <li>Streaming Guide</li> <li>Robot</li> <li>Network</li> </ul>"},{"location":"api/streaming/context/","title":"StreamingContext","text":"<p>Manages streaming state during execution.</p>"},{"location":"api/streaming/context/#class-robotlabstreamingcontext","title":"Class: <code>RobotLab::Streaming::Context</code>","text":"<pre><code>context = RobotLab::Streaming::Context.new(callback: -&gt;(e) { handle(e) })\n</code></pre>"},{"location":"api/streaming/context/#constructor","title":"Constructor","text":"<pre><code>Context.new(callback:, robot: nil, network: nil)\n</code></pre> <p>Parameters:</p> Name Type Description <code>callback</code> <code>Proc</code> Event handler <code>robot</code> <code>Robot</code>, <code>nil</code> Current robot <code>network</code> <code>NetworkRun</code>, <code>nil</code> Network context"},{"location":"api/streaming/context/#attributes","title":"Attributes","text":""},{"location":"api/streaming/context/#callback","title":"callback","text":"<pre><code>context.callback  # =&gt; Proc\n</code></pre> <p>The event handler callback.</p>"},{"location":"api/streaming/context/#robot","title":"robot","text":"<pre><code>context.robot  # =&gt; Robot | nil\n</code></pre> <p>The currently executing robot.</p>"},{"location":"api/streaming/context/#network","title":"network","text":"<pre><code>context.network  # =&gt; NetworkRun | nil\n</code></pre> <p>The network run context.</p>"},{"location":"api/streaming/context/#buffer","title":"buffer","text":"<pre><code>context.buffer  # =&gt; String\n</code></pre> <p>Accumulated text content.</p>"},{"location":"api/streaming/context/#tool_calls","title":"tool_calls","text":"<pre><code>context.tool_calls  # =&gt; Array&lt;ToolCallMessage&gt;\n</code></pre> <p>Tool calls received during streaming.</p>"},{"location":"api/streaming/context/#methods","title":"Methods","text":""},{"location":"api/streaming/context/#emit","title":"emit","text":"<pre><code>context.emit(event)\n</code></pre> <p>Send an event to the callback.</p>"},{"location":"api/streaming/context/#emit_text","title":"emit_text","text":"<pre><code>context.emit_text(text)\n</code></pre> <p>Emit a text delta event.</p>"},{"location":"api/streaming/context/#emit_tool_call","title":"emit_tool_call","text":"<pre><code>context.emit_tool_call(id:, name:, input:)\n</code></pre> <p>Emit a tool call event.</p>"},{"location":"api/streaming/context/#emit_error","title":"emit_error","text":"<pre><code>context.emit_error(error)\n</code></pre> <p>Emit an error event.</p>"},{"location":"api/streaming/context/#complete","title":"complete","text":"<pre><code>context.complete\n</code></pre> <p>Signal streaming completion.</p>"},{"location":"api/streaming/context/#for_robot","title":"for_robot","text":"<pre><code>new_context = context.for_robot(robot)\n</code></pre> <p>Create a child context for a specific robot.</p>"},{"location":"api/streaming/context/#examples","title":"Examples","text":""},{"location":"api/streaming/context/#custom-context","title":"Custom Context","text":"<pre><code>context = RobotLab::Streaming::Context.new(\n  callback: -&gt;(event) {\n    case event.type\n    when :text_delta\n      @output &lt;&lt; event.text\n    when :complete\n      process_output(@output)\n    end\n  }\n)\n\n# Pass to robot\nrobot.run(state: state, streaming: context)\n</code></pre>"},{"location":"api/streaming/context/#accumulating-content","title":"Accumulating Content","text":"<pre><code>context = RobotLab::Streaming::Context.new(\n  callback: -&gt;(event) {\n    print event.text if event.type == :text_delta\n  }\n)\n\nrobot.run(state: state, streaming: context)\n\n# Access accumulated content\nputs \"Total content: #{context.buffer}\"\nputs \"Tool calls: #{context.tool_calls.size}\"\n</code></pre>"},{"location":"api/streaming/context/#network-context","title":"Network Context","text":"<pre><code>context = RobotLab::Streaming::Context.new(\n  callback: -&gt;(event) {\n    prefix = event.robot_name ? \"[#{event.robot_name}] \" : \"\"\n    case event.type\n    when :text_delta\n      print \"#{prefix}#{event.text}\"\n    when :robot_complete\n      puts \"\\n#{prefix}Complete\"\n    end\n  }\n)\n\nnetwork.run(state: state, streaming: context)\n</code></pre>"},{"location":"api/streaming/context/#see-also","title":"See Also","text":"<ul> <li>Streaming Overview</li> <li>Events</li> </ul>"},{"location":"api/streaming/events/","title":"Streaming Events","text":"<p>Event types for real-time response handling.</p>"},{"location":"api/streaming/events/#class-robotlabstreamingevent","title":"Class: <code>RobotLab::Streaming::Event</code>","text":"<pre><code>event.type        # =&gt; Symbol\nevent.text        # =&gt; String (for text events)\nevent.robot_name  # =&gt; String (for robot events)\n</code></pre>"},{"location":"api/streaming/events/#event-types","title":"Event Types","text":""},{"location":"api/streaming/events/#start","title":":start","text":"<p>Streaming has begun.</p> <pre><code>case event.type\nwhen :start\n  puts \"Starting...\"\nend\n</code></pre> <p>Attributes:</p> Name Type Description <code>robot_name</code> <code>String</code>, <code>nil</code> Robot name"},{"location":"api/streaming/events/#text_delta","title":":text_delta","text":"<p>A chunk of text was received.</p> <pre><code>case event.type\nwhen :text_delta\n  print event.text\nend\n</code></pre> <p>Attributes:</p> Name Type Description <code>text</code> <code>String</code> Text content <code>robot_name</code> <code>String</code>, <code>nil</code> Source robot"},{"location":"api/streaming/events/#tool_call","title":":tool_call","text":"<p>A tool is being invoked.</p> <pre><code>case event.type\nwhen :tool_call\n  puts \"Calling #{event.name} with #{event.input}\"\nend\n</code></pre> <p>Attributes:</p> Name Type Description <code>id</code> <code>String</code> Tool call ID <code>name</code> <code>String</code> Tool name <code>input</code> <code>Hash</code> Tool parameters <code>robot_name</code> <code>String</code>, <code>nil</code> Source robot"},{"location":"api/streaming/events/#tool_result","title":":tool_result","text":"<p>A tool has returned a result.</p> <pre><code>case event.type\nwhen :tool_result\n  puts \"#{event.name} returned: #{event.result}\"\nend\n</code></pre> <p>Attributes:</p> Name Type Description <code>id</code> <code>String</code> Tool call ID <code>name</code> <code>String</code> Tool name <code>result</code> <code>Object</code> Tool result <code>robot_name</code> <code>String</code>, <code>nil</code> Source robot"},{"location":"api/streaming/events/#robot_start","title":":robot_start","text":"<p>A robot has started executing (network only).</p> <pre><code>case event.type\nwhen :robot_start\n  puts \"Robot #{event.robot_name} starting\"\nend\n</code></pre> <p>Attributes:</p> Name Type Description <code>robot_name</code> <code>String</code> Robot name"},{"location":"api/streaming/events/#robot_complete","title":":robot_complete","text":"<p>A robot has finished executing (network only).</p> <pre><code>case event.type\nwhen :robot_complete\n  puts \"Robot #{event.robot_name} finished\"\nend\n</code></pre> <p>Attributes:</p> Name Type Description <code>robot_name</code> <code>String</code> Robot name <code>result</code> <code>RobotResult</code> Execution result"},{"location":"api/streaming/events/#complete","title":":complete","text":"<p>All streaming has finished.</p> <pre><code>case event.type\nwhen :complete\n  puts \"All done!\"\nend\n</code></pre>"},{"location":"api/streaming/events/#error","title":":error","text":"<p>An error occurred.</p> <pre><code>case event.type\nwhen :error\n  puts \"Error: #{event.error.message}\"\nend\n</code></pre> <p>Attributes:</p> Name Type Description <code>error</code> <code>Exception</code> The error <code>robot_name</code> <code>String</code>, <code>nil</code> Source robot"},{"location":"api/streaming/events/#examples","title":"Examples","text":""},{"location":"api/streaming/events/#complete-handler","title":"Complete Handler","text":"<pre><code>robot.run(state: state) do |event|\n  case event.type\n  when :start\n    puts \"=== Starting ===\"\n  when :text_delta\n    print event.text\n  when :tool_call\n    puts \"\\n[Tool: #{event.name}]\"\n  when :tool_result\n    puts \"[Result: #{event.result.to_s.truncate(50)}]\"\n  when :complete\n    puts \"\\n=== Complete ===\"\n  when :error\n    puts \"\\n!!! Error: #{event.error.message}\"\n  end\nend\n</code></pre>"},{"location":"api/streaming/events/#network-handler","title":"Network Handler","text":"<pre><code>network.run(state: state) do |event|\n  robot = event.robot_name || \"system\"\n\n  case event.type\n  when :robot_start\n    puts \"[#{robot}] Starting...\"\n  when :text_delta\n    print event.text\n  when :tool_call\n    puts \"\\n[#{robot}] Calling #{event.name}\"\n  when :robot_complete\n    puts \"\\n[#{robot}] Complete\"\n  when :error\n    puts \"\\n[#{robot}] Error: #{event.error.message}\"\n  end\nend\n</code></pre>"},{"location":"api/streaming/events/#filtering-events","title":"Filtering Events","text":"<pre><code># Only text\nrobot.run(state: state) do |event|\n  print event.text if event.type == :text_delta\nend\n\n# Only tools\nrobot.run(state: state) do |event|\n  if event.type == :tool_call\n    log_tool_usage(event.name, event.input)\n  end\nend\n</code></pre>"},{"location":"api/streaming/events/#async-processing","title":"Async Processing","text":"<pre><code>queue = Queue.new\n\nThread.new do\n  loop do\n    event = queue.pop\n    break if event == :done\n    process_event(event)\n  end\nend\n\nrobot.run(state: state) do |event|\n  queue &lt;&lt; event\n  queue &lt;&lt; :done if event.type == :complete\nend\n</code></pre>"},{"location":"api/streaming/events/#see-also","title":"See Also","text":"<ul> <li>Streaming Overview</li> <li>StreamingContext</li> <li>Streaming Guide</li> </ul>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>RobotLab is designed around a few core architectural principles that enable flexible, composable AI workflows.</p>"},{"location":"architecture/#design-philosophy","title":"Design Philosophy","text":""},{"location":"architecture/#1-separation-of-concerns","title":"1. Separation of Concerns","text":"<p>Each component has a single, well-defined responsibility:</p> <ul> <li>Robot: Encapsulates LLM interaction logic and personality</li> <li>Network: Orchestrates robot execution and routing</li> <li>State: Manages conversation and workflow data</li> <li>Tool: Provides external capabilities to robots</li> </ul>"},{"location":"architecture/#2-composability","title":"2. Composability","text":"<p>Components are designed to be mixed and matched:</p> <ul> <li>Robots can be reused across multiple networks</li> <li>Tools can be shared or robot-specific</li> <li>Networks can be nested or chained</li> <li>State can be persisted and restored</li> </ul>"},{"location":"architecture/#3-provider-agnostic","title":"3. Provider Agnostic","text":"<p>RobotLab abstracts away LLM provider differences:</p> <ul> <li>Unified message format across providers</li> <li>Consistent tool calling interface</li> <li>Automatic provider detection from model names</li> <li>Easy switching between providers</li> </ul>"},{"location":"architecture/#system-architecture","title":"System Architecture","text":"<pre><code>graph TB\n    subgraph \"Application Layer\"\n        A[Your Application]\n    end\n\n    subgraph \"RobotLab Core\"\n        B[Network]\n        C[Router]\n        D[Robot]\n        E[State]\n        F[Memory]\n    end\n\n    subgraph \"Integration Layer\"\n        G[Adapters]\n        H[MCP Client]\n        I[Tools]\n    end\n\n    subgraph \"Provider Layer\"\n        J[Anthropic]\n        K[OpenAI]\n        L[Gemini]\n        M[MCP Servers]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E\n    E --&gt; F\n    D --&gt; G\n    D --&gt; H\n    D --&gt; I\n    G --&gt; J\n    G --&gt; K\n    G --&gt; L\n    H --&gt; M</code></pre>"},{"location":"architecture/#core-components","title":"Core Components","text":"Component Description Documentation Robot LLM-powered agent with personality and tools Core Concepts Network Orchestrates multiple robots Network Orchestration State Conversation and workflow data State Management Router Determines robot execution order Network Orchestration Memory Shared key-value store State Management Adapter Provider-specific message conversion Message Flow"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<ol> <li>Input: User message enters via State</li> <li>Routing: Router selects robot(s) to execute</li> <li>Execution: Robot processes message with LLM</li> <li>Tools: Robot may call tools during execution</li> <li>Result: Robot returns RobotResult</li> <li>Iteration: Router checks for next robot</li> <li>Output: Final results returned to application</li> </ol>"},{"location":"architecture/#key-patterns","title":"Key Patterns","text":""},{"location":"architecture/#builder-pattern","title":"Builder Pattern","text":"<p>Robots and networks are constructed using a fluent DSL:</p> <pre><code>robot = RobotLab.build do\n  name \"assistant\"\n  model \"claude-sonnet-4\"\n  template \"You are helpful.\"\nend\n</code></pre>"},{"location":"architecture/#strategy-pattern","title":"Strategy Pattern","text":"<p>Routers implement custom selection logic:</p> <pre><code>router = -&gt;(args) {\n  # Custom routing strategy\n  args.call_count.zero? ? :first_robot : nil\n}\n</code></pre>"},{"location":"architecture/#adapter-pattern","title":"Adapter Pattern","text":"<p>Provider adapters normalize LLM interfaces:</p> <pre><code>adapter = Adapters::Registry.for(:anthropic)\nmessages = adapter.format_messages(robot_lab_messages)\n</code></pre>"},{"location":"architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts - Deep dive into robots and tools</li> <li>Robot Execution - How robots process messages</li> <li>Network Orchestration - Multi-robot workflows</li> <li>State Management - Managing conversation state</li> <li>Message Flow - How messages move through the system</li> </ul>"},{"location":"architecture/core-concepts/","title":"Core Concepts","text":"<p>This page provides an in-depth look at RobotLab's fundamental building blocks.</p>"},{"location":"architecture/core-concepts/#robot","title":"Robot","text":"<p>A Robot is the primary unit of computation in RobotLab. It wraps an LLM with:</p> <ul> <li>A unique identity (name, description)</li> <li>A personality (system prompt/template)</li> <li>Capabilities (tools, MCP connections)</li> <li>A specific model configuration</li> </ul>"},{"location":"architecture/core-concepts/#robot-anatomy","title":"Robot Anatomy","text":"<pre><code>robot = RobotLab.build do\n  name \"support_agent\"                    # Unique identifier\n  description \"Handles support requests\"  # Used for routing hints\n  model \"claude-sonnet-4\"                 # LLM model\n\n  # System prompt - defines personality\n  template &lt;&lt;~PROMPT\n    You are a friendly customer support agent for Acme Corp.\n    Always be polite and helpful. If you don't know something,\n    say so honestly.\n  PROMPT\n\n  # Tools - extend capabilities\n  tool :lookup_account do\n    description \"Look up customer account\"\n    parameter :email, type: :string, required: true\n    handler { |email:, **_| Account.find_by_email(email)&amp;.to_h }\n  end\n\n  # MCP - external tool servers\n  mcp :inherit  # Use network's MCP servers\nend\n</code></pre>"},{"location":"architecture/core-concepts/#robot-lifecycle","title":"Robot Lifecycle","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Created: RobotLab.build\n    Created --&gt; Running: robot.run(state)\n    Running --&gt; ToolExecution: tool_call\n    ToolExecution --&gt; Running: result\n    Running --&gt; Completed: stop_reason\n    Completed --&gt; [*]</code></pre>"},{"location":"architecture/core-concepts/#robot-properties","title":"Robot Properties","text":"Property Type Description <code>name</code> String Unique identifier within network <code>description</code> String What the robot does <code>model</code> String LLM model to use <code>template</code> String System prompt <code>local_tools</code> Array Defined tools <code>mcp_clients</code> Array Connected MCP clients"},{"location":"architecture/core-concepts/#tool","title":"Tool","text":"<p>Tools give robots the ability to interact with external systems.</p>"},{"location":"architecture/core-concepts/#tool-structure","title":"Tool Structure","text":"<pre><code>tool = RobotLab::Tool.new(\n  name: \"get_weather\",\n  description: \"Get current weather for a location\",\n  parameters: {\n    location: {\n      type: \"string\",\n      description: \"City name\",\n      required: true\n    },\n    unit: {\n      type: \"string\",\n      enum: [\"celsius\", \"fahrenheit\"],\n      default: \"celsius\"\n    }\n  },\n  handler: -&gt;(location:, unit: \"celsius\", **_context) {\n    WeatherAPI.current(location, unit: unit)\n  }\n)\n</code></pre>"},{"location":"architecture/core-concepts/#tool-execution","title":"Tool Execution","text":"<p>When an LLM decides to use a tool:</p> <ol> <li>LLM generates a <code>ToolCallMessage</code> with tool name and arguments</li> <li>RobotLab validates arguments against the tool's schema</li> <li>Tool handler is called with validated arguments</li> <li>Result is wrapped in a <code>ToolResultMessage</code></li> <li>Result is sent back to the LLM for continued processing</li> </ol>"},{"location":"architecture/core-concepts/#handler-context","title":"Handler Context","text":"<p>Tool handlers receive context about the current execution:</p> <pre><code>handler: -&gt;(param:, robot:, network:, state:) {\n  # robot - The Robot instance executing the tool\n  # network - The Network (or NetworkRun) context\n  # state - Current State with data, results, memory\n}\n</code></pre> <p>Ignoring Context</p> <p>Use <code>**_context</code> to accept but ignore context parameters: <pre><code>handler: -&gt;(location:, **_context) { ... }\n</code></pre></p>"},{"location":"architecture/core-concepts/#toolmanifest","title":"ToolManifest","text":"<p>When you need to modify tool metadata without changing functionality:</p> <pre><code>manifest = RobotLab::ToolManifest.new(\n  tool: existing_tool,\n  name: \"custom_name\",           # Override name\n  description: \"New description\" # Override description\n)\n</code></pre>"},{"location":"architecture/core-concepts/#message-types","title":"Message Types","text":"<p>RobotLab uses a type hierarchy for messages:</p> <pre><code>classDiagram\n    Message &lt;|-- TextMessage\n    Message &lt;|-- ToolMessage\n    ToolMessage &lt;|-- ToolCallMessage\n    ToolMessage &lt;|-- ToolResultMessage\n\n    class Message {\n        +String type\n        +String role\n        +String content\n        +String stop_reason\n    }\n\n    class TextMessage {\n        +text?()\n        +user?()\n        +assistant?()\n    }\n\n    class ToolMessage {\n        +String id\n        +String name\n        +Hash input\n    }\n\n    class ToolCallMessage {\n        +Array~ToolMessage~ tools\n    }\n\n    class ToolResultMessage {\n        +ToolMessage tool\n        +Hash content\n    }</code></pre>"},{"location":"architecture/core-concepts/#message-roles","title":"Message Roles","text":"Role Description <code>user</code> Input from the user <code>assistant</code> Response from the LLM <code>system</code> System instructions <code>tool</code> Tool call or result"},{"location":"architecture/core-concepts/#stop-reasons","title":"Stop Reasons","text":"Reason Description <code>stop</code> Natural completion <code>tool</code> Tool call requested <code>max_tokens</code> Token limit reached"},{"location":"architecture/core-concepts/#robotresult","title":"RobotResult","text":"<p>The output from a robot execution:</p> <pre><code>result = robot.run(state: state, network: network)\n\nresult.robot_name   # =&gt; \"support_agent\"\nresult.output       # =&gt; [TextMessage, ...]\nresult.tool_calls   # =&gt; [ToolMessage, ...]\nresult.stop_reason  # =&gt; \"stop\"\nresult.created_at   # =&gt; Time\n</code></pre>"},{"location":"architecture/core-concepts/#accessing-response-content","title":"Accessing Response Content","text":"<pre><code># Get text response\ntext = result.output.select(&amp;:text?).map(&amp;:content).join\n\n# Check if tools were called\nhas_tools = result.tool_calls.any?\n\n# Get all tool names called\ntool_names = result.tool_calls.map(&amp;:name)\n</code></pre>"},{"location":"architecture/core-concepts/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>RobotLab uses a cascading configuration system:</p> <pre><code>Global (RobotLab.configure)\n\u2502\n\u251c\u2500\u2500 mcp: [server1, server2]\n\u251c\u2500\u2500 tools: [tool1, tool2]\n\u2502\n\u2514\u2500\u2500 Network\n    \u2502\n    \u251c\u2500\u2500 mcp: :inherit | :none | [servers]\n    \u251c\u2500\u2500 tools: :inherit | :none | [tools]\n    \u2502\n    \u2514\u2500\u2500 Robot\n        \u2502\n        \u251c\u2500\u2500 mcp: :inherit | :none | [servers]\n        \u2514\u2500\u2500 tools: :inherit | :none | [tools]\n</code></pre> <p>The <code>:inherit</code> value pulls from the parent level.</p>"},{"location":"architecture/core-concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Robot Execution - Detailed execution flow</li> <li>Network Orchestration - Multi-robot coordination</li> <li>State Management - Managing conversation state</li> </ul>"},{"location":"architecture/message-flow/","title":"Message Flow","text":"<p>This page explains how messages move through RobotLab, from user input to LLM response.</p>"},{"location":"architecture/message-flow/#message-types","title":"Message Types","text":"<p>RobotLab uses four primary message types:</p> <pre><code>classDiagram\n    class Message {\n        &lt;&lt;abstract&gt;&gt;\n        +type: String\n        +role: String\n        +content: String\n        +stop_reason: String\n    }\n\n    class TextMessage {\n        +text?() bool\n        +user?() bool\n        +assistant?() bool\n        +system?() bool\n    }\n\n    class ToolMessage {\n        +id: String\n        +name: String\n        +input: Hash\n        +tool_call?() bool\n    }\n\n    class ToolCallMessage {\n        +tools: Array~ToolMessage~\n    }\n\n    class ToolResultMessage {\n        +tool: ToolMessage\n        +content: Hash\n        +tool_result?() bool\n    }\n\n    Message &lt;|-- TextMessage\n    Message &lt;|-- ToolMessage\n    ToolMessage &lt;|-- ToolCallMessage\n    ToolMessage &lt;|-- ToolResultMessage</code></pre>"},{"location":"architecture/message-flow/#textmessage","title":"TextMessage","text":"<p>Regular text content from users or assistants:</p> <pre><code>TextMessage.new(\n  role: \"user\",\n  content: \"What's the weather in Paris?\"\n)\n\nTextMessage.new(\n  role: \"assistant\",\n  content: \"The weather in Paris is sunny and 22\u00b0C.\",\n  stop_reason: \"stop\"\n)\n</code></pre>"},{"location":"architecture/message-flow/#toolmessage","title":"ToolMessage","text":"<p>Base class for tool-related messages:</p> <pre><code>ToolMessage.new(\n  id: \"tool_123\",\n  name: \"get_weather\",\n  input: { location: \"Paris\" }\n)\n</code></pre>"},{"location":"architecture/message-flow/#toolcallmessage","title":"ToolCallMessage","text":"<p>LLM's request to execute tools:</p> <pre><code>ToolCallMessage.new(\n  role: \"assistant\",\n  content: nil,\n  stop_reason: \"tool\",\n  tools: [\n    ToolMessage.new(id: \"call_1\", name: \"get_weather\", input: { location: \"Paris\" })\n  ]\n)\n</code></pre>"},{"location":"architecture/message-flow/#toolresultmessage","title":"ToolResultMessage","text":"<p>Result from tool execution:</p> <pre><code>ToolResultMessage.new(\n  tool: tool_message,\n  content: { data: { temp: 22, condition: \"sunny\" } }\n)\n</code></pre>"},{"location":"architecture/message-flow/#message-flow-diagram","title":"Message Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant User\n    participant State\n    participant Robot\n    participant Adapter\n    participant LLM\n\n    User-&gt;&gt;State: UserMessage\n    State-&gt;&gt;State: Format messages\n    State-&gt;&gt;Robot: state.messages\n    Robot-&gt;&gt;Adapter: Convert messages\n    Adapter-&gt;&gt;LLM: Provider-specific format\n\n    LLM--&gt;&gt;Adapter: Response\n    Adapter--&gt;&gt;Robot: Parse response\n    Robot-&gt;&gt;Robot: Execute tools (if any)\n    Robot--&gt;&gt;State: RobotResult\n    State-&gt;&gt;State: Append result\n    State--&gt;&gt;User: Response</code></pre>"},{"location":"architecture/message-flow/#adapter-layer","title":"Adapter Layer","text":"<p>Adapters convert between RobotLab's message format and provider-specific formats.</p>"},{"location":"architecture/message-flow/#anthropic-adapter","title":"Anthropic Adapter","text":"<pre><code># RobotLab format\nmessages = [\n  TextMessage.new(role: \"user\", content: \"Hello\"),\n  TextMessage.new(role: \"assistant\", content: \"Hi there!\")\n]\n\n# Converted to Anthropic format\n[\n  { role: \"user\", content: \"Hello\" },\n  { role: \"assistant\", content: \"Hi there!\" }\n]\n</code></pre>"},{"location":"architecture/message-flow/#system-message-handling","title":"System Message Handling","text":"<p>System messages are handled specially:</p> <pre><code># RobotLab\nmessages = [\n  TextMessage.new(role: \"system\", content: \"You are helpful.\"),\n  TextMessage.new(role: \"user\", content: \"Hello\")\n]\n\n# Anthropic: system extracted separately\n# OpenAI: system message stays in array\n# Gemini: converted to context\n</code></pre>"},{"location":"architecture/message-flow/#tool-message-conversion","title":"Tool Message Conversion","text":"<p>Tool calls are provider-specific:</p> AnthropicOpenAI <pre><code>{\n  type: \"tool_use\",\n  id: \"tool_123\",\n  name: \"get_weather\",\n  input: { location: \"Paris\" }\n}\n</code></pre> <pre><code>{\n  type: \"function\",\n  function: {\n    name: \"get_weather\",\n    arguments: '{\"location\":\"Paris\"}'\n  }\n}\n</code></pre>"},{"location":"architecture/message-flow/#conversation-building","title":"Conversation Building","text":""},{"location":"architecture/message-flow/#initial-state","title":"Initial State","text":"<pre><code>state = RobotLab.create_state(\n  message: \"What's the weather?\",\n  data: { location: \"Paris\" }\n)\n\nstate.messages\n# =&gt; [TextMessage(role: \"user\", content: \"What's the weather?\")]\n</code></pre>"},{"location":"architecture/message-flow/#after-robot-execution","title":"After Robot Execution","text":"<pre><code>result = robot.run(state: state, network: network)\nstate.append_result(result)\n\nstate.messages\n# =&gt; [\n#   TextMessage(role: \"user\", content: \"What's the weather?\"),\n#   TextMessage(role: \"assistant\", content: \"The weather is sunny.\")\n# ]\n</code></pre>"},{"location":"architecture/message-flow/#with-tool-calls","title":"With Tool Calls","text":"<pre><code>state.messages\n# =&gt; [\n#   TextMessage(role: \"user\", content: \"What's the weather?\"),\n#   ToolCallMessage(tools: [ToolMessage(name: \"get_weather\", ...)]),\n#   ToolResultMessage(content: { temp: 22 }),\n#   TextMessage(role: \"assistant\", content: \"It's 22\u00b0C and sunny.\")\n# ]\n</code></pre>"},{"location":"architecture/message-flow/#format-history","title":"Format History","text":"<p>The <code>format_history</code> method prepares messages for LLM:</p> <pre><code># Includes results from previous robots\nformatted = state.format_history\n\n# Returns alternating user/assistant messages\n# with tool calls/results properly interleaved\n</code></pre>"},{"location":"architecture/message-flow/#message-predicates","title":"Message Predicates","text":"<p>Check message types easily:</p> <pre><code>message.text?         # Is it a TextMessage?\nmessage.tool_call?    # Is it a ToolCallMessage?\nmessage.tool_result?  # Is it a ToolResultMessage?\n\nmessage.user?         # Is role \"user\"?\nmessage.assistant?    # Is role \"assistant\"?\nmessage.system?       # Is role \"system\"?\n\nmessage.stopped?      # Is stop_reason \"stop\"?\nmessage.tool_stop?    # Is stop_reason \"tool\"?\n</code></pre>"},{"location":"architecture/message-flow/#creating-messages","title":"Creating Messages","text":""},{"location":"architecture/message-flow/#from-strings","title":"From Strings","text":"<pre><code>TextMessage.new(role: \"user\", content: \"Hello\")\n</code></pre>"},{"location":"architecture/message-flow/#from-hashes","title":"From Hashes","text":"<pre><code>Message.from_hash(\n  type: \"text\",\n  role: \"user\",\n  content: \"Hello\"\n)\n</code></pre>"},{"location":"architecture/message-flow/#from-usermessage","title":"From UserMessage","text":"<pre><code>user_msg = UserMessage.new(\"Hello\", thread_id: \"123\")\ntext_msg = user_msg.to_message\n# =&gt; TextMessage(role: \"user\", content: \"Hello\")\n</code></pre>"},{"location":"architecture/message-flow/#serialization","title":"Serialization","text":"<p>Messages can be serialized:</p> <pre><code># To hash\nhash = message.to_h\n# =&gt; { type: \"text\", role: \"user\", content: \"Hello\" }\n\n# To JSON\njson = message.to_json\n# =&gt; '{\"type\":\"text\",\"role\":\"user\",\"content\":\"Hello\"}'\n\n# From hash\nmessage = Message.from_hash(hash)\n</code></pre>"},{"location":"architecture/message-flow/#provider-registry","title":"Provider Registry","text":"<p>The adapter registry maps providers to adapters:</p> <pre><code>Adapters::Registry.for(:anthropic)  # =&gt; Adapters::Anthropic\nAdapters::Registry.for(:openai)     # =&gt; Adapters::OpenAI\nAdapters::Registry.for(:gemini)     # =&gt; Adapters::Gemini\n\n# Aliases\nAdapters::Registry.for(:azure_openai)  # =&gt; Adapters::OpenAI\nAdapters::Registry.for(:bedrock)       # =&gt; Adapters::Anthropic\n</code></pre>"},{"location":"architecture/message-flow/#next-steps","title":"Next Steps","text":"<ul> <li>Building Robots - Creating custom robots</li> <li>Using Tools - Tool message handling</li> <li>API Reference: Messages - Detailed message API</li> </ul>"},{"location":"architecture/network-orchestration/","title":"Network Orchestration","text":"<p>Networks coordinate multiple robots using SimpleFlow pipelines for DAG-based execution.</p>"},{"location":"architecture/network-orchestration/#network-structure","title":"Network Structure","text":"<p>A network is a thin wrapper around <code>SimpleFlow::Pipeline</code>:</p> <ul> <li>Pipeline: DAG-based execution engine</li> <li>Robots: Named collection of task handlers</li> <li>Tasks: Define dependencies and execution order</li> </ul> <pre><code>network = RobotLab.create_network(name: \"customer_service\") do\n  task :classifier, classifier_robot, depends_on: :none\n  task :billing, billing_robot, depends_on: :optional\n  task :technical, technical_robot, depends_on: :optional\nend\n</code></pre>"},{"location":"architecture/network-orchestration/#task-configuration","title":"Task Configuration","text":"<p>Tasks can have per-task configuration that's deep-merged with network run params:</p> <pre><code>network = RobotLab.create_network(name: \"support\") do\n  task :classifier, classifier_robot, depends_on: :none\n  task :billing, billing_robot,\n       context: { department: \"billing\", escalation_level: 2 },\n       tools: [RefundTool],\n       depends_on: :optional\n  task :technical, technical_robot,\n       context: { department: \"technical\" },\n       mcp: [FilesystemServer],\n       depends_on: :optional\nend\n</code></pre>"},{"location":"architecture/network-orchestration/#execution-model","title":"Execution Model","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Start\n    Start --&gt; ExecuteTask: next ready task\n    ExecuteTask --&gt; CheckDependents: task complete\n    CheckDependents --&gt; ExecuteTask: more tasks ready\n    CheckDependents --&gt; Complete: all tasks done\n    ExecuteTask --&gt; Halted: task halts\n    Complete --&gt; [*]\n    Halted --&gt; [*]</code></pre>"},{"location":"architecture/network-orchestration/#task-dependency-types","title":"Task Dependency Types","text":"Type Description <code>:none</code> No dependencies, runs first <code>[:task1, :task2]</code> Waits for listed tasks <code>:optional</code> Only runs when activated"},{"location":"architecture/network-orchestration/#robotcall-interface","title":"Robot#call Interface","text":"<p>Each robot implements the SimpleFlow step interface:</p> <pre><code>class Robot\n  def call(result)\n    # Run the LLM\n    robot_result = run(**extract_run_context(result))\n\n    # Return new result with context\n    result\n      .with_context(@name.to_sym, robot_result)\n      .continue(robot_result)\n  end\nend\n</code></pre>"},{"location":"architecture/network-orchestration/#result-methods","title":"Result Methods","text":"Method Description <code>continue(value)</code> Continue to next tasks <code>halt(value)</code> Stop pipeline execution <code>with_context(key, val)</code> Add data to context <code>activate(task_name)</code> Enable optional task"},{"location":"architecture/network-orchestration/#simpleflowresult","title":"SimpleFlow::Result","text":"<p>The result object flows through the pipeline:</p> <pre><code>result.value      # Current task's output\nresult.context    # Accumulated context from all tasks\nresult.halted?    # Whether execution stopped early\nresult.continued? # Whether execution continues\n</code></pre>"},{"location":"architecture/network-orchestration/#context-structure","title":"Context Structure","text":"<pre><code>{\n  run_params: { message: \"...\", customer_id: 123 },\n  classifier: RobotResult,\n  billing: RobotResult,\n  # ... other task results\n}\n</code></pre>"},{"location":"architecture/network-orchestration/#optional-task-activation","title":"Optional Task Activation","text":"<p>Optional tasks don't run automatically. They must be activated:</p> <pre><code>class ClassifierRobot &lt; RobotLab::Robot\n  def call(result)\n    robot_result = run(**extract_run_context(result))\n\n    new_result = result\n      .with_context(@name.to_sym, robot_result)\n      .continue(robot_result)\n\n    # Analyze output and activate appropriate task\n    category = robot_result.last_text_content.to_s.downcase\n\n    case category\n    when /billing/\n      new_result.activate(:billing)\n    when /technical/\n      new_result.activate(:technical)\n    else\n      new_result.activate(:general)\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/network-orchestration/#parallel-execution","title":"Parallel Execution","text":"<p>Tasks with the same dependencies can run in parallel:</p> <pre><code>network = RobotLab.create_network(name: \"analysis\", concurrency: :threads) do\n  task :fetch, fetcher, depends_on: :none\n\n  # These three run in parallel\n  task :sentiment, sentiment_bot, depends_on: [:fetch]\n  task :entities, entity_bot, depends_on: [:fetch]\n  task :keywords, keyword_bot, depends_on: [:fetch]\n\n  # Waits for all three\n  task :merge, merger, depends_on: [:sentiment, :entities, :keywords]\nend\n</code></pre>"},{"location":"architecture/network-orchestration/#concurrency-modes","title":"Concurrency Modes","text":"Mode Description <code>:auto</code> SimpleFlow chooses best mode <code>:threads</code> Use Ruby threads <code>:async</code> Use async/fiber"},{"location":"architecture/network-orchestration/#data-flow","title":"Data Flow","text":"<ol> <li>Initial Value: <code>network.run(**params)</code> creates initial result</li> <li>Run Params: Stored in <code>result.context[:run_params]</code></li> <li>Task Results: Each task adds to context</li> <li>Final Value: Last task's output becomes <code>result.value</code></li> </ol> <pre><code># Run with context\nresult = network.run(\n  message: \"Help with billing\",\n  customer_id: 123\n)\n\n# Access the flow\nresult.context[:run_params]  # { message: \"...\", customer_id: 123 }\nresult.context[:classifier]  # First robot's RobotResult\nresult.context[:billing]     # Billing robot's RobotResult\nresult.value                 # Final RobotResult\n</code></pre>"},{"location":"architecture/network-orchestration/#visualization","title":"Visualization","text":"<p>Networks provide visualization methods:</p> <pre><code># ASCII representation\nputs network.visualize\n\n# Mermaid diagram\nputs network.to_mermaid\n\n# Execution plan description\nputs network.execution_plan\n</code></pre>"},{"location":"architecture/network-orchestration/#network-configuration","title":"Network Configuration","text":"<pre><code>network = RobotLab.create_network(\n  name: \"support\",\n  concurrency: :threads  # :auto, :threads, or :async\n) do\n  task :classifier, classifier, depends_on: :none\n  task :handler, handler, depends_on: [:classifier]\nend\n</code></pre>"},{"location":"architecture/network-orchestration/#next-steps","title":"Next Steps","text":"<ul> <li>Creating Networks - Practical patterns</li> <li>Robot Execution - How robots process messages</li> <li>API Reference: Network - Complete API</li> </ul>"},{"location":"architecture/robot-execution/","title":"Robot Execution","text":"<p>This page details how a robot processes messages and generates responses.</p>"},{"location":"architecture/robot-execution/#execution-overview","title":"Execution Overview","text":"<p>When you call <code>robot.run(state:, network:)</code>, several steps occur:</p> <pre><code>sequenceDiagram\n    participant App as Application\n    participant Robot\n    participant Model as RoboticModel\n    participant Adapter\n    participant LLM\n\n    App-&gt;&gt;Robot: run(state, network)\n    Robot-&gt;&gt;Robot: resolve_tools()\n    Robot-&gt;&gt;Model: infer(messages, tools)\n    Model-&gt;&gt;Adapter: format_messages()\n    Model-&gt;&gt;LLM: API Request\n\n    loop Tool Calls\n        LLM--&gt;&gt;Model: tool_call response\n        Model-&gt;&gt;Robot: execute_tool()\n        Robot-&gt;&gt;Model: tool_result\n        Model-&gt;&gt;LLM: continue\n    end\n\n    LLM--&gt;&gt;Model: final response\n    Model-&gt;&gt;Adapter: parse_response()\n    Model--&gt;&gt;Robot: InferenceResponse\n    Robot--&gt;&gt;App: RobotResult</code></pre>"},{"location":"architecture/robot-execution/#step-by-step-flow","title":"Step-by-Step Flow","text":""},{"location":"architecture/robot-execution/#1-tool-resolution","title":"1. Tool Resolution","text":"<p>Before making any LLM call, the robot resolves available tools:</p> <pre><code># Internal process\ntools = []\ntools += local_tools           # Tools defined on robot\ntools += mcp_tools             # Tools from MCP servers\ntools = apply_whitelist(tools) # Filter by allowed tools\n</code></pre>"},{"location":"architecture/robot-execution/#2-message-preparation","title":"2. Message Preparation","text":"<p>The robot prepares messages from state:</p> <pre><code>messages = []\nmessages &lt;&lt; system_message     # From template\nmessages += state.messages     # Conversation history\nmessages &lt;&lt; user_message       # Current input\n</code></pre>"},{"location":"architecture/robot-execution/#3-llm-inference","title":"3. LLM Inference","text":"<p>Messages are sent to the LLM via <code>RoboticModel</code>:</p> <pre><code>response = model.infer(\n  messages,\n  tools,\n  tool_choice: \"auto\",\n  streaming: streaming_callback\n)\n</code></pre>"},{"location":"architecture/robot-execution/#4-tool-execution-loop","title":"4. Tool Execution Loop","text":"<p>If the LLM requests tool calls:</p> <pre><code>loop do\n  if response.wants_tools?\n    response.tool_calls.each do |tool_call|\n      result = execute_tool(tool_call)\n      # Result sent back to LLM\n    end\n    response = model.continue_with_results(results)\n  else\n    break\n  end\nend\n</code></pre>"},{"location":"architecture/robot-execution/#5-result-construction","title":"5. Result Construction","text":"<p>Finally, a <code>RobotResult</code> is created:</p> <pre><code>RobotResult.new(\n  robot_name: name,\n  output: response.output,\n  tool_calls: executed_tools,\n  stop_reason: response.stop_reason\n)\n</code></pre>"},{"location":"architecture/robot-execution/#tool-execution","title":"Tool Execution","text":""},{"location":"architecture/robot-execution/#tool-call-processing","title":"Tool Call Processing","text":"<p>When the LLM requests a tool:</p> <ol> <li>Identify Tool: Match tool name to registered tools</li> <li>Validate Input: Check parameters against schema</li> <li>Execute Handler: Call the tool's handler function</li> <li>Capture Result: Wrap response in ToolResultMessage</li> <li>Return to LLM: Send result for continued processing</li> </ol>"},{"location":"architecture/robot-execution/#execution-context","title":"Execution Context","text":"<p>Tools receive context about their execution environment:</p> <pre><code>tool.handler.call(\n  **tool_call.input,  # User-provided arguments\n  robot: self,        # The executing robot\n  network: network,   # Network context\n  state: state        # Current state\n)\n</code></pre>"},{"location":"architecture/robot-execution/#error-handling","title":"Error Handling","text":"<p>Tool errors are captured and returned to the LLM:</p> <pre><code>begin\n  result = tool.handler.call(**args)\n  ToolResultMessage.new(tool: tool_call, content: { data: result })\nrescue StandardError =&gt; e\n  ToolResultMessage.new(tool: tool_call, content: { error: e.message })\nend\n</code></pre>"},{"location":"architecture/robot-execution/#iteration-limits","title":"Iteration Limits","text":"<p>Robot execution has safeguards:</p> Limit Default Purpose <code>max_tool_iterations</code> 10 Max tool calls per robot run <p>When limits are reached, execution stops with the current state.</p>"},{"location":"architecture/robot-execution/#streaming","title":"Streaming","text":"<p>Robots support streaming responses:</p> <pre><code>robot.run(\n  state: state,\n  network: network,\n  streaming: -&gt;(event) {\n    case event.type\n    when :delta then print event.content\n    when :tool_call then puts \"Calling: #{event.tool_name}\"\n    end\n  }\n)\n</code></pre>"},{"location":"architecture/robot-execution/#streaming-events","title":"Streaming Events","text":"Event Type Description <code>run.started</code> Robot execution began <code>delta</code> Text content chunk <code>tool_call</code> Tool execution starting <code>tool_result</code> Tool execution complete <code>run.completed</code> Robot execution finished <code>run.failed</code> Error occurred"},{"location":"architecture/robot-execution/#model-selection","title":"Model Selection","text":"<p>The model is determined by:</p> <ol> <li>Robot's explicit <code>model</code> setting</li> <li>Network's <code>default_model</code></li> <li>Global <code>RobotLab.configuration.default_model</code></li> </ol> <pre><code>robot = RobotLab.build do\n  model \"claude-sonnet-4\"  # Takes precedence\nend\n\nnetwork = RobotLab.create_network do\n  default_model \"gpt-4\"    # Fallback for robots without model\nend\n</code></pre>"},{"location":"architecture/robot-execution/#provider-detection","title":"Provider Detection","text":"<p>If no provider is specified, it's detected from model name:</p> Model Pattern Provider <code>claude-*</code>, <code>anthropic-*</code> <code>:anthropic</code> <code>gpt-*</code>, <code>o1-*</code>, <code>chatgpt-*</code> <code>:openai</code> <code>gemini-*</code> <code>:gemini</code> <code>llama-*</code>, <code>mistral-*</code> <code>:ollama</code>"},{"location":"architecture/robot-execution/#roboticmodel","title":"RoboticModel","text":"<p>The <code>RoboticModel</code> class handles LLM communication:</p> <pre><code>model = RoboticModel.new(\"claude-sonnet-4\", provider: :anthropic)\n\n# Full inference\nresponse = model.infer(messages, tools)\n\n# Quick ask\nresponse = model.ask(\"What is 2+2?\", system: \"You are a math tutor\")\n</code></pre>"},{"location":"architecture/robot-execution/#inferenceresponse","title":"InferenceResponse","text":"<p>The response object provides:</p> <pre><code>response.output              # Array&lt;Message&gt; - parsed output\nresponse.raw                 # Original LLM response\nresponse.stop_reason         # \"stop\", \"tool\", etc.\nresponse.stopped?            # true if naturally completed\nresponse.wants_tools?        # true if tool calls pending\nresponse.tool_calls          # Array&lt;ToolMessage&gt;\nresponse.text_content        # Combined text from output\nresponse.captured_tool_results  # Auto-executed tool results\n</code></pre>"},{"location":"architecture/robot-execution/#next-steps","title":"Next Steps","text":"<ul> <li>Network Orchestration - Multi-robot coordination</li> <li>State Management - Managing state across robots</li> <li>Using Tools - Creating and using tools</li> </ul>"},{"location":"architecture/state-management/","title":"State Management","text":"<p>State in RobotLab tracks all data and history for a conversation or workflow.</p>"},{"location":"architecture/state-management/#state-structure","title":"State Structure","text":"<p>The <code>State</code> class holds:</p> <pre><code>state = RobotLab.create_state(\n  message: \"Hello!\",           # Current user message\n  data: { user_id: \"123\" }     # Custom workflow data\n)\n\nstate.data        # StateProxy - custom key-value data\nstate.results     # Array&lt;RobotResult&gt; - execution history\nstate.messages    # Array&lt;Message&gt; - formatted conversation\nstate.thread_id   # String - optional persistence ID\nstate.memory      # Memory - shared key-value store\n</code></pre>"},{"location":"architecture/state-management/#creating-state","title":"Creating State","text":""},{"location":"architecture/state-management/#basic-creation","title":"Basic Creation","text":"<pre><code>state = RobotLab.create_state(message: \"What's the weather?\")\n</code></pre>"},{"location":"architecture/state-management/#with-custom-data","title":"With Custom Data","text":"<pre><code>state = RobotLab.create_state(\n  message: \"Process my order\",\n  data: {\n    user_id: \"user_123\",\n    order_id: \"ord_456\",\n    priority: \"high\"\n  }\n)\n</code></pre>"},{"location":"architecture/state-management/#from-existing-results","title":"From Existing Results","text":"<pre><code>state = RobotLab.create_state(\n  message: \"Continue our conversation\",\n  results: previous_results,\n  thread_id: \"thread_abc\"\n)\n</code></pre>"},{"location":"architecture/state-management/#stateproxy","title":"StateProxy","text":"<p>The <code>data</code> attribute is a <code>StateProxy</code> that provides convenient access:</p> <pre><code>state.data[:user_id]          # Hash-style access\nstate.data[:user_id] = \"456\"  # Assignment\n\nstate.data.user_id            # Method-style access\nstate.data.user_id = \"456\"    # Method-style assignment\n\nstate.data.key?(:user_id)     # Check existence\nstate.data.keys               # Get all keys\nstate.data.to_h               # Convert to plain hash\n</code></pre>"},{"location":"architecture/state-management/#change-tracking","title":"Change Tracking","text":"<p>StateProxy can track changes:</p> <pre><code>state = State.new(\n  data: { count: 0 },\n  on_change: -&gt;(key, old_val, new_val) {\n    puts \"#{key}: #{old_val} -&gt; #{new_val}\"\n  }\n)\n\nstate.data[:count] = 1  # Prints: \"count: 0 -&gt; 1\"\n</code></pre>"},{"location":"architecture/state-management/#memory","title":"Memory","text":"<p>Memory provides a shared key-value store across robots:</p> <pre><code># Store values\nstate.memory.remember(\"user_name\", \"Alice\")\nstate.memory.remember(\"preferences\", { theme: \"dark\" })\n\n# Retrieve values\nname = state.memory.recall(\"user_name\")  # =&gt; \"Alice\"\n\n# Check existence\nstate.memory.exists?(\"user_name\")  # =&gt; true\n\n# Remove values\nstate.memory.forget(\"user_name\")\n\n# List all\nstate.memory.all  # =&gt; { \"user_name\" =&gt; \"Alice\", ... }\n</code></pre>"},{"location":"architecture/state-management/#scoped-memory","title":"Scoped Memory","text":"<p>Organize memory with namespaces:</p> <pre><code># Create scoped view\nuser_memory = state.memory.scoped(\"user:123\")\nuser_memory.remember(\"last_login\", Time.now)\n\n# Access scoped data\nuser_memory.recall(\"last_login\")\n\n# Full key is \"user:123:last_login\"\nstate.memory.recall(\"user:123:last_login\")\n</code></pre>"},{"location":"architecture/state-management/#shared-memory","title":"Shared Memory","text":"<p>Use the <code>SHARED</code> namespace for cross-robot data:</p> <pre><code># In first robot\nstate.memory.remember(\"SHARED:context\", important_data)\n\n# In second robot (same or different network run)\ndata = state.memory.recall(\"SHARED:context\")\n</code></pre>"},{"location":"architecture/state-management/#memory-operations","title":"Memory Operations","text":"<pre><code># Search by pattern\nmatches = state.memory.search(\"user:*\")\n\n# Get statistics\nstate.memory.stats\n# =&gt; { total_keys: 15, namespaces: [\"user\", \"session\"] }\n\n# Clear namespace\nstate.memory.scoped(\"temp\").clear\n\n# Clear everything\nstate.memory.clear_all\n</code></pre>"},{"location":"architecture/state-management/#results","title":"Results","text":"<p>Results track the history of robot executions:</p> <pre><code># Append a result\nstate.append_result(robot_result)\n\n# Get all results\nstate.results\n\n# Get results from index\nstate.results_from(5)  # Results starting at index 5\n\n# Format for LLM conversation\nstate.format_history\n</code></pre>"},{"location":"architecture/state-management/#result-history","title":"Result History","text":"<p>Each <code>RobotResult</code> contains:</p> <pre><code>result.robot_name   # Which robot produced this\nresult.output       # Array&lt;Message&gt; - response content\nresult.tool_calls   # Array&lt;ToolMessage&gt; - tools called\nresult.stop_reason  # \"stop\", \"tool\", etc.\nresult.created_at   # When it was created\n</code></pre>"},{"location":"architecture/state-management/#messages","title":"Messages","text":"<p>The <code>messages</code> method formats state for LLM consumption:</p> <pre><code>messages = state.messages\n\n# Returns Array&lt;Message&gt; with:\n# - System message (if present)\n# - Alternating user/assistant messages\n# - Tool calls and results\n</code></pre>"},{"location":"architecture/state-management/#thread-id","title":"Thread ID","text":"<p>For persistent conversations:</p> <pre><code># Set thread ID\nstate.thread_id = \"thread_123\"\n\n# Or via UserMessage\nmessage = UserMessage.new(\n  \"Continue\",\n  thread_id: \"thread_123\"\n)\nstate = RobotLab.create_state(message: message)\n</code></pre>"},{"location":"architecture/state-management/#state-cloning","title":"State Cloning","text":"<p>Create independent copies:</p> <pre><code>original = RobotLab.create_state(data: { count: 1 })\nclone = original.clone\n\nclone.data[:count] = 2\noriginal.data[:count]  # Still 1\n</code></pre>"},{"location":"architecture/state-management/#serialization","title":"Serialization","text":"<p>Convert state to/from hash:</p> <pre><code># To hash\nhash = state.to_h\njson = state.to_json\n\n# From hash\nstate = State.from_hash(hash)\n</code></pre>"},{"location":"architecture/state-management/#hash-structure","title":"Hash Structure","text":"<pre><code>{\n  data: { ... },\n  results: [\n    {\n      robot_name: \"assistant\",\n      output: [...],\n      tool_calls: [...],\n      stop_reason: \"stop\"\n    }\n  ],\n  thread_id: \"thread_123\"\n}\n</code></pre>"},{"location":"architecture/state-management/#usermessage","title":"UserMessage","text":"<p>Enhanced message with metadata:</p> <pre><code>message = UserMessage.new(\n  \"What's the status of my order?\",\n  thread_id: \"thread_123\",\n  system_prompt: \"Respond in Spanish\",  # Augment system prompt\n  metadata: {\n    user_id: \"user_456\",\n    source: \"web_chat\"\n  }\n)\n\nstate = RobotLab.create_state(message: message)\n</code></pre>"},{"location":"architecture/state-management/#usermessage-properties","title":"UserMessage Properties","text":"Property Description <code>content</code> The message text <code>thread_id</code> Conversation thread ID <code>system_prompt</code> Additional system instructions <code>metadata</code> Custom key-value data <code>id</code> Unique message identifier <code>created_at</code> Timestamp"},{"location":"architecture/state-management/#best-practices","title":"Best Practices","text":""},{"location":"architecture/state-management/#1-use-memory-for-cross-robot-data","title":"1. Use Memory for Cross-Robot Data","text":"<pre><code># Don't pass data through routing\nrouter = -&gt;(args) {\n  # Bad: parsing previous output for data\n}\n\n# Do: use memory\nstate.memory.remember(\"classification\", \"billing\")\n# Later robot reads it directly\n</code></pre>"},{"location":"architecture/state-management/#2-scope-memory-appropriately","title":"2. Scope Memory Appropriately","text":"<pre><code># Session data\nsession = state.memory.scoped(\"session:#{session_id}\")\n\n# User preferences\nuser = state.memory.scoped(\"user:#{user_id}\")\n\n# Temporary working data\ntemp = state.memory.scoped(\"temp\")\n</code></pre>"},{"location":"architecture/state-management/#3-keep-data-minimal","title":"3. Keep Data Minimal","text":"<pre><code># Don't store large objects\nstate.data[:huge_response] = api_response  # Bad\n\n# Store references instead\nstate.data[:response_id] = response.id  # Good\n</code></pre>"},{"location":"architecture/state-management/#next-steps","title":"Next Steps","text":"<ul> <li>Memory System - Advanced memory patterns</li> <li>History Guide - Persisting state</li> <li>Message Flow - How messages are processed</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Complete working examples demonstrating RobotLab features.</p>"},{"location":"examples/#overview","title":"Overview","text":"<p>These examples show how to use RobotLab for common scenarios, from simple chatbots to complex multi-robot systems.</p>"},{"location":"examples/#examples_1","title":"Examples","text":"Example Description Basic Chat Simple conversational robot Multi-Robot Network Customer service with routing Tool Usage External API integration MCP Server Creating an MCP tool server Rails Application Full Rails integration"},{"location":"examples/#quick-links","title":"Quick Links","text":""},{"location":"examples/#simple-examples","title":"Simple Examples","text":"<ul> <li>Hello World Robot</li> <li>Robot with Tools</li> <li>Network with Routing</li> </ul>"},{"location":"examples/#advanced-examples","title":"Advanced Examples","text":"<ul> <li>Streaming Responses</li> <li>Persistent Conversations</li> <li>MCP Integration</li> </ul>"},{"location":"examples/#hello-world","title":"Hello World","text":"<pre><code>require \"robot_lab\"\n\nRobotLab.configure do |config|\n  config.default_model = \"claude-sonnet-4\"\nend\n\nrobot = RobotLab.build do\n  name \"greeter\"\n  template \"You are a friendly greeter. Say hello warmly.\"\nend\n\nstate = RobotLab.create_state(message: \"Hi there!\")\nresult = robot.run(state: state)\n\nputs result.output.first.content\n</code></pre>"},{"location":"examples/#robot-with-tools","title":"Robot with Tools","text":"<pre><code>robot = RobotLab.build do\n  name \"calculator\"\n  template \"You help with calculations.\"\n\n  tool :calculate do\n    description \"Perform a calculation\"\n    parameter :expression, type: :string, required: true\n    handler { |expression:, **_| eval(expression).to_s }\n  end\nend\n\nstate = RobotLab.create_state(message: \"What's 25 * 4?\")\nresult = robot.run(state: state)\n</code></pre>"},{"location":"examples/#network-with-routing","title":"Network with Routing","text":"<pre><code>classifier = RobotLab.build do\n  name \"classifier\"\n  template \"Classify: BILLING, TECHNICAL, or GENERAL\"\nend\n\nbilling = RobotLab.build do\n  name \"billing\"\n  template \"You handle billing questions.\"\nend\n\ntech = RobotLab.build do\n  name \"tech\"\n  template \"You handle technical issues.\"\nend\n\nnetwork = RobotLab.create_network do\n  name \"support\"\n  add_robot classifier\n  add_robot billing\n  add_robot tech\n\n  router -&gt;(args) {\n    case args.call_count\n    when 0 then :classifier\n    when 1\n      category = args.last_result&amp;.output&amp;.first&amp;.content&amp;.strip\n      category == \"BILLING\" ? :billing : :tech\n    end\n  }\nend\n\nresult = network.run(state: state)\n</code></pre>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<ol> <li> <p>Install dependencies:    <pre><code>bundle install\n</code></pre></p> </li> <li> <p>Set API key:    <pre><code>export ANTHROPIC_API_KEY=\"your-key\"\n</code></pre></p> </li> <li> <p>Run example:    <pre><code>ruby examples/basic_chat.rb\n</code></pre></p> </li> </ol>"},{"location":"examples/#see-also","title":"See Also","text":"<ul> <li>Getting Started</li> <li>Guides</li> <li>API Reference</li> </ul>"},{"location":"examples/basic-chat/","title":"Basic Chat","text":"<p>A simple conversational robot example.</p>"},{"location":"examples/basic-chat/#overview","title":"Overview","text":"<p>This example demonstrates the minimal setup for a conversational robot that can respond to user messages.</p>"},{"location":"examples/basic-chat/#complete-example","title":"Complete Example","text":"<pre><code>#!/usr/bin/env ruby\n# examples/basic_chat.rb\n\nrequire \"bundler/setup\"\nrequire \"robot_lab\"\n\n# Configure RobotLab\nRobotLab.configure do |config|\n  config.default_model = \"claude-sonnet-4\"\nend\n\n# Build a simple assistant\nassistant = RobotLab.build do\n  name \"assistant\"\n  description \"A helpful conversational assistant\"\n\n  template &lt;&lt;~PROMPT\n    You are a helpful, friendly assistant. You provide clear,\n    concise answers to questions. Be conversational but informative.\n  PROMPT\nend\n\n# Simple REPL\nputs \"Chat with the assistant (type 'quit' to exit)\"\nputs \"-\" * 50\n\nloop do\n  print \"\\nYou: \"\n  input = gets&amp;.chomp\n\n  break if input.nil? || input.downcase == \"quit\"\n  next if input.empty?\n\n  # Create state and run\n  state = RobotLab.create_state(message: input)\n  result = assistant.run(state: state)\n\n  # Display response\n  response = result.output.first&amp;.content || \"No response\"\n  puts \"\\nAssistant: #{response}\"\nend\n\nputs \"\\nGoodbye!\"\n</code></pre>"},{"location":"examples/basic-chat/#with-streaming","title":"With Streaming","text":"<pre><code>#!/usr/bin/env ruby\n# examples/streaming_chat.rb\n\nrequire \"bundler/setup\"\nrequire \"robot_lab\"\n\nRobotLab.configure do |config|\n  config.default_model = \"claude-sonnet-4\"\nend\n\nassistant = RobotLab.build do\n  name \"assistant\"\n  template \"You are a helpful assistant.\"\nend\n\nputs \"Chat with streaming (type 'quit' to exit)\"\nputs \"-\" * 50\n\nloop do\n  print \"\\nYou: \"\n  input = gets&amp;.chomp\n\n  break if input.nil? || input.downcase == \"quit\"\n  next if input.empty?\n\n  state = RobotLab.create_state(message: input)\n\n  print \"\\nAssistant: \"\n  assistant.run(state: state) do |event|\n    print event.text if event.type == :text_delta\n  end\n  puts\nend\n\nputs \"\\nGoodbye!\"\n</code></pre>"},{"location":"examples/basic-chat/#with-conversation-history","title":"With Conversation History","text":"<pre><code>#!/usr/bin/env ruby\n# examples/chat_with_memory.rb\n\nrequire \"bundler/setup\"\nrequire \"robot_lab\"\n\nRobotLab.configure do |config|\n  config.default_model = \"claude-sonnet-4\"\nend\n\nassistant = RobotLab.build do\n  name \"assistant\"\n  template \"You are a helpful assistant with memory of our conversation.\"\nend\n\n# In-memory history store\nHISTORY = {}\n\nhistory_config = RobotLab::History::Config.new(\n  create_thread: -&gt;(state:, **) {\n    id = SecureRandom.uuid\n    HISTORY[id] = []\n    { id: id }\n  },\n  get: -&gt;(thread_id:, **) {\n    HISTORY[thread_id] || []\n  },\n  append_results: -&gt;(thread_id:, new_results:, **) {\n    HISTORY[thread_id].concat(new_results.map(&amp;:to_h))\n  }\n)\n\nnetwork = RobotLab.create_network do\n  name \"chat\"\n  history history_config\n  add_robot assistant\nend\n\nputs \"Chat with memory (type 'quit' to exit)\"\nputs \"-\" * 50\n\nthread_id = nil\n\nloop do\n  print \"\\nYou: \"\n  input = gets&amp;.chomp\n\n  break if input.nil? || input.downcase == \"quit\"\n  next if input.empty?\n\n  message = thread_id ?\n    RobotLab::UserMessage.new(input, thread_id: thread_id) :\n    input\n\n  state = RobotLab.create_state(message: message)\n  result = network.run(state: state)\n\n  thread_id ||= result.state.thread_id\n\n  response = result.last_result&amp;.output&amp;.first&amp;.content || \"No response\"\n  puts \"\\nAssistant: #{response}\"\nend\n\nputs \"\\nGoodbye!\"\n</code></pre>"},{"location":"examples/basic-chat/#running","title":"Running","text":"<pre><code># Set API key\nexport ANTHROPIC_API_KEY=\"your-key\"\n\n# Run basic chat\nruby examples/basic_chat.rb\n\n# Run with streaming\nruby examples/streaming_chat.rb\n\n# Run with memory\nruby examples/chat_with_memory.rb\n</code></pre>"},{"location":"examples/basic-chat/#key-concepts","title":"Key Concepts","text":"<ol> <li>Robot Building: Use <code>RobotLab.build</code> with a template</li> <li>State Creation: Use <code>RobotLab.create_state</code> with a message</li> <li>Execution: Call <code>robot.run(state: state)</code></li> <li>Response: Access via <code>result.output.first.content</code></li> </ol>"},{"location":"examples/basic-chat/#see-also","title":"See Also","text":"<ul> <li>Building Robots Guide</li> <li>Streaming Guide</li> <li>History Guide</li> </ul>"},{"location":"examples/mcp-server/","title":"MCP Server","text":"<p>Creating and using Model Context Protocol servers.</p>"},{"location":"examples/mcp-server/#overview","title":"Overview","text":"<p>This example demonstrates how to create MCP servers to expose tools and how to connect robots to external MCP servers.</p>"},{"location":"examples/mcp-server/#creating-an-mcp-server","title":"Creating an MCP Server","text":"<pre><code>#!/usr/bin/env ruby\n# examples/mcp_server.rb\n\nrequire \"bundler/setup\"\nrequire \"robot_lab\"\nrequire \"json\"\n\n# Create an MCP server with database tools\nserver = RobotLab::MCP::Server.new(\n  name: \"database_tools\",\n  version: \"1.0.0\"\n)\n\n# Mock database\nUSERS = {\n  \"1\" =&gt; { id: \"1\", name: \"Alice\", email: \"alice@example.com\", plan: \"pro\" },\n  \"2\" =&gt; { id: \"2\", name: \"Bob\", email: \"bob@example.com\", plan: \"free\" }\n}\n\nORDERS = {\n  \"ORD001\" =&gt; { id: \"ORD001\", user_id: \"1\", total: 99.99, status: \"shipped\" },\n  \"ORD002\" =&gt; { id: \"ORD002\", user_id: \"1\", total: 49.99, status: \"pending\" },\n  \"ORD003\" =&gt; { id: \"ORD003\", user_id: \"2\", total: 29.99, status: \"delivered\" }\n}\n\n# Add tools to the server\nserver.add_tool(\n  name: \"get_user\",\n  description: \"Get user by ID\",\n  parameters: {\n    user_id: { type: \"string\", required: true, description: \"User ID\" }\n  },\n  handler: -&gt;(user_id:) {\n    user = USERS[user_id]\n    user || { error: \"User not found\" }\n  }\n)\n\nserver.add_tool(\n  name: \"list_users\",\n  description: \"List all users\",\n  parameters: {\n    plan: { type: \"string\", enum: [\"free\", \"pro\"], description: \"Filter by plan\" }\n  },\n  handler: -&gt;(plan: nil) {\n    users = USERS.values\n    users = users.select { |u| u[:plan] == plan } if plan\n    users\n  }\n)\n\nserver.add_tool(\n  name: \"get_orders\",\n  description: \"Get orders for a user\",\n  parameters: {\n    user_id: { type: \"string\", required: true },\n    status: { type: \"string\", enum: [\"pending\", \"shipped\", \"delivered\"] }\n  },\n  handler: -&gt;(user_id:, status: nil) {\n    orders = ORDERS.values.select { |o| o[:user_id] == user_id }\n    orders = orders.select { |o| o[:status] == status } if status\n    orders\n  }\n)\n\nserver.add_tool(\n  name: \"update_order_status\",\n  description: \"Update an order's status\",\n  parameters: {\n    order_id: { type: \"string\", required: true },\n    status: { type: \"string\", required: true, enum: [\"pending\", \"shipped\", \"delivered\"] }\n  },\n  handler: -&gt;(order_id:, status:) {\n    order = ORDERS[order_id]\n    return { error: \"Order not found\" } unless order\n    order[:status] = status\n    { success: true, order: order }\n  }\n)\n\n# Start the server (stdio for local use)\nputs \"Starting MCP server...\"\nserver.start(transport: :stdio)\n</code></pre>"},{"location":"examples/mcp-server/#using-mcp-server-in-robot","title":"Using MCP Server in Robot","text":"<pre><code>#!/usr/bin/env ruby\n# examples/mcp_client.rb\n\nrequire \"bundler/setup\"\nrequire \"robot_lab\"\n\nRobotLab.configure do |config|\n  config.default_model = \"claude-sonnet-4\"\nend\n\n# Robot that uses the MCP server\nadmin_bot = RobotLab.build do\n  name \"admin_assistant\"\n  description \"Helps with administrative tasks\"\n\n  template &lt;&lt;~PROMPT\n    You are an administrative assistant with access to user and order data.\n    Help users look up information and manage orders.\n  PROMPT\n\n  mcp [\n    {\n      name: \"database\",\n      transport: {\n        type: \"stdio\",\n        command: \"ruby\",\n        args: [\"examples/mcp_server.rb\"]\n      }\n    }\n  ]\nend\n\n# Interactive session\nputs \"Admin Assistant (uses MCP server)\"\nputs \"-\" * 50\n\nstate = RobotLab.create_state(message: \"List all pro users and their orders\")\n\nadmin_bot.run(state: state) do |event|\n  case event.type\n  when :text_delta\n    print event.text\n  when :tool_call\n    puts \"\\n[MCP: #{event.name}]\"\n  end\nend\n\nputs\nadmin_bot.disconnect\n</code></pre>"},{"location":"examples/mcp-server/#network-with-mcp","title":"Network with MCP","text":"<pre><code># examples/network_with_mcp.rb\n\nnetwork = RobotLab.create_network do\n  name \"support_with_mcp\"\n\n  # MCP servers available to all robots\n  mcp [\n    {\n      name: \"database\",\n      transport: { type: \"stdio\", command: \"ruby examples/mcp_server.rb\" }\n    },\n    {\n      name: \"filesystem\",\n      transport: {\n        type: \"stdio\",\n        command: \"npx\",\n        args: [\"@modelcontextprotocol/server-filesystem\", \"/data\"]\n      }\n    }\n  ]\n\n  add_robot RobotLab.build {\n    name \"data_analyst\"\n    template \"You analyze user data.\"\n    mcp :inherit  # Uses network's MCP servers\n  }\n\n  add_robot RobotLab.build {\n    name \"file_manager\"\n    template \"You manage files.\"\n    mcp :inherit\n    tools %w[read_file list_directory]  # Only these MCP tools\n  }\nend\n</code></pre>"},{"location":"examples/mcp-server/#http-mcp-server","title":"HTTP MCP Server","text":"<pre><code>#!/usr/bin/env ruby\n# examples/http_mcp_server.rb\n\nrequire \"robot_lab\"\nrequire \"sinatra\"\n\nserver = RobotLab::MCP::Server.new(name: \"api_tools\")\n\nserver.add_tool(\n  name: \"get_stats\",\n  description: \"Get system statistics\",\n  parameters: {},\n  handler: -&gt; {\n    {\n      uptime: `uptime`.strip,\n      memory: `free -m 2&gt;/dev/null || vm_stat`.strip,\n      time: Time.now.iso8601\n    }\n  }\n)\n\n# Sinatra endpoint for MCP\npost \"/mcp\" do\n  content_type :json\n  request_body = JSON.parse(request.body.read)\n  response = server.handle_request(request_body)\n  response.to_json\nend\n\n# Run: ruby examples/http_mcp_server.rb\n# Connect with HTTP transport\n</code></pre>"},{"location":"examples/mcp-server/#connecting-to-http-server","title":"Connecting to HTTP Server","text":"<pre><code>robot = RobotLab.build do\n  name \"remote_assistant\"\n  template \"You have access to remote tools.\"\n\n  mcp [\n    {\n      name: \"remote\",\n      transport: {\n        type: \"http\",\n        url: \"https://mcp.example.com/mcp\",\n        headers: { \"Authorization\" =&gt; \"Bearer #{ENV['MCP_TOKEN']}\" }\n      }\n    }\n  ]\nend\n</code></pre>"},{"location":"examples/mcp-server/#websocket-server","title":"WebSocket Server","text":"<pre><code>#!/usr/bin/env ruby\n# examples/websocket_mcp_server.rb\n\nrequire \"robot_lab\"\n\nserver = RobotLab::MCP::Server.new(name: \"realtime_tools\")\n\nserver.add_tool(\n  name: \"subscribe_events\",\n  description: \"Subscribe to real-time events\",\n  parameters: { channel: { type: \"string\", required: true } },\n  handler: -&gt;(channel:) { { subscribed: channel } }\n)\n\n# Start WebSocket server\nserver.start(transport: :websocket, port: 8765)\n</code></pre>"},{"location":"examples/mcp-server/#running","title":"Running","text":"<pre><code># Start MCP server in one terminal\nruby examples/mcp_server.rb\n\n# Run client in another terminal\nexport ANTHROPIC_API_KEY=\"your-key\"\nruby examples/mcp_client.rb\n</code></pre>"},{"location":"examples/mcp-server/#key-concepts","title":"Key Concepts","text":"<ol> <li>Server Creation: Use <code>RobotLab::MCP::Server.new</code></li> <li>Tool Registration: Add tools with <code>server.add_tool</code></li> <li>Transport: Choose stdio, http, websocket, or sse</li> <li>Client Connection: Configure in robot's <code>mcp</code> block</li> <li>Tool Filtering: Use <code>tools</code> whitelist for security</li> </ol>"},{"location":"examples/mcp-server/#see-also","title":"See Also","text":"<ul> <li>MCP Integration Guide</li> <li>MCP API Reference</li> <li>Transports</li> </ul>"},{"location":"examples/multi-robot-network/","title":"Multi-Robot Network","text":"<p>Customer service system with intelligent routing using SimpleFlow pipelines.</p>"},{"location":"examples/multi-robot-network/#overview","title":"Overview","text":"<p>This example demonstrates a multi-robot network where a classifier routes customer inquiries to specialized support robots using optional task activation.</p>"},{"location":"examples/multi-robot-network/#complete-example","title":"Complete Example","text":"<pre><code>#!/usr/bin/env ruby\n# examples/customer_service.rb\n\nrequire \"bundler/setup\"\nrequire \"robot_lab\"\n\nRobotLab.configure do |config|\n  config.default_model = \"claude-sonnet-4\"\nend\n\n# Custom classifier that routes to specialists\nclass ClassifierRobot &lt; RobotLab::Robot\n  def call(result)\n    robot_result = run(**extract_run_context(result))\n\n    new_result = result\n      .with_context(@name.to_sym, robot_result)\n      .continue(robot_result)\n\n    # Route based on classification\n    category = robot_result.last_text_content.to_s.strip.downcase\n\n    case category\n    when /billing/ then new_result.activate(:billing_agent)\n    when /technical/ then new_result.activate(:tech_agent)\n    when /account/ then new_result.activate(:account_agent)\n    else new_result.activate(:general_agent)\n    end\n  end\nend\n\n# Classifier robot\nclassifier = ClassifierRobot.new(\n  name: \"classifier\",\n  description: \"Classifies customer inquiries\",\n  system_prompt: &lt;&lt;~PROMPT\n    You are a customer inquiry classifier. Analyze the customer's message\n    and respond with exactly ONE of these categories:\n\n    - BILLING (payment issues, invoices, refunds, subscriptions)\n    - TECHNICAL (bugs, errors, how-to questions, feature requests)\n    - ACCOUNT (login issues, profile changes, security concerns)\n    - GENERAL (everything else)\n\n    Respond with ONLY the category name, nothing else.\n  PROMPT\n)\n\n# Billing specialist\nbilling_agent = RobotLab.build(\n  name: \"billing_agent\",\n  description: \"Handles billing inquiries\",\n  system_prompt: &lt;&lt;~PROMPT\n    You are a billing support specialist. You help customers with:\n    - Payment issues and refunds\n    - Invoice questions\n    - Subscription management\n    - Pricing inquiries\n\n    Be helpful, empathetic, and provide clear next steps.\n  PROMPT\n)\n\n# Technical support\ntech_agent = RobotLab.build(\n  name: \"tech_agent\",\n  description: \"Handles technical issues\",\n  system_prompt: &lt;&lt;~PROMPT\n    You are a technical support specialist. You help customers with:\n    - Bug reports and troubleshooting\n    - Feature explanations\n    - Integration questions\n    - Best practices\n\n    Ask clarifying questions when needed. Provide step-by-step solutions.\n  PROMPT\n)\n\n# Account specialist\naccount_agent = RobotLab.build(\n  name: \"account_agent\",\n  description: \"Handles account issues\",\n  system_prompt: &lt;&lt;~PROMPT\n    You are an account support specialist. You help customers with:\n    - Login and authentication issues\n    - Profile and settings changes\n    - Security concerns\n    - Account recovery\n\n    Prioritize security while being helpful.\n  PROMPT\n)\n\n# General support\ngeneral_agent = RobotLab.build(\n  name: \"general_agent\",\n  description: \"Handles general inquiries\",\n  system_prompt: &lt;&lt;~PROMPT\n    You are a general support agent. You help customers with:\n    - Product information\n    - General questions\n    - Feedback collection\n    - Routing to appropriate departments\n\n    Be friendly and informative.\n  PROMPT\n)\n\n# Create the network with optional task routing\nnetwork = RobotLab.create_network(name: \"customer_service\") do\n  task :classifier, classifier, depends_on: :none\n  task :billing_agent, billing_agent, depends_on: :optional\n  task :tech_agent, tech_agent, depends_on: :optional\n  task :account_agent, account_agent, depends_on: :optional\n  task :general_agent, general_agent, depends_on: :optional\nend\n\n# Run the support system\nputs \"Customer Service System\"\nputs \"=\" * 50\nputs\n\ntest_inquiries = [\n  \"I was charged twice for my subscription last month\",\n  \"How do I reset my password?\",\n  \"The app crashes when I try to upload photos\",\n  \"What features are included in the pro plan?\"\n]\n\ntest_inquiries.each do |inquiry|\n  puts \"Customer: #{inquiry}\"\n  puts \"-\" * 50\n\n  result = network.run(message: inquiry)\n\n  # Show classification\n  if result.context[:classifier]\n    puts \"Classification: #{result.context[:classifier].last_text_content}\"\n  end\n\n  # Show specialist response\n  if result.value.is_a?(RobotLab::RobotResult)\n    puts \"Handled by: #{result.value.robot_name}\"\n    puts \"Response: #{result.value.last_text_content[0..200]}...\"\n  end\n\n  puts\n  puts \"=\" * 50\n  puts\nend\n</code></pre>"},{"location":"examples/multi-robot-network/#with-context-passing","title":"With Context Passing","text":"<pre><code># Enhanced version with additional context\n\nclass ContextAwareClassifier &lt; RobotLab::Robot\n  def call(result)\n    robot_result = run(**extract_run_context(result))\n\n    # Store classification in context for specialist\n    new_result = result\n      .with_context(@name.to_sym, robot_result)\n      .with_context(:classification, robot_result.last_text_content.strip)\n      .with_context(:original_message, result.context[:run_params][:message])\n      .continue(robot_result)\n\n    category = robot_result.last_text_content.to_s.downcase\n    case category\n    when /billing/ then new_result.activate(:billing_agent)\n    when /technical/ then new_result.activate(:tech_agent)\n    else new_result.activate(:general_agent)\n    end\n  end\nend\n\n# Specialist can access shared context\nclass BillingAgent &lt; RobotLab::Robot\n  def call(result)\n    # Access context from classifier\n    classification = result.context[:classification]\n    original_message = result.context[:original_message]\n\n    robot_result = run(\n      **extract_run_context(result),\n      classification: classification,\n      customer_message: original_message\n    )\n\n    result.with_context(@name.to_sym, robot_result).continue(robot_result)\n  end\nend\n</code></pre>"},{"location":"examples/multi-robot-network/#per-task-configuration","title":"Per-Task Configuration","text":"<pre><code># Tasks with individual context and tools\nnetwork = RobotLab.create_network(name: \"support\") do\n  task :classifier, classifier, depends_on: :none\n  task :billing_agent, billing_agent,\n       context: { department: \"billing\", escalation_level: 2 },\n       tools: [RefundTool, InvoiceTool],\n       depends_on: :optional\n  task :tech_agent, tech_agent,\n       context: { department: \"technical\" },\n       mcp: [FilesystemServer],\n       depends_on: :optional\nend\n</code></pre>"},{"location":"examples/multi-robot-network/#pipeline-pattern","title":"Pipeline Pattern","text":"<pre><code># Sequential processing pipeline\nnetwork = RobotLab.create_network(name: \"document_processor\") do\n  task :extract, extractor, depends_on: :none\n  task :analyze, analyzer, depends_on: [:extract]\n  task :format, formatter, depends_on: [:analyze]\nend\n\nresult = network.run(message: \"Process this document\")\nputs result.value.last_text_content\n</code></pre>"},{"location":"examples/multi-robot-network/#parallel-analysis-pattern","title":"Parallel Analysis Pattern","text":"<pre><code># Fan-out / fan-in pattern\nnetwork = RobotLab.create_network(name: \"multi_analysis\", concurrency: :threads) do\n  task :prepare, preparer, depends_on: :none\n\n  # These run in parallel\n  task :sentiment, sentiment_analyzer, depends_on: [:prepare]\n  task :entities, entity_extractor, depends_on: [:prepare]\n  task :keywords, keyword_extractor, depends_on: [:prepare]\n\n  # Waits for all three\n  task :summarize, summarizer, depends_on: [:sentiment, :entities, :keywords]\nend\n\nresult = network.run(message: \"Analyze this text\")\n\n# Access parallel results\nputs \"Sentiment: #{result.context[:sentiment].last_text_content}\"\nputs \"Entities: #{result.context[:entities].last_text_content}\"\nputs \"Keywords: #{result.context[:keywords].last_text_content}\"\nputs \"Summary: #{result.value.last_text_content}\"\n</code></pre>"},{"location":"examples/multi-robot-network/#conditional-halting","title":"Conditional Halting","text":"<pre><code>class ValidatorRobot &lt; RobotLab::Robot\n  def call(result)\n    robot_result = run(**extract_run_context(result))\n\n    if robot_result.last_text_content.include?(\"INVALID\")\n      # Halt the pipeline early\n      result.halt(robot_result)\n    else\n      result.with_context(@name.to_sym, robot_result).continue(robot_result)\n    end\n  end\nend\n\nnetwork = RobotLab.create_network(name: \"validated_pipeline\") do\n  task :validate, validator, depends_on: :none\n  task :process, processor, depends_on: [:validate]  # Only runs if not halted\nend\n\nresult = network.run(message: \"Process this\")\nif result.halted?\n  puts \"Validation failed: #{result.value.last_text_content}\"\nelse\n  puts \"Processing complete: #{result.value.last_text_content}\"\nend\n</code></pre>"},{"location":"examples/multi-robot-network/#running","title":"Running","text":"<pre><code>export ANTHROPIC_API_KEY=\"your-key\"\nruby examples/customer_service.rb\n</code></pre>"},{"location":"examples/multi-robot-network/#key-concepts","title":"Key Concepts","text":"<ol> <li>SimpleFlow Pipeline: DAG-based execution with dependency management</li> <li>Optional Tasks: Activated dynamically based on classification</li> <li>Robot#call: Custom routing logic in classifier robots</li> <li>Context Flow: Data passed through <code>result.context</code></li> <li>Parallel Execution: Tasks with same dependencies run concurrently</li> <li>Per-Task Configuration: Each task can have its own context, tools, and MCP servers</li> </ol>"},{"location":"examples/multi-robot-network/#see-also","title":"See Also","text":"<ul> <li>Creating Networks Guide</li> <li>Network Orchestration</li> <li>API Reference: Network</li> </ul>"},{"location":"examples/rails-application/","title":"Rails Application","text":"<p>Full Rails integration with Action Cable and background jobs.</p>"},{"location":"examples/rails-application/#overview","title":"Overview","text":"<p>This example demonstrates integrating RobotLab into a Rails application with real-time streaming via Action Cable, background job processing, and persistent conversation history.</p>"},{"location":"examples/rails-application/#setup","title":"Setup","text":""},{"location":"examples/rails-application/#1-add-to-gemfile","title":"1. Add to Gemfile","text":"<pre><code># Gemfile\ngem \"robot_lab\"\n</code></pre>"},{"location":"examples/rails-application/#2-run-generator","title":"2. Run Generator","text":"<pre><code>rails generate robot_lab:install\n</code></pre> <p>This creates:</p> <ul> <li><code>config/initializers/robot_lab.rb</code></li> <li><code>app/robots/</code> directory</li> <li>Database migrations for history</li> </ul>"},{"location":"examples/rails-application/#3-run-migrations","title":"3. Run Migrations","text":"<pre><code>rails db:migrate\n</code></pre>"},{"location":"examples/rails-application/#configuration","title":"Configuration","text":"<pre><code># config/initializers/robot_lab.rb\n\nRobotLab.configure do |config|\n  config.default_model = ENV.fetch(\"LLM_MODEL\", \"claude-sonnet-4\")\n\n  # Enable logging in development\n  config.logger = Rails.logger if Rails.env.development?\nend\n</code></pre>"},{"location":"examples/rails-application/#models","title":"Models","text":"<pre><code># app/models/conversation_thread.rb\nclass ConversationThread &lt; ApplicationRecord\n  belongs_to :user\n  has_many :messages, class_name: \"ConversationMessage\", dependent: :destroy\n\n  validates :external_id, presence: true, uniqueness: true\n\n  def self.find_or_create_for(user:, external_id: nil)\n    external_id ||= SecureRandom.uuid\n    find_or_create_by!(user: user, external_id: external_id)\n  end\nend\n\n# app/models/conversation_message.rb\nclass ConversationMessage &lt; ApplicationRecord\n  belongs_to :thread, class_name: \"ConversationThread\"\n\n  validates :role, presence: true\n  validates :content, presence: true\n\n  scope :ordered, -&gt; { order(:position) }\n\n  def to_robot_result\n    RobotLab::RobotResult.from_hash(\n      robot_name: robot_name,\n      input: input,\n      output: output\n    )\n  end\nend\n</code></pre>"},{"location":"examples/rails-application/#robot-definitions","title":"Robot Definitions","text":"<pre><code># app/robots/support_robot.rb\nclass SupportRobot\n  def self.build\n    RobotLab.build do\n      name \"support\"\n      description \"Customer support assistant\"\n\n      template &lt;&lt;~PROMPT\n        You are a helpful customer support assistant for our company.\n        Be friendly, professional, and thorough in your responses.\n        If you need to look up information, use the available tools.\n      PROMPT\n\n      tool :get_user_info do\n        description \"Get information about the current user\"\n\n        handler do |state:, **_|\n          user_id = state.data[:user_id]\n          user = User.find(user_id)\n\n          {\n            name: user.name,\n            email: user.email,\n            plan: user.subscription&amp;.plan || \"free\",\n            member_since: user.created_at.to_date.to_s\n          }\n        rescue ActiveRecord::RecordNotFound\n          { error: \"User not found\" }\n        end\n      end\n\n      tool :get_orders do\n        description \"Get user's recent orders\"\n        parameter :limit, type: :integer, default: 5\n\n        handler do |limit:, state:, **_|\n          user_id = state.data[:user_id]\n          orders = Order.where(user_id: user_id)\n                       .order(created_at: :desc)\n                       .limit(limit)\n\n          orders.map do |order|\n            {\n              id: order.external_id,\n              status: order.status,\n              total: order.total.to_f,\n              created_at: order.created_at.iso8601\n            }\n          end\n        end\n      end\n\n      tool :create_ticket do\n        description \"Create a support ticket\"\n        parameter :subject, type: :string, required: true\n        parameter :description, type: :string, required: true\n        parameter :priority, type: :string, enum: %w[low medium high], default: \"medium\"\n\n        handler do |subject:, description:, priority:, state:, **_|\n          ticket = SupportTicket.create!(\n            user_id: state.data[:user_id],\n            subject: subject,\n            description: description,\n            priority: priority\n          )\n\n          {\n            success: true,\n            ticket_id: ticket.external_id,\n            message: \"Ticket created successfully\"\n          }\n        rescue =&gt; e\n          { success: false, error: e.message }\n        end\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"examples/rails-application/#network-configuration","title":"Network Configuration","text":"<pre><code># app/robots/support_network.rb\nclass SupportNetwork\n  def self.build\n    RobotLab.create_network do\n      name \"support_network\"\n      default_model \"claude-sonnet-4\"\n\n      history RobotLab::History::ActiveRecordAdapter.new(\n        thread_model: ConversationThread,\n        result_model: ConversationMessage\n      ).to_config\n\n      add_robot SupportRobot.build\n    end\n  end\nend\n</code></pre>"},{"location":"examples/rails-application/#service-object","title":"Service Object","text":"<pre><code># app/services/chat_service.rb\nclass ChatService\n  def initialize(user:, thread_id: nil)\n    @user = user\n    @thread_id = thread_id\n    @network = SupportNetwork.build\n  end\n\n  def call(message:, &amp;streaming_callback)\n    user_message = build_message(message)\n    state = build_state(user_message)\n\n    result = @network.run(state: state, user_id: @user.id) do |event|\n      streaming_callback&amp;.call(event)\n    end\n\n    {\n      thread_id: result.state.thread_id,\n      response: extract_response(result),\n      messages: result.new_results\n    }\n  end\n\n  private\n\n  def build_message(content)\n    if @thread_id\n      RobotLab::UserMessage.new(content, thread_id: @thread_id)\n    else\n      content\n    end\n  end\n\n  def build_state(message)\n    RobotLab.create_state(\n      message: message,\n      data: { user_id: @user.id }\n    )\n  end\n\n  def extract_response(result)\n    result.last_result&amp;.output&amp;.find { |m| m.is_a?(RobotLab::TextMessage) }&amp;.content\n  end\nend\n</code></pre>"},{"location":"examples/rails-application/#controller","title":"Controller","text":"<pre><code># app/controllers/api/chats_controller.rb\nmodule Api\n  class ChatsController &lt; ApplicationController\n    before_action :authenticate_user!\n\n    def create\n      service = ChatService.new(\n        user: current_user,\n        thread_id: params[:thread_id]\n      )\n\n      result = service.call(message: params[:message])\n\n      render json: {\n        thread_id: result[:thread_id],\n        response: result[:response]\n      }\n    end\n  end\nend\n</code></pre>"},{"location":"examples/rails-application/#action-cable-integration","title":"Action Cable Integration","text":"<pre><code># app/channels/chat_channel.rb\nclass ChatChannel &lt; ApplicationCable::Channel\n  def subscribed\n    stream_for current_user\n  end\n\n  def receive(data)\n    ChatJob.perform_later(\n      user_id: current_user.id,\n      thread_id: data[\"thread_id\"],\n      message: data[\"message\"]\n    )\n  end\nend\n\n# app/jobs/chat_job.rb\nclass ChatJob &lt; ApplicationJob\n  queue_as :default\n\n  def perform(user_id:, thread_id:, message:)\n    user = User.find(user_id)\n\n    service = ChatService.new(user: user, thread_id: thread_id)\n\n    service.call(message: message) do |event|\n      case event.type\n      when :text_delta\n        broadcast_to_user(user, type: \"text\", content: event.text)\n      when :tool_call\n        broadcast_to_user(user, type: \"tool\", name: event.name)\n      when :complete\n        broadcast_to_user(user, type: \"complete\")\n      end\n    end\n  end\n\n  private\n\n  def broadcast_to_user(user, data)\n    ChatChannel.broadcast_to(user, data)\n  end\nend\n</code></pre>"},{"location":"examples/rails-application/#frontend-stimulus","title":"Frontend (Stimulus)","text":"<pre><code>// app/javascript/controllers/chat_controller.js\nimport { Controller } from \"@hotwired/stimulus\"\nimport { createConsumer } from \"@rails/actioncable\"\n\nexport default class extends Controller {\n  static targets = [\"messages\", \"input\", \"response\"]\n\n  connect() {\n    this.consumer = createConsumer()\n    this.channel = this.consumer.subscriptions.create(\"ChatChannel\", {\n      received: (data) =&gt; this.handleMessage(data)\n    })\n  }\n\n  disconnect() {\n    this.channel?.unsubscribe()\n  }\n\n  send() {\n    const message = this.inputTarget.value.trim()\n    if (!message) return\n\n    this.appendMessage(\"user\", message)\n    this.inputTarget.value = \"\"\n\n    // Create response container\n    this.currentResponse = document.createElement(\"div\")\n    this.currentResponse.className = \"message assistant\"\n    this.messagesTarget.appendChild(this.currentResponse)\n\n    this.channel.send({\n      message: message,\n      thread_id: this.threadId\n    })\n  }\n\n  handleMessage(data) {\n    switch (data.type) {\n      case \"text\":\n        this.currentResponse.textContent += data.content\n        break\n      case \"tool\":\n        // Show tool indicator\n        break\n      case \"complete\":\n        this.threadId = data.thread_id\n        break\n    }\n  }\n\n  appendMessage(role, content) {\n    const div = document.createElement(\"div\")\n    div.className = `message ${role}`\n    div.textContent = content\n    this.messagesTarget.appendChild(div)\n  }\n}\n</code></pre>"},{"location":"examples/rails-application/#view","title":"View","text":"<pre><code>&lt;!-- app/views/chats/show.html.erb --&gt;\n&lt;div data-controller=\"chat\"&gt;\n  &lt;div class=\"messages\" data-chat-target=\"messages\"&gt;\n    &lt;!-- Messages appear here --&gt;\n  &lt;/div&gt;\n\n  &lt;form data-action=\"submit-&gt;chat#send\"&gt;\n    &lt;input type=\"text\"\n           data-chat-target=\"input\"\n           placeholder=\"Type a message...\"\n           autocomplete=\"off\"&gt;\n    &lt;button type=\"submit\"&gt;Send&lt;/button&gt;\n  &lt;/form&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/rails-application/#running","title":"Running","text":"<pre><code># Install dependencies\nbundle install\nyarn install\n\n# Setup database\nrails db:migrate\n\n# Set API key\nexport ANTHROPIC_API_KEY=\"your-key\"\n\n# Start server\nbin/dev\n</code></pre>"},{"location":"examples/rails-application/#key-concepts","title":"Key Concepts","text":"<ol> <li>Robot Classes: Encapsulate robot definitions</li> <li>Network Classes: Configure multi-robot networks</li> <li>Service Objects: Handle business logic</li> <li>Action Cable: Real-time streaming to browser</li> <li>Background Jobs: Non-blocking processing</li> <li>History Persistence: ActiveRecord integration</li> </ol>"},{"location":"examples/rails-application/#see-also","title":"See Also","text":"<ul> <li>Rails Integration Guide</li> <li>Streaming Guide</li> <li>History Guide</li> </ul>"},{"location":"examples/tool-usage/","title":"Tool Usage","text":"<p>Robots with external API integration.</p>"},{"location":"examples/tool-usage/#overview","title":"Overview","text":"<p>This example demonstrates how to give robots access to external systems through tools, including API calls, database queries, and calculations.</p>"},{"location":"examples/tool-usage/#complete-example","title":"Complete Example","text":"<pre><code>#!/usr/bin/env ruby\n# examples/weather_assistant.rb\n\nrequire \"bundler/setup\"\nrequire \"robot_lab\"\nrequire \"http\"\nrequire \"json\"\n\nRobotLab.configure do |config|\n  config.default_model = \"claude-sonnet-4\"\nend\n\n# Weather assistant with API integration\nweather_bot = RobotLab.build do\n  name \"weather_assistant\"\n  description \"Provides weather information\"\n\n  template &lt;&lt;~PROMPT\n    You are a helpful weather assistant. You can look up current weather\n    conditions for any city. When users ask about weather, use the\n    get_weather tool to fetch real data.\n\n    Always provide temperatures in both Fahrenheit and Celsius.\n    Include relevant advice based on conditions (umbrella, sunscreen, etc).\n  PROMPT\n\n  tool :get_weather do\n    description \"Get current weather for a city\"\n\n    parameter :city, type: :string, required: true,\n              description: \"City name (e.g., 'New York', 'London')\"\n\n    handler do |city:, **_|\n      # Using wttr.in API (free, no key required)\n      response = HTTP.get(\"https://wttr.in/#{URI.encode_www_form_component(city)}?format=j1\")\n\n      if response.status.success?\n        data = JSON.parse(response.body)\n        current = data[\"current_condition\"].first\n\n        {\n          city: city,\n          temperature_f: current[\"temp_F\"],\n          temperature_c: current[\"temp_C\"],\n          condition: current[\"weatherDesc\"].first[\"value\"],\n          humidity: current[\"humidity\"],\n          wind_mph: current[\"windspeedMiles\"],\n          feels_like_f: current[\"FeelsLikeF\"],\n          uv_index: current[\"uvIndex\"]\n        }\n      else\n        { error: \"Could not fetch weather for #{city}\" }\n      end\n    rescue HTTP::Error =&gt; e\n      { error: \"Network error: #{e.message}\" }\n    end\n  end\n\n  tool :get_forecast do\n    description \"Get weather forecast for upcoming days\"\n\n    parameter :city, type: :string, required: true\n    parameter :days, type: :integer, default: 3\n\n    handler do |city:, days: 3, **_|\n      response = HTTP.get(\"https://wttr.in/#{URI.encode_www_form_component(city)}?format=j1\")\n\n      if response.status.success?\n        data = JSON.parse(response.body)\n\n        data[\"weather\"].take(days).map do |day|\n          {\n            date: day[\"date\"],\n            high_f: day[\"maxtempF\"],\n            low_f: day[\"mintempF\"],\n            condition: day[\"hourly\"].first[\"weatherDesc\"].first[\"value\"]\n          }\n        end\n      else\n        { error: \"Could not fetch forecast\" }\n      end\n    rescue HTTP::Error =&gt; e\n      { error: \"Network error: #{e.message}\" }\n    end\n  end\nend\n\n# Run interactive session\nputs \"Weather Assistant (type 'quit' to exit)\"\nputs \"-\" * 50\n\nloop do\n  print \"\\nYou: \"\n  input = gets&amp;.chomp\n\n  break if input.nil? || input.downcase == \"quit\"\n  next if input.empty?\n\n  state = RobotLab.create_state(message: input)\n\n  print \"\\nAssistant: \"\n  weather_bot.run(state: state) do |event|\n    case event.type\n    when :text_delta\n      print event.text\n    when :tool_call\n      puts \"\\n[Checking weather for #{event.input[:city]}...]\"\n    end\n  end\n  puts\nend\n\nputs \"\\nGoodbye!\"\n</code></pre>"},{"location":"examples/tool-usage/#database-integration","title":"Database Integration","text":"<pre><code># examples/order_assistant.rb\n\nrequire \"robot_lab\"\n\n# Mock database\nORDERS = {\n  \"ORD001\" =&gt; { id: \"ORD001\", status: \"shipped\", items: [\"Widget\"], total: 29.99 },\n  \"ORD002\" =&gt; { id: \"ORD002\", status: \"processing\", items: [\"Gadget\", \"Gizmo\"], total: 89.99 }\n}\n\norder_bot = RobotLab.build do\n  name \"order_assistant\"\n  template \"You help customers check their orders.\"\n\n  tool :get_order do\n    description \"Look up an order by ID\"\n    parameter :order_id, type: :string, required: true\n\n    handler do |order_id:, state:, **_|\n      # Verify user owns this order\n      user_id = state.data[:user_id]\n      order = ORDERS[order_id.upcase]\n\n      if order\n        order\n      else\n        { error: \"Order not found\" }\n      end\n    end\n  end\n\n  tool :list_orders do\n    description \"List user's recent orders\"\n    parameter :limit, type: :integer, default: 5\n\n    handler do |limit:, state:, **_|\n      user_id = state.data[:user_id]\n      # Filter by user in real implementation\n      ORDERS.values.take(limit)\n    end\n  end\n\n  tool :cancel_order do\n    description \"Cancel an order\"\n    parameter :order_id, type: :string, required: true\n    parameter :reason, type: :string\n\n    handler do |order_id:, reason: nil, state:, **_|\n      order = ORDERS[order_id.upcase]\n\n      if order.nil?\n        { success: false, error: \"Order not found\" }\n      elsif order[:status] == \"shipped\"\n        { success: false, error: \"Cannot cancel shipped orders\" }\n      else\n        order[:status] = \"cancelled\"\n        order[:cancel_reason] = reason\n        { success: true, message: \"Order #{order_id} cancelled\" }\n      end\n    end\n  end\nend\n\n# Run with user context\nstate = RobotLab.create_state(\n  message: \"What's the status of order ORD001?\",\n  data: { user_id: \"user_123\" }\n)\n\nresult = order_bot.run(state: state)\nputs result.output.first.content\n</code></pre>"},{"location":"examples/tool-usage/#calculator-tool","title":"Calculator Tool","text":"<pre><code># examples/math_assistant.rb\n\nrequire \"robot_lab\"\nrequire \"dentaku\"\n\ncalculator = Dentaku::Calculator.new\n\nmath_bot = RobotLab.build do\n  name \"math_assistant\"\n  template \"You help with mathematical calculations.\"\n\n  tool :calculate do\n    description \"Evaluate a mathematical expression\"\n    parameter :expression, type: :string, required: true,\n              description: \"Math expression like '2 + 2' or 'sqrt(16)'\"\n\n    handler do |expression:, **_|\n      result = calculator.evaluate(expression)\n      { expression: expression, result: result }\n    rescue =&gt; e\n      { error: \"Invalid expression: #{e.message}\" }\n    end\n  end\n\n  tool :solve_equation do\n    description \"Solve for a variable\"\n    parameter :equation, type: :string, required: true\n    parameter :variable, type: :string, required: true\n\n    handler do |equation:, variable:, **_|\n      result = calculator.solve(equation, variable.to_sym)\n      { equation: equation, variable: variable, solutions: result }\n    rescue =&gt; e\n      { error: \"Could not solve: #{e.message}\" }\n    end\n  end\nend\n</code></pre>"},{"location":"examples/tool-usage/#multi-tool-example","title":"Multi-Tool Example","text":"<pre><code># examples/research_assistant.rb\n\nresearch_bot = RobotLab.build do\n  name \"research_assistant\"\n  template \"You help with research tasks.\"\n\n  tool :web_search do\n    description \"Search the web\"\n    parameter :query, type: :string, required: true\n    handler { |query:, **_| SearchAPI.search(query) }\n  end\n\n  tool :read_url do\n    description \"Read content from a URL\"\n    parameter :url, type: :string, required: true\n    handler { |url:, **_| HTTP.get(url).body.to_s }\n  end\n\n  tool :summarize do\n    description \"Summarize text\"\n    parameter :text, type: :string, required: true\n    parameter :length, type: :string, enum: %w[short medium long], default: \"medium\"\n    handler { |text:, length:, **_| Summarizer.summarize(text, length) }\n  end\n\n  tool :save_note do\n    description \"Save a research note\"\n    parameter :title, type: :string, required: true\n    parameter :content, type: :string, required: true\n    handler do |title:, content:, state:, **_|\n      notes = state.memory.recall(\"notes\") || []\n      notes &lt;&lt; { title: title, content: content, created: Time.now }\n      state.memory.remember(\"notes\", notes)\n      { saved: true, total_notes: notes.size }\n    end\n  end\nend\n</code></pre>"},{"location":"examples/tool-usage/#running","title":"Running","text":"<pre><code>export ANTHROPIC_API_KEY=\"your-key\"\n\n# Weather assistant\nruby examples/weather_assistant.rb\n\n# Order lookup\nruby examples/order_assistant.rb\n</code></pre>"},{"location":"examples/tool-usage/#key-concepts","title":"Key Concepts","text":"<ol> <li>Tool Definition: Use the <code>tool</code> DSL with description and parameters</li> <li>Handler: Receives parameters plus state, robot, network context</li> <li>Error Handling: Return error hashes for graceful failures</li> <li>State Access: Tools can read/write state and memory</li> </ol>"},{"location":"examples/tool-usage/#see-also","title":"See Also","text":"<ul> <li>Using Tools Guide</li> <li>Tool API</li> <li>Memory Guide</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to RobotLab! This section will help you get up and running quickly.</p>"},{"location":"getting-started/#what-youll-learn","title":"What You'll Learn","text":"<p>In this section, you'll learn how to:</p> <ol> <li>Install RobotLab - Add the gem to your project</li> <li>Configure Your Environment - Set up API keys and defaults</li> <li>Create Your First Robot - Build a simple AI assistant</li> <li>Run a Network - Execute a multi-robot workflow</li> </ol>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Ruby 3.1+ installed</li> <li>An API key from at least one LLM provider:<ul> <li>Anthropic (recommended)</li> <li>OpenAI</li> <li>Google AI</li> </ul> </li> </ul>"},{"location":"getting-started/#quick-links","title":"Quick Links","text":"<ul> <li> <p> Installation</p> <p>Install RobotLab and dependencies</p> </li> <li> <p> Quick Start</p> <p>Build your first robot in 5 minutes</p> </li> <li> <p> Configuration</p> <p>Configure API keys and defaults</p> </li> </ul>"},{"location":"getting-started/#estimated-time","title":"Estimated Time","text":"Guide Time Installation 2 minutes Quick Start 5 minutes Configuration 5 minutes"},{"location":"getting-started/#need-help","title":"Need Help?","text":"<p>If you run into issues:</p> <ul> <li>Check the API Reference for detailed documentation</li> <li>Browse Examples for working code</li> <li>Open an issue on GitHub</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>RobotLab provides flexible configuration options at global, network, and robot levels.</p>"},{"location":"getting-started/configuration/#global-configuration","title":"Global Configuration","text":"<p>Configure RobotLab globally using the <code>configure</code> block:</p> <pre><code>RobotLab.configure do |config|\n  # LLM Provider API Keys\n  config.anthropic_api_key = ENV[\"ANTHROPIC_API_KEY\"]\n  config.openai_api_key = ENV[\"OPENAI_API_KEY\"]\n  config.gemini_api_key = ENV[\"GEMINI_API_KEY\"]\n\n  # Default settings\n  config.default_provider = :anthropic\n  config.default_model = \"claude-sonnet-4\"\n\n  # Execution limits\n  config.max_iterations = 10        # Max robots per network run\n  config.max_tool_iterations = 10   # Max tool calls per robot run\n\n  # Streaming\n  config.streaming_enabled = true\n\n  # Logging\n  config.logger = Logger.new($stdout)\n\n  # Template path for prompt files\n  config.template_path = \"prompts\"\nend\n</code></pre>"},{"location":"getting-started/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"getting-started/configuration/#api-keys","title":"API Keys","text":"Option Description <code>anthropic_api_key</code> Anthropic Claude API key <code>openai_api_key</code> OpenAI API key <code>gemini_api_key</code> Google Gemini API key <code>bedrock_api_key</code> AWS Bedrock API key <code>openrouter_api_key</code> OpenRouter API key"},{"location":"getting-started/configuration/#defaults","title":"Defaults","text":"Option Default Description <code>default_provider</code> <code>:anthropic</code> Default LLM provider <code>default_model</code> <code>\"claude-sonnet-4\"</code> Default model <code>max_iterations</code> <code>10</code> Max robots per network run <code>max_tool_iterations</code> <code>10</code> Max tool calls per robot <code>streaming_enabled</code> <code>true</code> Enable streaming by default"},{"location":"getting-started/configuration/#templates","title":"Templates","text":"Option Default Description <code>template_path</code> <code>\"prompts\"</code> (or <code>\"app/prompts\"</code> in Rails) Directory for prompt templates"},{"location":"getting-started/configuration/#global-mcp-tools","title":"Global MCP &amp; Tools","text":"<pre><code>RobotLab.configure do |config|\n  # Global MCP servers available to all networks\n  config.mcp = [\n    { name: \"github\", transport: { type: \"stdio\", command: \"github-mcp\" } }\n  ]\n\n  # Global tool whitelist\n  config.tools = %w[search_code create_issue]\nend\n</code></pre>"},{"location":"getting-started/configuration/#network-level-configuration","title":"Network-Level Configuration","text":"<p>Override global settings at the network level:</p> <pre><code>network = RobotLab.create_network do\n  name \"my_network\"\n\n  # Override default model for this network\n  default_model \"claude-sonnet-4\"\n\n  # Network-specific MCP servers\n  mcp [\n    { name: \"filesystem\", transport: { type: \"stdio\", command: \"mcp-fs\" } }\n  ]\n\n  # Network-specific tool whitelist\n  tools %w[read_file write_file]\n\n  # Or inherit from global\n  mcp :inherit\n  tools :inherit\nend\n</code></pre>"},{"location":"getting-started/configuration/#robot-level-configuration","title":"Robot-Level Configuration","text":"<p>Configure individual robots:</p> <pre><code>robot = RobotLab.build do\n  name \"specialist\"\n\n  # Robot-specific model\n  model \"claude-sonnet-4\"\n\n  # Robot-specific MCP (overrides network)\n  mcp :inherit  # Use network's MCP servers\n  # or\n  mcp :none     # No MCP servers for this robot\n  # or\n  mcp [...]     # Specific servers\n\n  # Robot-specific tools\n  tools :inherit  # Use network's tools\nend\n</code></pre>"},{"location":"getting-started/configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>Configuration cascades from global to network to robot:</p> <pre><code>Global (RobotLab.configure)\n  \u2514\u2500\u2500 Network (create_network)\n        \u2514\u2500\u2500 Robot (build)\n              \u2514\u2500\u2500 Runtime (robot.run)\n</code></pre> <p>Each level can:</p> <ul> <li><code>:inherit</code> - Use parent level's configuration</li> <li><code>:none</code> or <code>nil</code> or <code>[]</code> - No items allowed</li> <li><code>[items]</code> - Specific items only</li> </ul>"},{"location":"getting-started/configuration/#rails-configuration","title":"Rails Configuration","text":"<p>In Rails, configure in an initializer:</p> config/initializers/robot_lab.rb<pre><code>RobotLab.configure do |config|\n  # Use Rails credentials\n  config.anthropic_api_key = Rails.application.credentials.anthropic_api_key\n\n  # Use Rails logger\n  config.logger = Rails.logger\n\n  # Template path is automatically set to app/prompts\nend\n</code></pre> <p>Or use <code>config/application.rb</code>:</p> config/application.rb<pre><code>module MyApp\n  class Application &lt; Rails::Application\n    config.robot_lab.default_model = \"claude-sonnet-4\"\n    config.robot_lab.default_provider = :anthropic\n  end\nend\n</code></pre>"},{"location":"getting-started/configuration/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"config/initializers/robot_lab.rb<pre><code>RobotLab.configure do |config|\n  config.anthropic_api_key = ENV[\"ANTHROPIC_API_KEY\"]\n\n  case Rails.env\n  when \"development\"\n    config.logger = Logger.new($stdout, level: :debug)\n    config.default_model = \"claude-haiku-3\"  # Faster/cheaper for dev\n  when \"test\"\n    config.streaming_enabled = false\n  when \"production\"\n    config.logger = Rails.logger\n    config.default_model = \"claude-sonnet-4\"\n  end\nend\n</code></pre>"},{"location":"getting-started/configuration/#using-environment-variables","title":"Using Environment Variables","text":"<p>Recommended environment variables:</p> <pre><code># Required - at least one provider\nANTHROPIC_API_KEY=sk-ant-...\nOPENAI_API_KEY=sk-...\nGEMINI_API_KEY=...\n\n# Optional - override defaults\nROBOT_LAB_DEFAULT_MODEL=claude-sonnet-4\nROBOT_LAB_DEFAULT_PROVIDER=anthropic\nROBOT_LAB_MAX_ITERATIONS=20\n</code></pre> <p>Load them in configuration:</p> <pre><code>RobotLab.configure do |config|\n  config.anthropic_api_key = ENV[\"ANTHROPIC_API_KEY\"]\n  config.default_model = ENV.fetch(\"ROBOT_LAB_DEFAULT_MODEL\", \"claude-sonnet-4\")\n  config.max_iterations = ENV.fetch(\"ROBOT_LAB_MAX_ITERATIONS\", 10).to_i\nend\n</code></pre>"},{"location":"getting-started/configuration/#accessing-configuration","title":"Accessing Configuration","text":"<pre><code># Get current configuration\nconfig = RobotLab.configuration\n\n# Check settings\nconfig.default_model      # =&gt; \"claude-sonnet-4\"\nconfig.default_provider   # =&gt; :anthropic\nconfig.streaming_enabled  # =&gt; true\n</code></pre>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Building Robots - Create custom robots</li> <li>Creating Networks - Network configuration</li> <li>MCP Integration - Configure MCP servers</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers installing RobotLab in your Ruby project.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Ruby: 3.1 or higher</li> <li>Bundler: 2.0 or higher (recommended)</li> </ul>"},{"location":"getting-started/installation/#install-via-bundler","title":"Install via Bundler","text":"<p>Add RobotLab to your <code>Gemfile</code>:</p> <pre><code>gem \"robot_lab\"\n</code></pre> <p>Then install:</p> <pre><code>bundle install\n</code></pre>"},{"location":"getting-started/installation/#install-via-rubygems","title":"Install via RubyGems","text":"<p>Or install directly:</p> <pre><code>gem install robot_lab\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>RobotLab automatically installs these dependencies:</p> Gem Purpose <code>ruby_llm</code> LLM provider integrations <code>ruby_llm-template</code> Template rendering for prompts <code>simple_flow</code> Workflow execution"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>For specific features, you may need additional gems:</p> MCP WebSocket TransportMCP HTTP TransportRails Integration <pre><code>gem \"async-websocket\"\n</code></pre> <pre><code>gem \"async-http\"\n</code></pre> <pre><code># Rails is detected automatically\ngem \"rails\", \"&gt;= 7.0\"\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Create a test file to verify everything works:</p> <pre><code># test_robot_lab.rb\nrequire \"robot_lab\"\n\nputs \"RobotLab version: #{RobotLab::VERSION}\"\nputs \"Installation successful!\"\n</code></pre> <p>Run it:</p> <pre><code>ruby test_robot_lab.rb\n# =&gt; RobotLab version: 0.0.1\n# =&gt; Installation successful!\n</code></pre>"},{"location":"getting-started/installation/#rails-installation","title":"Rails Installation","text":"<p>For Rails applications, use the install generator:</p> <pre><code>rails generate robot_lab:install\n</code></pre> <p>This creates:</p> <ul> <li><code>config/initializers/robot_lab.rb</code> - Configuration file</li> <li><code>db/migrate/*_create_robot_lab_tables.rb</code> - Database migrations</li> <li><code>app/models/robot_lab_thread.rb</code> - Thread model</li> <li><code>app/models/robot_lab_result.rb</code> - Result model</li> <li><code>app/robots/</code> - Directory for robot definitions</li> <li><code>app/tools/</code> - Directory for tool definitions</li> </ul> <p>Then run migrations:</p> <pre><code>rails db:migrate\n</code></pre>"},{"location":"getting-started/installation/#environment-setup","title":"Environment Setup","text":"<p>Before using RobotLab, set up your API keys as environment variables:</p> Anthropic (Recommended)OpenAIGoogle Gemini <pre><code>export ANTHROPIC_API_KEY=\"sk-ant-...\"\n</code></pre> <pre><code>export OPENAI_API_KEY=\"sk-...\"\n</code></pre> <pre><code>export GEMINI_API_KEY=\"...\"\n</code></pre> <p>Using dotenv</p> <p>For development, consider using the dotenv gem to manage environment variables:</p> <pre><code># Gemfile\ngem \"dotenv-rails\", groups: [:development, :test]\n</code></pre> <pre><code># .env\nANTHROPIC_API_KEY=sk-ant-...\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#gem-installation-fails","title":"Gem Installation Fails","text":"<p>If you encounter SSL or network errors:</p> <pre><code># Update RubyGems\ngem update --system\n\n# Try installing with verbose output\ngem install robot_lab --verbose\n</code></pre>"},{"location":"getting-started/installation/#missing-dependencies","title":"Missing Dependencies","text":"<p>If you see \"LoadError\" for optional gems:</p> <pre><code># Install the specific gem mentioned in the error\nbundle add async-websocket\n</code></pre>"},{"location":"getting-started/installation/#api-key-issues","title":"API Key Issues","text":"<p>If you see authentication errors:</p> <ol> <li>Verify your API key is set: <code>echo $ANTHROPIC_API_KEY</code></li> <li>Check the key is valid in your provider's console</li> <li>Ensure you're using the correct environment variable name</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that RobotLab is installed:</p> <ul> <li> Quick Start - Build your first robot</li> <li> Configuration - Configure defaults</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Build your first RobotLab application in 5 minutes.</p>"},{"location":"getting-started/quick-start/#step-1-configure-robotlab","title":"Step 1: Configure RobotLab","text":"<p>First, set up your API credentials:</p> <pre><code>require \"robot_lab\"\n\nRobotLab.configure do |config|\n  config.anthropic_api_key = ENV[\"ANTHROPIC_API_KEY\"]\n  config.default_model = \"claude-sonnet-4\"\nend\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-create-a-robot","title":"Step 2: Create a Robot","text":"<p>Build a simple assistant robot:</p> <pre><code>assistant = RobotLab.build do\n  name \"assistant\"\n  description \"A helpful AI assistant\"\n\n  template &lt;&lt;~PROMPT\n    You are a helpful AI assistant. You provide clear, accurate,\n    and concise answers to questions. Be friendly but professional.\n  PROMPT\nend\n</code></pre>"},{"location":"getting-started/quick-start/#step-3-create-a-network","title":"Step 3: Create a Network","text":"<p>Add your robot to a network:</p> <pre><code>network = RobotLab.create_network do\n  name \"my_first_network\"\n  add_robot assistant\nend\n</code></pre>"},{"location":"getting-started/quick-start/#step-4-run-it","title":"Step 4: Run It!","text":"<p>Execute the network with a message:</p> <pre><code># Create state with your message\nstate = RobotLab.create_state(message: \"What is Ruby on Rails?\")\n\n# Run the network\nresult = network.run(state: state)\n\n# Get the response\nresponse = result.last_result.output.first.content\nputs response\n</code></pre>"},{"location":"getting-started/quick-start/#complete-example","title":"Complete Example","text":"<p>Here's everything together in one file:</p> hello_robot.rb<pre><code>require \"robot_lab\"\n\n# Configure\nRobotLab.configure do |config|\n  config.anthropic_api_key = ENV[\"ANTHROPIC_API_KEY\"]\n  config.default_model = \"claude-sonnet-4\"\nend\n\n# Build robot\nassistant = RobotLab.build do\n  name \"assistant\"\n  description \"A helpful AI assistant\"\n  template \"You are a helpful AI assistant.\"\nend\n\n# Create network\nnetwork = RobotLab.create_network do\n  name \"hello_network\"\n  add_robot assistant\nend\n\n# Run\nstate = RobotLab.create_state(message: \"Hello! What can you help me with?\")\nresult = network.run(state: state)\n\nputs result.last_result.output.first.content\n</code></pre> <p>Run it:</p> <pre><code>ruby hello_robot.rb\n</code></pre>"},{"location":"getting-started/quick-start/#adding-a-tool","title":"Adding a Tool","text":"<p>Make your robot more capable with tools:</p> <pre><code>assistant = RobotLab.build do\n  name \"assistant\"\n  description \"An assistant that can tell time\"\n\n  template &lt;&lt;~PROMPT\n    You are a helpful assistant. Use the current_time tool\n    when users ask about the time.\n  PROMPT\n\n  tool :current_time do\n    description \"Get the current date and time\"\n    handler { Time.now.strftime(\"%Y-%m-%d %H:%M:%S\") }\n  end\nend\n</code></pre> <p>Now the robot can respond to \"What time is it?\" by calling the tool.</p>"},{"location":"getting-started/quick-start/#multi-robot-example","title":"Multi-Robot Example","text":"<p>Create a network with multiple specialized robots:</p> <pre><code># Classifier robot\nclassifier = RobotLab.build do\n  name \"classifier\"\n  description \"Classifies incoming requests\"\n  template &lt;&lt;~PROMPT\n    Classify the user's request into one category:\n    - QUESTION: General knowledge questions\n    - MATH: Mathematical calculations\n    - OTHER: Everything else\n\n    Respond with only the category name.\n  PROMPT\nend\n\n# Question answerer\nanswerer = RobotLab.build do\n  name \"answerer\"\n  description \"Answers general questions\"\n  template \"You answer general knowledge questions accurately.\"\nend\n\n# Calculator\ncalculator = RobotLab.build do\n  name \"calculator\"\n  description \"Handles math problems\"\n  template \"You solve mathematical problems step by step.\"\nend\n\n# Network with routing\nnetwork = RobotLab.create_network do\n  name \"smart_assistant\"\n  add_robot classifier\n  add_robot answerer\n  add_robot calculator\n\n  router -&gt;(args) {\n    case args.call_count\n    when 0\n      :classifier\n    when 1\n      result = args.last_result&amp;.output&amp;.first&amp;.content&amp;.strip\n      case result\n      when \"QUESTION\" then :answerer\n      when \"MATH\" then :calculator\n      else :answerer\n      end\n    else\n      nil\n    end\n  }\nend\n</code></pre>"},{"location":"getting-started/quick-start/#whats-next","title":"What's Next?","text":"<p>You've built your first RobotLab application! Here's where to go next:</p> <ul> <li> <p> Configuration</p> <p>Learn all configuration options</p> </li> <li> <p> Building Robots</p> <p>Deep dive into robot creation</p> </li> <li> <p> Using Tools</p> <p>Give robots custom capabilities</p> </li> <li> <p> Creating Networks</p> <p>Advanced network patterns</p> </li> </ul>"},{"location":"guides/","title":"Guides","text":"<p>Practical guides for building applications with RobotLab.</p>"},{"location":"guides/#getting-started","title":"Getting Started","text":"<p>If you're new to RobotLab, start here:</p> <ul> <li> <p> Building Robots</p> <p>Create specialized AI agents with personalities and tools</p> </li> <li> <p> Creating Networks</p> <p>Orchestrate multiple robots for complex workflows</p> </li> </ul>"},{"location":"guides/#core-features","title":"Core Features","text":"<ul> <li> <p> Using Tools</p> <p>Give robots custom capabilities to interact with external systems</p> </li> <li> <p> MCP Integration</p> <p>Connect to Model Context Protocol servers</p> </li> <li> <p> Streaming Responses</p> <p>Real-time streaming of LLM responses</p> </li> <li> <p> Conversation History</p> <p>Persist and restore conversation threads</p> </li> <li> <p> Memory System</p> <p>Share data between robots with the memory system</p> </li> </ul>"},{"location":"guides/#framework-integration","title":"Framework Integration","text":"<ul> <li> <p> Rails Integration</p> <p>Use RobotLab in Ruby on Rails applications</p> </li> </ul>"},{"location":"guides/#guide-index","title":"Guide Index","text":"Guide Description Time Building Robots Create and configure robots 10 min Creating Networks Multi-robot orchestration 15 min Using Tools Add custom capabilities 10 min MCP Integration External tool servers 10 min Streaming Real-time responses 5 min History Conversation persistence 10 min Memory Shared data store 5 min Rails Integration Rails application setup 15 min"},{"location":"guides/building-robots/","title":"Building Robots","text":"<p>This guide covers everything you need to know about creating robots in RobotLab.</p>"},{"location":"guides/building-robots/#basic-robot","title":"Basic Robot","text":"<p>Create a simple robot with the builder DSL:</p> <pre><code>robot = RobotLab.build do\n  name \"assistant\"\n  description \"A helpful AI assistant\"\n  template \"You are a helpful assistant.\"\nend\n</code></pre>"},{"location":"guides/building-robots/#robot-properties","title":"Robot Properties","text":""},{"location":"guides/building-robots/#name","title":"Name","text":"<p>A unique identifier used for routing and logging:</p> <pre><code>name \"support_agent\"\n</code></pre>"},{"location":"guides/building-robots/#description","title":"Description","text":"<p>Describes what the robot does (useful for routing decisions):</p> <pre><code>description \"Handles customer support inquiries about orders and refunds\"\n</code></pre>"},{"location":"guides/building-robots/#model","title":"Model","text":"<p>The LLM model to use:</p> <pre><code>model \"claude-sonnet-4\"      # Anthropic\nmodel \"gpt-4o\"               # OpenAI\nmodel \"gemini-1.5-pro\"       # Google\n</code></pre>"},{"location":"guides/building-robots/#template-system-prompt","title":"Template (System Prompt)","text":"<p>Instructions that define the robot's personality and behavior:</p> <pre><code>template &lt;&lt;~PROMPT\n  You are a customer support specialist for TechCo.\n\n  Your responsibilities:\n  - Answer questions about products and services\n  - Help resolve order issues\n  - Provide friendly, professional assistance\n\n  Always be polite and acknowledge the customer's concerns.\nPROMPT\n</code></pre>"},{"location":"guides/building-robots/#adding-tools","title":"Adding Tools","text":"<p>Give robots capabilities with tools:</p> <pre><code>robot = RobotLab.build do\n  name \"order_assistant\"\n\n  tool :lookup_order do\n    description \"Look up order details by order ID\"\n    parameter :order_id, type: :string, required: true, description: \"The order ID\"\n    handler do |order_id:, **_context|\n      Order.find_by(id: order_id)&amp;.to_h || { error: \"Order not found\" }\n    end\n  end\n\n  tool :check_inventory do\n    description \"Check product inventory\"\n    parameter :product_id, type: :string, required: true\n    parameter :warehouse, type: :string, default: \"main\"\n    handler do |product_id:, warehouse:, **_context|\n      Inventory.check(product_id, warehouse: warehouse)\n    end\n  end\nend\n</code></pre>"},{"location":"guides/building-robots/#tool-parameters","title":"Tool Parameters","text":"<p>Define parameters with types and descriptions:</p> <pre><code>tool :search do\n  parameter :query, type: :string, required: true, description: \"Search query\"\n  parameter :limit, type: :integer, default: 10, description: \"Max results\"\n  parameter :category, type: :string, enum: %w[books movies music]\nend\n</code></pre> Option Description <code>type</code> Parameter type (<code>:string</code>, <code>:integer</code>, <code>:boolean</code>, <code>:number</code>, <code>:array</code>, <code>:object</code>) <code>required</code> Whether the parameter is required <code>default</code> Default value if not provided <code>description</code> Description for the LLM <code>enum</code> List of allowed values"},{"location":"guides/building-robots/#tool-handler-context","title":"Tool Handler Context","text":"<p>Handlers receive execution context:</p> <pre><code>handler do |param1:, param2:, robot:, network:, state:|\n  # robot   - The Robot instance\n  # network - The NetworkRun\n  # state   - Current State\n\n  # Access state data\n  user_id = state.data[:user_id]\n\n  # Use memory\n  state.memory.remember(\"last_search\", param1)\n\n  # Return result (will be sent to LLM)\n  { success: true, data: result }\nend\n</code></pre> <p>Ignoring Context</p> <p>Use <code>**_context</code> to accept but ignore context: <pre><code>handler { |query:, **_context| search(query) }\n</code></pre></p>"},{"location":"guides/building-robots/#template-files","title":"Template Files","text":"<p>Load templates from files:</p> <pre><code># Configure template path\nRobotLab.configure do |config|\n  config.template_path = \"prompts\"  # or \"app/prompts\" in Rails\nend\n\n# Reference template by name\nrobot = RobotLab.build do\n  name \"support\"\n  template \"support_agent\"  # Loads prompts/support_agent.erb\nend\n</code></pre>"},{"location":"guides/building-robots/#template-variables","title":"Template Variables","text":"<p>Pass variables to templates:</p> <pre><code>robot = RobotLab.build do\n  name \"support\"\n  template \"support_agent\", company: \"TechCo\", tone: \"friendly\"\nend\n</code></pre> prompts/support_agent.erb<pre><code>You are a support agent for &lt;%= company %&gt;.\nYour tone should be &lt;%= tone %&gt;.\n</code></pre>"},{"location":"guides/building-robots/#mcp-configuration","title":"MCP Configuration","text":"<p>Connect to MCP servers:</p> <pre><code>robot = RobotLab.build do\n  name \"coder\"\n\n  # Use specific MCP servers\n  mcp [\n    {\n      name: \"filesystem\",\n      transport: { type: \"stdio\", command: \"mcp-server-fs\", args: [\"--root\", \"/data\"] }\n    }\n  ]\n\n  # Or inherit from network\n  mcp :inherit\n\n  # Or disable MCP\n  mcp :none\nend\n</code></pre>"},{"location":"guides/building-robots/#tool-whitelist","title":"Tool Whitelist","text":"<p>Restrict available tools:</p> <pre><code>robot = RobotLab.build do\n  name \"reader\"\n\n  # Only allow specific tools\n  tools %w[read_file list_directory]\n\n  # Or inherit from network\n  tools :inherit\n\n  # Or disable all inherited tools\n  tools :none\nend\n</code></pre>"},{"location":"guides/building-robots/#running-robots","title":"Running Robots","text":""},{"location":"guides/building-robots/#standalone","title":"Standalone","text":"<p>Run a robot directly:</p> <pre><code>state = RobotLab.create_state(message: \"Hello!\")\nresult = robot.run(state: state, network: nil)\n\nputs result.output.first.content\n</code></pre>"},{"location":"guides/building-robots/#in-a-network","title":"In a Network","text":"<p>Run through a network for full orchestration:</p> <pre><code>network = RobotLab.create_network do\n  add_robot robot\nend\n\nstate = RobotLab.create_state(message: \"Hello!\")\nresult = network.run(state: state)\n</code></pre>"},{"location":"guides/building-robots/#with-streaming","title":"With Streaming","text":"<p>Stream responses in real-time:</p> <pre><code>robot.run(\n  state: state,\n  network: network,\n  streaming: -&gt;(event) {\n    case event[:event]\n    when \"delta\"\n      print event[:data][:content]\n    when \"tool_call\"\n      puts \"\\nCalling tool: #{event[:data][:name]}\"\n    end\n  }\n)\n</code></pre>"},{"location":"guides/building-robots/#robot-patterns","title":"Robot Patterns","text":""},{"location":"guides/building-robots/#classifier-robot","title":"Classifier Robot","text":"<p>Route requests to specialized handlers:</p> <pre><code>classifier = RobotLab.build do\n  name \"classifier\"\n  description \"Classifies incoming requests\"\n\n  template &lt;&lt;~PROMPT\n    Analyze the user's message and classify it into exactly one category:\n    - BILLING: Questions about invoices, payments, subscriptions\n    - TECHNICAL: Technical issues, bugs, how-to questions\n    - GENERAL: General inquiries, feedback, other\n\n    Respond with only the category name, nothing else.\n  PROMPT\nend\n</code></pre>"},{"location":"guides/building-robots/#specialist-robot","title":"Specialist Robot","text":"<p>Handle specific domains:</p> <pre><code>billing_specialist = RobotLab.build do\n  name \"billing_specialist\"\n  description \"Handles billing and payment inquiries\"\n\n  template &lt;&lt;~PROMPT\n    You are a billing specialist. You help customers with:\n    - Invoice questions\n    - Payment issues\n    - Subscription management\n\n    Always verify the customer's account before making changes.\n  PROMPT\n\n  tool :get_invoices do\n    description \"Get customer's recent invoices\"\n    parameter :customer_id, type: :string, required: true\n    handler { |customer_id:, **_| Invoice.where(customer_id: customer_id).limit(10) }\n  end\nend\n</code></pre>"},{"location":"guides/building-robots/#summarizer-robot","title":"Summarizer Robot","text":"<p>Condense information:</p> <pre><code>summarizer = RobotLab.build do\n  name \"summarizer\"\n  description \"Summarizes conversations and documents\"\n\n  template &lt;&lt;~PROMPT\n    Create concise summaries of the provided content.\n    Focus on key points and actionable items.\n    Use bullet points for clarity.\n  PROMPT\nend\n</code></pre>"},{"location":"guides/building-robots/#best-practices","title":"Best Practices","text":""},{"location":"guides/building-robots/#1-clear-focused-templates","title":"1. Clear, Focused Templates","text":"<pre><code># Good: Specific and focused\ntemplate &lt;&lt;~PROMPT\n  You are a code reviewer. Review code for:\n  - Security vulnerabilities\n  - Performance issues\n  - Best practice violations\n\n  Provide specific line numbers and suggestions.\nPROMPT\n\n# Bad: Vague and unfocused\ntemplate \"You help with code stuff.\"\n</code></pre>"},{"location":"guides/building-robots/#2-descriptive-tool-definitions","title":"2. Descriptive Tool Definitions","text":"<pre><code># Good: Clear description and parameter docs\ntool :search_users do\n  description \"Search for users by email, name, or ID. Returns up to 10 matches.\"\n  parameter :query, type: :string, required: true,\n            description: \"Email address, partial name, or user ID\"\nend\n\n# Bad: Missing context\ntool :search do\n  parameter :q, type: :string\nend\n</code></pre>"},{"location":"guides/building-robots/#3-handle-tool-errors-gracefully","title":"3. Handle Tool Errors Gracefully","text":"<pre><code>handler do |user_id:, **_|\n  user = User.find_by(id: user_id)\n  if user\n    { success: true, user: user.to_h }\n  else\n    { success: false, error: \"User not found\", user_id: user_id }\n  end\nrescue ActiveRecord::ConnectionError =&gt; e\n  { success: false, error: \"Database unavailable\", retry: true }\nend\n</code></pre>"},{"location":"guides/building-robots/#next-steps","title":"Next Steps","text":"<ul> <li>Creating Networks - Orchestrate multiple robots</li> <li>Using Tools - Advanced tool patterns</li> <li>API Reference: Robot - Complete API documentation</li> </ul>"},{"location":"guides/creating-networks/","title":"Creating Networks","text":"<p>Networks orchestrate multiple robots using SimpleFlow pipelines with DAG-based execution and optional task activation.</p>"},{"location":"guides/creating-networks/#basic-network","title":"Basic Network","text":"<p>Create a network with a sequential pipeline:</p> <pre><code>network = RobotLab.create_network(name: \"pipeline\") do\n  task :analyzer, analyzer_robot, depends_on: :none\n  task :writer, writer_robot, depends_on: [:analyzer]\n  task :reviewer, reviewer_robot, depends_on: [:writer]\nend\n\nresult = network.run(message: \"Analyze this document\")\n</code></pre>"},{"location":"guides/creating-networks/#network-properties","title":"Network Properties","text":""},{"location":"guides/creating-networks/#name","title":"Name","text":"<p>Identifies the network for logging and debugging:</p> <pre><code>network = RobotLab.create_network(name: \"customer_service\") do\n  # ...\nend\n</code></pre>"},{"location":"guides/creating-networks/#concurrency","title":"Concurrency","text":"<p>Control parallel execution mode:</p> <pre><code>network = RobotLab.create_network(name: \"parallel\", concurrency: :threads) do\n  # :auto (default), :threads, or :async\nend\n</code></pre>"},{"location":"guides/creating-networks/#adding-tasks","title":"Adding Tasks","text":""},{"location":"guides/creating-networks/#sequential-tasks","title":"Sequential Tasks","text":"<p>Each task depends on the previous:</p> <pre><code>network = RobotLab.create_network(name: \"pipeline\") do\n  task :first, robot1, depends_on: :none\n  task :second, robot2, depends_on: [:first]\n  task :third, robot3, depends_on: [:second]\nend\n</code></pre>"},{"location":"guides/creating-networks/#parallel-tasks","title":"Parallel Tasks","text":"<p>Tasks with the same dependencies run in parallel:</p> <pre><code>network = RobotLab.create_network(name: \"parallel_analysis\") do\n  task :fetch, fetcher, depends_on: :none\n\n  # These run in parallel after :fetch\n  task :sentiment, sentiment_bot, depends_on: [:fetch]\n  task :entities, entity_bot, depends_on: [:fetch]\n  task :keywords, keyword_bot, depends_on: [:fetch]\n\n  # This waits for all three to complete\n  task :merge, merger, depends_on: [:sentiment, :entities, :keywords]\nend\n</code></pre>"},{"location":"guides/creating-networks/#optional-tasks","title":"Optional Tasks","text":"<p>Optional tasks only run when explicitly activated:</p> <pre><code>network = RobotLab.create_network(name: \"router\") do\n  task :classifier, classifier_robot, depends_on: :none\n  task :billing, billing_robot, depends_on: :optional\n  task :technical, technical_robot, depends_on: :optional\n  task :general, general_robot, depends_on: :optional\nend\n</code></pre>"},{"location":"guides/creating-networks/#per-task-configuration","title":"Per-Task Configuration","text":"<p>Tasks can have individual context and configuration that's deep-merged with the network's run parameters:</p> <pre><code>network = RobotLab.create_network(name: \"support\") do\n  task :classifier, classifier_robot, depends_on: :none\n  task :billing, billing_robot,\n       context: { department: \"billing\", escalation_level: 2 },\n       depends_on: :optional\n  task :technical, technical_robot,\n       context: { department: \"technical\" },\n       tools: [DebugTool, LogTool],\n       depends_on: :optional\nend\n</code></pre>"},{"location":"guides/creating-networks/#task-options","title":"Task Options","text":"Option Description <code>context</code> Hash merged with run params (task values override) <code>mcp</code> MCP servers for this task <code>tools</code> Tools available to this task <code>memory</code> Task-specific memory <code>depends_on</code> <code>:none</code>, <code>[:task1]</code>, or <code>:optional</code>"},{"location":"guides/creating-networks/#conditional-routing","title":"Conditional Routing","text":"<p>Use optional tasks with custom Robot subclasses for intelligent routing:</p> <pre><code>class ClassifierRobot &lt; RobotLab::Robot\n  def call(result)\n    robot_result = run(**extract_run_context(result))\n\n    new_result = result\n      .with_context(@name.to_sym, robot_result)\n      .continue(robot_result)\n\n    # Activate appropriate specialist based on classification\n    category = robot_result.last_text_content.to_s.strip.downcase\n\n    case category\n    when /billing/ then new_result.activate(:billing)\n    when /technical/ then new_result.activate(:technical)\n    else new_result.activate(:general)\n    end\n  end\nend\n\nclassifier = ClassifierRobot.new(\n  name: \"classifier\",\n  system_prompt: \"Classify as: billing, technical, or general. Respond with one word.\"\n)\n\nnetwork = RobotLab.create_network(name: \"support\") do\n  task :classifier, classifier, depends_on: :none\n  task :billing, billing_robot, depends_on: :optional\n  task :technical, technical_robot, depends_on: :optional\n  task :general, general_robot, depends_on: :optional\nend\n</code></pre>"},{"location":"guides/creating-networks/#running-networks","title":"Running Networks","text":""},{"location":"guides/creating-networks/#basic-run","title":"Basic Run","text":"<pre><code>result = network.run(message: \"Help me with my order\")\n\n# Get the final response\nputs result.value.last_text_content\n</code></pre>"},{"location":"guides/creating-networks/#with-additional-context","title":"With Additional Context","text":"<pre><code>result = network.run(\n  message: \"Check my order status\",\n  customer_id: 123,\n  order_id: \"ORD-456\"\n)\n</code></pre>"},{"location":"guides/creating-networks/#accessing-task-results","title":"Accessing Task Results","text":"<pre><code>result = network.run(message: \"Process this\")\n\n# Access individual robot results\nclassifier_result = result.context[:classifier]\nbilling_result = result.context[:billing]\n\n# Original run parameters\noriginal_params = result.context[:run_params]\n</code></pre>"},{"location":"guides/creating-networks/#simpleflowresult","title":"SimpleFlow::Result","text":"<p>Networks return a <code>SimpleFlow::Result</code> object:</p> <pre><code>result = network.run(message: \"Hello\")\n\nresult.value      # The final task's output (RobotResult)\nresult.context    # Hash of all task results and metadata\nresult.halted?    # Whether execution was halted early\nresult.continued? # Whether execution continued normally\n</code></pre>"},{"location":"guides/creating-networks/#patterns","title":"Patterns","text":""},{"location":"guides/creating-networks/#classifier-pattern","title":"Classifier Pattern","text":"<p>Route to specialists based on classification:</p> <pre><code>class SupportClassifier &lt; RobotLab::Robot\n  def call(result)\n    robot_result = run(**extract_run_context(result))\n    new_result = result\n      .with_context(@name.to_sym, robot_result)\n      .continue(robot_result)\n\n    category = robot_result.last_text_content.to_s.strip.downcase\n    new_result.activate(category.to_sym)\n  end\nend\n\nnetwork = RobotLab.create_network(name: \"support\") do\n  task :classifier, SupportClassifier.new(name: \"classifier\", template: :classifier),\n       depends_on: :none\n  task :billing, billing_robot, depends_on: :optional\n  task :technical, technical_robot, depends_on: :optional\n  task :general, general_robot, depends_on: :optional\nend\n</code></pre>"},{"location":"guides/creating-networks/#pipeline-pattern","title":"Pipeline Pattern","text":"<p>Process through sequential stages:</p> <pre><code>network = RobotLab.create_network(name: \"document_processor\") do\n  task :extract, extractor, depends_on: :none\n  task :analyze, analyzer, depends_on: [:extract]\n  task :format, formatter, depends_on: [:analyze]\nend\n</code></pre>"},{"location":"guides/creating-networks/#fan-outfan-in-pattern","title":"Fan-Out/Fan-In Pattern","text":"<p>Parallel processing with aggregation:</p> <pre><code>network = RobotLab.create_network(name: \"multi_analysis\") do\n  task :prepare, preparer, depends_on: :none\n\n  # Fan-out: parallel analysis\n  task :sentiment, sentiment_analyzer, depends_on: [:prepare]\n  task :topics, topic_extractor, depends_on: [:prepare]\n  task :entities, entity_recognizer, depends_on: [:prepare]\n\n  # Fan-in: aggregate results\n  task :aggregate, aggregator, depends_on: [:sentiment, :topics, :entities]\nend\n</code></pre>"},{"location":"guides/creating-networks/#conditional-continuation","title":"Conditional Continuation","text":"<p>A robot can halt execution early:</p> <pre><code>class ValidatorRobot &lt; RobotLab::Robot\n  def call(result)\n    robot_result = run(**extract_run_context(result))\n\n    if robot_result.last_text_content.include?(\"INVALID\")\n      # Stop the pipeline\n      result.halt(robot_result)\n    else\n      # Continue to next task\n      result\n        .with_context(@name.to_sym, robot_result)\n        .continue(robot_result)\n    end\n  end\nend\n</code></pre>"},{"location":"guides/creating-networks/#visualization","title":"Visualization","text":""},{"location":"guides/creating-networks/#ascii-visualization","title":"ASCII Visualization","text":"<pre><code>puts network.visualize\n# =&gt; ASCII representation of the pipeline\n</code></pre>"},{"location":"guides/creating-networks/#mermaid-diagram","title":"Mermaid Diagram","text":"<pre><code>puts network.to_mermaid\n# =&gt; Mermaid graph definition\n</code></pre>"},{"location":"guides/creating-networks/#execution-plan","title":"Execution Plan","text":"<pre><code>puts network.execution_plan\n# =&gt; Description of execution order\n</code></pre>"},{"location":"guides/creating-networks/#network-introspection","title":"Network Introspection","text":"<pre><code>network.name              # =&gt; \"support\"\nnetwork.robots            # =&gt; Hash of name =&gt; Robot\nnetwork.robot(:billing)   # =&gt; Robot instance\nnetwork[\"billing\"]        # =&gt; Robot instance (alias)\nnetwork.available_robots  # =&gt; Array of Robot instances\nnetwork.to_h              # =&gt; Hash representation\n</code></pre>"},{"location":"guides/creating-networks/#best-practices","title":"Best Practices","text":""},{"location":"guides/creating-networks/#1-keep-robots-focused","title":"1. Keep Robots Focused","text":"<p>Each robot should have a single responsibility:</p> <pre><code># Good: focused robots\ntask :classify, classifier, depends_on: :none\ntask :respond, responder, depends_on: [:classify]\n\n# Bad: one robot doing everything\ntask :do_everything, mega_robot, depends_on: :none\n</code></pre>"},{"location":"guides/creating-networks/#2-use-context-for-data-passing","title":"2. Use Context for Data Passing","text":"<p>Access previous results via context:</p> <pre><code>class ResponderRobot &lt; RobotLab::Robot\n  def call(result)\n    # Get classifier's output\n    classification = result.context[:classifier]&amp;.last_text_content\n\n    # Use it in this robot's run\n    robot_result = run(\n      **extract_run_context(result),\n      classification: classification\n    )\n\n    result.with_context(@name.to_sym, robot_result).continue(robot_result)\n  end\nend\n</code></pre>"},{"location":"guides/creating-networks/#3-handle-missing-results","title":"3. Handle Missing Results","text":"<p>Guard against missing optional task results:</p> <pre><code>def call(result)\n  # Check if optional task ran\n  if result.context[:validator]\n    # Use validator result\n  else\n    # Handle missing validation\n  end\nend\n</code></pre>"},{"location":"guides/creating-networks/#next-steps","title":"Next Steps","text":"<ul> <li>Using Tools - Add capabilities to robots</li> <li>Memory Guide - Persistent memory across runs</li> <li>API Reference: Network - Complete API</li> </ul>"},{"location":"guides/history/","title":"Conversation History","text":"<p>Persist and restore conversation threads across sessions.</p>"},{"location":"guides/history/#overview","title":"Overview","text":"<p>History allows you to:</p> <ul> <li>Save conversation results to a database</li> <li>Restore previous conversations</li> <li>Continue multi-turn interactions</li> <li>Maintain context across sessions</li> </ul>"},{"location":"guides/history/#configuration","title":"Configuration","text":""},{"location":"guides/history/#history-config","title":"History Config","text":"<p>Configure history with callbacks:</p> <pre><code>history_config = RobotLab::History::Config.new(\n  create_thread: -&gt;(state:, input:, **) {\n    # Create a new thread, return thread_id\n    { thread_id: SecureRandom.uuid }\n  },\n\n  get: -&gt;(thread_id:, **) {\n    # Retrieve history for thread\n    # Return Array&lt;RobotResult&gt;\n    []\n  },\n\n  append_user_message: -&gt;(thread_id:, message:, **) {\n    # Optional: Store user message\n  },\n\n  append_results: -&gt;(thread_id:, new_results:, **) {\n    # Store new results\n  }\n)\n</code></pre>"},{"location":"guides/history/#apply-to-network","title":"Apply to Network","text":"<pre><code>network = RobotLab.create_network do\n  name \"persistent_chat\"\n  history history_config\nend\n</code></pre>"},{"location":"guides/history/#callback-reference","title":"Callback Reference","text":""},{"location":"guides/history/#create_thread","title":"create_thread","text":"<p>Called when starting a new conversation:</p> <pre><code>create_thread: -&gt;(state:, input:, **kwargs) {\n  # state - Current State object\n  # input - UserMessage or string\n  # kwargs - Additional context\n\n  thread = Thread.create!(\n    initial_input: input.to_s,\n    user_id: state.data[:user_id]\n  )\n\n  { thread_id: thread.id.to_s }  # Must return hash with :thread_id\n}\n</code></pre>"},{"location":"guides/history/#get","title":"get","text":"<p>Called to retrieve existing history:</p> <pre><code>get: -&gt;(thread_id:, **kwargs) {\n  # thread_id - The thread identifier\n  # kwargs - Additional context\n\n  Result.where(thread_id: thread_id)\n        .order(:created_at)\n        .map { |r| deserialize_result(r) }\n\n  # Must return Array&lt;RobotResult&gt;\n}\n</code></pre>"},{"location":"guides/history/#append_user_message-optional","title":"append_user_message (Optional)","text":"<p>Called when a user message is added:</p> <pre><code>append_user_message: -&gt;(thread_id:, message:, **kwargs) {\n  # thread_id - The thread identifier\n  # message - UserMessage object\n\n  Message.create!(\n    thread_id: thread_id,\n    content: message.content,\n    metadata: message.metadata\n  )\n}\n</code></pre>"},{"location":"guides/history/#append_results","title":"append_results","text":"<p>Called after robots finish:</p> <pre><code>append_results: -&gt;(thread_id:, new_results:, **kwargs) {\n  # thread_id - The thread identifier\n  # new_results - Array&lt;RobotResult&gt;\n\n  new_results.each do |result|\n    Result.create!(\n      thread_id: thread_id,\n      robot_name: result.robot_name,\n      output_data: serialize_output(result.output),\n      stop_reason: result.stop_reason\n    )\n  end\n}\n</code></pre>"},{"location":"guides/history/#activerecord-adapter","title":"ActiveRecord Adapter","text":"<p>RobotLab includes a built-in ActiveRecord adapter:</p> <pre><code>adapter = RobotLab::History::ActiveRecordAdapter.new(\n  thread_model: RobotLabThread,\n  result_model: RobotLabResult\n)\n\nnetwork = RobotLab.create_network do\n  history adapter.to_config\nend\n</code></pre>"},{"location":"guides/history/#required-models","title":"Required Models","text":"app/models/robot_lab_thread.rb<pre><code>class RobotLabThread &lt; ApplicationRecord\n  has_many :results, class_name: \"RobotLabResult\", foreign_key: :thread_id\n\n  # Required columns:\n  # - thread_id: string\n  # - initial_input: text\n  # - input_metadata: jsonb\n  # - state_data: jsonb\n  # - last_user_message: text\n  # - last_user_message_at: datetime\nend\n</code></pre> app/models/robot_lab_result.rb<pre><code>class RobotLabResult &lt; ApplicationRecord\n  belongs_to :thread, class_name: \"RobotLabThread\", foreign_key: :thread_id\n\n  # Required columns:\n  # - thread_id: string\n  # - robot_name: string\n  # - sequence_number: integer\n  # - output_data: jsonb\n  # - tool_calls_data: jsonb\n  # - stop_reason: string\n  # - checksum: string\nend\n</code></pre>"},{"location":"guides/history/#using-thread-ids","title":"Using Thread IDs","text":""},{"location":"guides/history/#start-new-thread","title":"Start New Thread","text":"<pre><code>state = RobotLab.create_state(message: \"Hello!\")\nresult = network.run(state: state)\n\n# Thread ID is assigned automatically\nthread_id = state.thread_id\n</code></pre>"},{"location":"guides/history/#continue-existing-thread","title":"Continue Existing Thread","text":"<pre><code># Option 1: Via UserMessage\nmessage = RobotLab::UserMessage.new(\n  \"Continue our conversation\",\n  thread_id: existing_thread_id\n)\nstate = RobotLab.create_state(message: message)\n\n# Option 2: Direct assignment\nstate = RobotLab.create_state(message: \"Continue\")\nstate.thread_id = existing_thread_id\n\n# History is automatically loaded\nresult = network.run(state: state)\n</code></pre>"},{"location":"guides/history/#threadmanager","title":"ThreadManager","text":"<p>For programmatic control:</p> <pre><code>manager = RobotLab::History::ThreadManager.new(history_config)\n\n# Create thread\nthread_id = manager.create_thread(state: state, input: message)\n\n# Load history\nresults = manager.get_history(thread_id)\n\n# Save state\nmanager.save_state(thread_id: thread_id, state: state, since_index: 5)\n</code></pre>"},{"location":"guides/history/#serialization","title":"Serialization","text":""},{"location":"guides/history/#robotresult","title":"RobotResult","text":"<p>Results are serialized via <code>export</code>:</p> <pre><code>result.export\n# =&gt; {\n#   robot_name: \"assistant\",\n#   output: [...],\n#   tool_calls: [...],\n#   stop_reason: \"stop\",\n#   id: \"...\",\n#   created_at: \"...\"\n# }\n</code></pre>"},{"location":"guides/history/#messages","title":"Messages","text":"<p>Messages serialize to hashes:</p> <pre><code>message.to_h\n# =&gt; {\n#   type: \"text\",\n#   role: \"assistant\",\n#   content: \"Hello!\",\n#   stop_reason: \"stop\"\n# }\n</code></pre>"},{"location":"guides/history/#restore-from-hash","title":"Restore from hash","text":"<pre><code>RobotLab::Message.from_hash(hash)\n</code></pre>"},{"location":"guides/history/#patterns","title":"Patterns","text":""},{"location":"guides/history/#redis-based-history","title":"Redis-Based History","text":"<pre><code>history_config = History::Config.new(\n  create_thread: -&gt;(state:, input:, **) {\n    thread_id = SecureRandom.uuid\n    Redis.current.hset(\"threads\", thread_id, input.to_s)\n    { thread_id: thread_id }\n  },\n\n  get: -&gt;(thread_id:, **) {\n    data = Redis.current.lrange(\"results:#{thread_id}\", 0, -1)\n    data.map { |json| deserialize_result(JSON.parse(json)) }\n  },\n\n  append_results: -&gt;(thread_id:, new_results:, **) {\n    new_results.each do |result|\n      Redis.current.rpush(\"results:#{thread_id}\", result.export.to_json)\n    end\n  }\n)\n</code></pre>"},{"location":"guides/history/#custom-storage","title":"Custom Storage","text":"<pre><code>class CustomHistoryAdapter\n  def initialize(storage)\n    @storage = storage\n  end\n\n  def to_config\n    History::Config.new(\n      create_thread: method(:create_thread),\n      get: method(:get),\n      append_results: method(:append_results)\n    )\n  end\n\n  private\n\n  def create_thread(state:, input:, **)\n    id = @storage.create_conversation(input: input.to_s)\n    { thread_id: id }\n  end\n\n  def get(thread_id:, **)\n    @storage.fetch_results(thread_id)\n  end\n\n  def append_results(thread_id:, new_results:, **)\n    @storage.store_results(thread_id, new_results)\n  end\nend\n</code></pre>"},{"location":"guides/history/#best-practices","title":"Best Practices","text":""},{"location":"guides/history/#1-handle-missing-threads","title":"1. Handle Missing Threads","text":"<pre><code>get: -&gt;(thread_id:, **) {\n  thread = Thread.find_by(thread_id: thread_id)\n  return [] unless thread\n\n  thread.results.order(:created_at).map(&amp;:to_robot_result)\n}\n</code></pre>"},{"location":"guides/history/#2-index-for-performance","title":"2. Index for Performance","text":"<pre><code>CREATE INDEX idx_results_thread_id ON robot_lab_results(thread_id);\nCREATE INDEX idx_results_created_at ON robot_lab_results(created_at);\n</code></pre>"},{"location":"guides/history/#3-clean-up-old-threads","title":"3. Clean Up Old Threads","text":"<pre><code># Periodic cleanup job\nThread.where(\"updated_at &lt; ?\", 30.days.ago).destroy_all\n</code></pre>"},{"location":"guides/history/#4-limit-history-size","title":"4. Limit History Size","text":"<pre><code>get: -&gt;(thread_id:, **) {\n  Result.where(thread_id: thread_id)\n        .order(created_at: :desc)\n        .limit(50)  # Last 50 exchanges\n        .reverse\n        .map(&amp;:to_robot_result)\n}\n</code></pre>"},{"location":"guides/history/#next-steps","title":"Next Steps","text":"<ul> <li>Memory System - In-memory data sharing</li> <li>State Management - State details</li> <li>API Reference: History - Complete API</li> </ul>"},{"location":"guides/mcp-integration/","title":"MCP Integration","text":"<p>RobotLab supports the Model Context Protocol (MCP) for connecting to external tool servers.</p>"},{"location":"guides/mcp-integration/#what-is-mcp","title":"What is MCP?","text":"<p>MCP is a protocol that allows LLM applications to connect to external servers that provide tools, resources, and context. This enables:</p> <ul> <li>Reusable tool servers across applications</li> <li>Separation of tool logic from AI logic</li> <li>Dynamic tool discovery</li> </ul>"},{"location":"guides/mcp-integration/#configuring-mcp-servers","title":"Configuring MCP Servers","text":""},{"location":"guides/mcp-integration/#at-network-level","title":"At Network Level","text":"<pre><code>network = RobotLab.create_network do\n  name \"dev_assistant\"\n\n  mcp [\n    {\n      name: \"filesystem\",\n      transport: {\n        type: \"stdio\",\n        command: \"mcp-server-filesystem\",\n        args: [\"--root\", \"/home/user/projects\"]\n      }\n    },\n    {\n      name: \"github\",\n      transport: {\n        type: \"stdio\",\n        command: \"mcp-server-github\"\n      }\n    }\n  ]\nend\n</code></pre>"},{"location":"guides/mcp-integration/#at-robot-level","title":"At Robot Level","text":"<pre><code>robot = RobotLab.build do\n  name \"coder\"\n\n  # Use network's MCP servers\n  mcp :inherit\n\n  # Or specific servers\n  mcp [\n    { name: \"filesystem\", transport: { type: \"stdio\", command: \"mcp-fs\" } }\n  ]\n\n  # Or disable MCP\n  mcp :none\nend\n</code></pre>"},{"location":"guides/mcp-integration/#global-configuration","title":"Global Configuration","text":"<pre><code>RobotLab.configure do |config|\n  config.mcp = [\n    { name: \"common_tools\", transport: { type: \"stdio\", command: \"common-mcp\" } }\n  ]\nend\n</code></pre>"},{"location":"guides/mcp-integration/#transport-types","title":"Transport Types","text":""},{"location":"guides/mcp-integration/#stdio-transport","title":"Stdio Transport","text":"<p>Communicate via stdin/stdout with a subprocess:</p> <pre><code>{\n  name: \"server_name\",\n  transport: {\n    type: \"stdio\",\n    command: \"mcp-server-command\",\n    args: [\"--option\", \"value\"],\n    env: { \"API_KEY\" =&gt; ENV[\"API_KEY\"] }\n  }\n}\n</code></pre>"},{"location":"guides/mcp-integration/#websocket-transport","title":"WebSocket Transport","text":"<p>Connect via WebSocket:</p> <pre><code>{\n  name: \"remote_server\",\n  transport: {\n    type: \"websocket\",\n    url: \"ws://localhost:8080/mcp\"\n  }\n}\n</code></pre> <p>Dependency Required</p> <p>WebSocket transport requires the <code>async-websocket</code> gem.</p>"},{"location":"guides/mcp-integration/#sse-transport","title":"SSE Transport","text":"<p>Server-Sent Events transport:</p> <pre><code>{\n  name: \"sse_server\",\n  transport: {\n    type: \"sse\",\n    url: \"http://localhost:8080/sse\"\n  }\n}\n</code></pre>"},{"location":"guides/mcp-integration/#http-transport","title":"HTTP Transport","text":"<p>Streamable HTTP transport with session support:</p> <pre><code>{\n  name: \"http_server\",\n  transport: {\n    type: \"streamable_http\",\n    url: \"https://api.example.com/mcp\",\n    session_id: \"optional_session_id\",\n    auth_provider: -&gt; { \"Bearer #{fetch_token}\" }\n  }\n}\n</code></pre>"},{"location":"guides/mcp-integration/#using-mcp-tools","title":"Using MCP Tools","text":"<p>Once configured, MCP tools are automatically available to robots:</p> <pre><code>network = RobotLab.create_network do\n  mcp [\n    { name: \"github\", transport: { type: \"stdio\", command: \"mcp-server-github\" } }\n  ]\n\n  add_robot RobotLab.build {\n    name \"helper\"\n    template &lt;&lt;~PROMPT\n      You can help users with GitHub tasks.\n      Use available tools to search repositories, create issues, etc.\n    PROMPT\n  }\nend\n\n# The robot can now use GitHub MCP tools\nstate = RobotLab.create_state(message: \"Find repositories about machine learning\")\nnetwork.run(state: state)\n</code></pre>"},{"location":"guides/mcp-integration/#filtering-mcp-tools","title":"Filtering MCP Tools","text":"<p>Restrict which MCP tools are available:</p> <pre><code>robot = RobotLab.build do\n  name \"reader\"\n  mcp :inherit\n\n  # Only allow specific MCP tools\n  tools %w[read_file search_code list_directory]\nend\n</code></pre>"},{"location":"guides/mcp-integration/#mcp-server-configuration","title":"MCP Server Configuration","text":""},{"location":"guides/mcp-integration/#server-object","title":"Server Object","text":"<pre><code>server = RobotLab::MCP::Server.new(\n  name: \"my_server\",\n  transport: {\n    type: \"stdio\",\n    command: \"my-mcp-server\"\n  }\n)\n\nserver.name           # =&gt; \"my_server\"\nserver.transport_type # =&gt; \"stdio\"\nserver.to_h           # Hash representation\n</code></pre>"},{"location":"guides/mcp-integration/#client-object","title":"Client Object","text":"<pre><code>client = RobotLab::MCP::Client.new(server: server)\nclient.connect\n\nclient.connected?     # =&gt; true\nclient.to_h           # Client info\n</code></pre>"},{"location":"guides/mcp-integration/#common-mcp-servers","title":"Common MCP Servers","text":""},{"location":"guides/mcp-integration/#filesystem","title":"Filesystem","text":"<pre><code>{\n  name: \"filesystem\",\n  transport: {\n    type: \"stdio\",\n    command: \"mcp-server-filesystem\",\n    args: [\"--root\", \"/path/to/files\"]\n  }\n}\n</code></pre> <p>Tools: <code>read_file</code>, <code>write_file</code>, <code>list_directory</code>, <code>search_files</code></p>"},{"location":"guides/mcp-integration/#github","title":"GitHub","text":"<pre><code>{\n  name: \"github\",\n  transport: {\n    type: \"stdio\",\n    command: \"mcp-server-github\",\n    env: { \"GITHUB_TOKEN\" =&gt; ENV[\"GITHUB_TOKEN\"] }\n  }\n}\n</code></pre> <p>Tools: <code>search_repositories</code>, <code>create_issue</code>, <code>get_file_contents</code>, etc.</p>"},{"location":"guides/mcp-integration/#database","title":"Database","text":"<pre><code>{\n  name: \"postgres\",\n  transport: {\n    type: \"stdio\",\n    command: \"mcp-server-postgres\",\n    env: { \"DATABASE_URL\" =&gt; ENV[\"DATABASE_URL\"] }\n  }\n}\n</code></pre> <p>Tools: <code>query</code>, <code>list_tables</code>, <code>describe_table</code></p>"},{"location":"guides/mcp-integration/#error-handling","title":"Error Handling","text":""},{"location":"guides/mcp-integration/#connection-errors","title":"Connection Errors","text":"<pre><code>begin\n  network.run(state: state)\nrescue RobotLab::MCPError =&gt; e\n  puts \"MCP Error: #{e.message}\"\n  # Handle gracefully\nend\n</code></pre>"},{"location":"guides/mcp-integration/#missing-dependencies","title":"Missing Dependencies","text":"<pre><code># If async-websocket not installed\nrescue RobotLab::MCPError =&gt; e\n  if e.message.include?(\"async-websocket\")\n    puts \"Install async-websocket gem for WebSocket support\"\n  end\nend\n</code></pre>"},{"location":"guides/mcp-integration/#disconnecting","title":"Disconnecting","text":"<p>Robots automatically disconnect from MCP servers when done:</p> <pre><code>robot.disconnect  # Manually disconnect\n</code></pre> <p>Networks handle this automatically at the end of a run.</p>"},{"location":"guides/mcp-integration/#patterns","title":"Patterns","text":""},{"location":"guides/mcp-integration/#development-vs-production","title":"Development vs Production","text":"<pre><code>network = RobotLab.create_network do\n  mcp_config = if Rails.env.development?\n    [{ name: \"local_fs\", transport: { type: \"stdio\", command: \"mcp-fs\", args: [\"--root\", \".\"] } }]\n  else\n    [{ name: \"s3\", transport: { type: \"stdio\", command: \"mcp-s3\" } }]\n  end\n\n  mcp mcp_config\nend\n</code></pre>"},{"location":"guides/mcp-integration/#dynamic-server-selection","title":"Dynamic Server Selection","text":"<pre><code>def mcp_servers_for_user(user)\n  servers = []\n  servers &lt;&lt; github_server if user.github_connected?\n  servers &lt;&lt; slack_server if user.slack_connected?\n  servers\nend\n\nnetwork = RobotLab.create_network do\n  mcp mcp_servers_for_user(current_user)\nend\n</code></pre>"},{"location":"guides/mcp-integration/#best-practices","title":"Best Practices","text":""},{"location":"guides/mcp-integration/#1-use-environment-variables-for-credentials","title":"1. Use Environment Variables for Credentials","text":"<pre><code>{\n  name: \"github\",\n  transport: {\n    type: \"stdio\",\n    command: \"mcp-server-github\",\n    env: {\n      \"GITHUB_TOKEN\" =&gt; ENV[\"GITHUB_TOKEN\"],\n      \"GITHUB_ORG\" =&gt; ENV[\"GITHUB_ORG\"]\n    }\n  }\n}\n</code></pre>"},{"location":"guides/mcp-integration/#2-limit-tool-access","title":"2. Limit Tool Access","text":"<pre><code># Don't expose all tools\nrobot = RobotLab.build do\n  mcp :inherit\n  tools %w[read_file search_files]  # No write access\nend\n</code></pre>"},{"location":"guides/mcp-integration/#3-handle-disconnections","title":"3. Handle Disconnections","text":"<pre><code>begin\n  result = network.run(state: state)\nrescue RobotLab::MCPError\n  # Retry without MCP\n  result = network.run(state: state, mcp: :none)\nend\n</code></pre>"},{"location":"guides/mcp-integration/#next-steps","title":"Next Steps","text":"<ul> <li>Using Tools - Local tool patterns</li> <li>Creating Networks - Network configuration</li> <li>API Reference: MCP - Complete MCP API</li> </ul>"},{"location":"guides/memory/","title":"Memory System","text":"<p>The memory system allows robots to share data within a network run.</p>"},{"location":"guides/memory/#overview","title":"Overview","text":"<p>Memory provides:</p> <ul> <li>Key-value storage accessible by all robots</li> <li>Namespaced scopes for organization</li> <li>Persistence within a single network run</li> </ul>"},{"location":"guides/memory/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/memory/#store-values","title":"Store Values","text":"<pre><code>state.memory.remember(\"user_name\", \"Alice\")\nstate.memory.remember(\"preferences\", { theme: \"dark\", language: \"en\" })\n</code></pre>"},{"location":"guides/memory/#retrieve-values","title":"Retrieve Values","text":"<pre><code>name = state.memory.recall(\"user_name\")  # =&gt; \"Alice\"\nprefs = state.memory.recall(\"preferences\")  # =&gt; { theme: \"dark\", ... }\n\n# Returns nil if not found\nmissing = state.memory.recall(\"unknown\")  # =&gt; nil\n</code></pre>"},{"location":"guides/memory/#check-existence","title":"Check Existence","text":"<pre><code>state.memory.exists?(\"user_name\")  # =&gt; true\nstate.memory.exists?(\"unknown\")    # =&gt; false\n</code></pre>"},{"location":"guides/memory/#remove-values","title":"Remove Values","text":"<pre><code>state.memory.forget(\"user_name\")\n</code></pre>"},{"location":"guides/memory/#scoped-memory","title":"Scoped Memory","text":"<p>Organize data with namespaces:</p> <pre><code># Create a scoped view\nuser_memory = state.memory.scoped(\"user:123\")\n\n# Operations are scoped\nuser_memory.remember(\"name\", \"Alice\")\nuser_memory.remember(\"email\", \"alice@example.com\")\n\n# Keys are prefixed\nstate.memory.recall(\"user:123:name\")  # =&gt; \"Alice\"\n\n# Scoped recall\nuser_memory.recall(\"name\")  # =&gt; \"Alice\"\n</code></pre>"},{"location":"guides/memory/#nested-scopes","title":"Nested Scopes","text":"<pre><code>session = state.memory.scoped(\"session:abc\")\nprefs = session.scoped(\"preferences\")\n\nprefs.remember(\"theme\", \"dark\")\n# Full key: \"session:abc:preferences:theme\"\n</code></pre>"},{"location":"guides/memory/#memory-operations","title":"Memory Operations","text":""},{"location":"guides/memory/#list-all-keys","title":"List All Keys","text":"<pre><code>state.memory.all\n# =&gt; {\n#   \"user_name\" =&gt; \"Alice\",\n#   \"user:123:email\" =&gt; \"alice@example.com\",\n#   ...\n# }\n</code></pre>"},{"location":"guides/memory/#list-namespaces","title":"List Namespaces","text":"<pre><code>state.memory.namespaces\n# =&gt; [\"user:123\", \"session:abc\", ...]\n</code></pre>"},{"location":"guides/memory/#search-by-pattern","title":"Search by Pattern","text":"<pre><code># Find keys matching pattern\nmatches = state.memory.search(\"user:*\")\n# =&gt; { \"user:123:name\" =&gt; \"Alice\", \"user:123:email\" =&gt; \"...\" }\n</code></pre>"},{"location":"guides/memory/#statistics","title":"Statistics","text":"<pre><code>state.memory.stats\n# =&gt; { total_keys: 15, namespaces: [\"user:123\", \"session\"] }\n</code></pre>"},{"location":"guides/memory/#clear-memory","title":"Clear Memory","text":"<pre><code># Clear a namespace\nstate.memory.scoped(\"temp\").clear\n\n# Clear all memory\nstate.memory.clear_all\n</code></pre>"},{"location":"guides/memory/#shared-namespace","title":"Shared Namespace","text":"<p>The <code>SHARED</code> namespace is a convention for cross-robot data:</p> <pre><code># In first robot\nstate.memory.remember(\"SHARED:context\", important_data)\n\n# In later robot\ncontext = state.memory.recall(\"SHARED:context\")\n</code></pre>"},{"location":"guides/memory/#using-shared-scope","title":"Using Shared Scope","text":"<pre><code>shared = state.memory.scoped(RobotLab::Memory::SHARED_NAMESPACE)\nshared.remember(\"workflow_status\", \"in_progress\")\n</code></pre>"},{"location":"guides/memory/#in-tool-handlers","title":"In Tool Handlers","text":"<p>Access memory from tools:</p> <pre><code>tool :update_preference do\n  description \"Update user preference\"\n  parameter :key, type: :string, required: true\n  parameter :value, type: :string, required: true\n\n  handler do |key:, value:, state:, **_|\n    prefs = state.memory.scoped(\"preferences\")\n    prefs.remember(key, value)\n    { success: true, key: key, value: value }\n  end\nend\n</code></pre>"},{"location":"guides/memory/#in-routers","title":"In Routers","text":"<p>Use memory for routing decisions:</p> <pre><code>router = -&gt;(args) {\n  case args.call_count\n  when 0\n    :classifier\n  when 1\n    # Read classification from memory\n    intent = args.network.state.memory.recall(\"SHARED:intent\")\n    case intent\n    when \"billing\" then :billing_agent\n    when \"technical\" then :tech_agent\n    else :general_agent\n    end\n  else\n    nil\n  end\n}\n</code></pre>"},{"location":"guides/memory/#patterns","title":"Patterns","text":""},{"location":"guides/memory/#accumulating-data","title":"Accumulating Data","text":"<pre><code># In each robot\ndef add_finding(state, finding)\n  findings = state.memory.recall(\"findings\") || []\n  findings &lt;&lt; finding\n  state.memory.remember(\"findings\", findings)\nend\n\n# In final robot\nall_findings = state.memory.recall(\"findings\")\n</code></pre>"},{"location":"guides/memory/#tracking-progress","title":"Tracking Progress","text":"<pre><code># Track workflow stages\nstate.memory.remember(\"stage\", \"intake\")\n# ... processing ...\nstate.memory.remember(\"stage\", \"analysis\")\n# ... processing ...\nstate.memory.remember(\"stage\", \"response\")\n</code></pre>"},{"location":"guides/memory/#caching-expensive-operations","title":"Caching Expensive Operations","text":"<pre><code>tool :fetch_user do\n  handler do |user_id:, state:, **_|\n    cache_key = \"cache:user:#{user_id}\"\n\n    # Check cache\n    cached = state.memory.recall(cache_key)\n    return cached if cached\n\n    # Fetch and cache\n    user = User.find(user_id).to_h\n    state.memory.remember(cache_key, user)\n    user\n  end\nend\n</code></pre>"},{"location":"guides/memory/#user-session-data","title":"User Session Data","text":"<pre><code># Store session data\nsession = state.memory.scoped(\"session:#{session_id}\")\nsession.remember(\"started_at\", Time.now.iso8601)\nsession.remember(\"page_views\", 0)\n\n# Update during conversation\nviews = session.recall(\"page_views\") || 0\nsession.remember(\"page_views\", views + 1)\n</code></pre>"},{"location":"guides/memory/#memory-vs-statedata","title":"Memory vs State.data","text":"Feature Memory State.data Purpose Robot-to-robot sharing Input/output data Scope Namespaced Flat hash Typical Use Intermediate results User input, workflow config Persistence Within run Can be serialized <pre><code># Use state.data for input configuration\nstate = RobotLab.create_state(\n  message: \"Process order\",\n  data: { order_id: \"123\", priority: \"high\" }\n)\n\n# Use memory for intermediate findings\nstate.memory.remember(\"validation_result\", { valid: true })\nstate.memory.remember(\"processing_steps\", [\"validated\", \"charged\"])\n</code></pre>"},{"location":"guides/memory/#best-practices","title":"Best Practices","text":""},{"location":"guides/memory/#1-use-descriptive-keys","title":"1. Use Descriptive Keys","text":"<pre><code># Good\nstate.memory.remember(\"classification:intent\", \"billing\")\nstate.memory.remember(\"user:123:last_order_id\", \"ord_456\")\n\n# Bad\nstate.memory.remember(\"x\", \"billing\")\nstate.memory.remember(\"temp1\", \"ord_456\")\n</code></pre>"},{"location":"guides/memory/#2-scope-related-data","title":"2. Scope Related Data","text":"<pre><code># Good\nuser = state.memory.scoped(\"user:#{user_id}\")\nuser.remember(\"name\", name)\nuser.remember(\"email\", email)\nuser.remember(\"plan\", plan)\n\n# Less organized\nstate.memory.remember(\"user_name\", name)\nstate.memory.remember(\"user_email\", email)\nstate.memory.remember(\"user_plan\", plan)\n</code></pre>"},{"location":"guides/memory/#3-clean-up-temporary-data","title":"3. Clean Up Temporary Data","text":"<pre><code># At end of processing\nstate.memory.scoped(\"temp\").clear\n</code></pre>"},{"location":"guides/memory/#4-document-memory-keys","title":"4. Document Memory Keys","text":"<pre><code># In your robot definitions, document expected keys\n# Memory keys used:\n# - SHARED:intent - Classification result\n# - SHARED:entities - Extracted entities\n# - user:{id}:* - User-specific data\n</code></pre>"},{"location":"guides/memory/#next-steps","title":"Next Steps","text":"<ul> <li>State Management - Full state details</li> <li>Building Robots - Using memory in robots</li> <li>API Reference: Memory - Complete API</li> </ul>"},{"location":"guides/rails-integration/","title":"Rails Integration","text":"<p>RobotLab integrates seamlessly with Ruby on Rails applications.</p>"},{"location":"guides/rails-integration/#installation","title":"Installation","text":""},{"location":"guides/rails-integration/#generate-files","title":"Generate Files","text":"<pre><code>rails generate robot_lab:install\n</code></pre> <p>This creates:</p> <pre><code>config/initializers/robot_lab.rb  # Configuration\ndb/migrate/*_create_robot_lab_tables.rb  # Database tables\napp/models/robot_lab_thread.rb  # Thread model\napp/models/robot_lab_result.rb  # Result model\napp/robots/  # Directory for robots\napp/tools/   # Directory for tools\n</code></pre>"},{"location":"guides/rails-integration/#run-migrations","title":"Run Migrations","text":"<pre><code>rails db:migrate\n</code></pre>"},{"location":"guides/rails-integration/#configuration","title":"Configuration","text":""},{"location":"guides/rails-integration/#initializer","title":"Initializer","text":"config/initializers/robot_lab.rb<pre><code>RobotLab.configure do |config|\n  # API Keys from credentials\n  config.anthropic_api_key = Rails.application.credentials.anthropic_api_key\n  config.openai_api_key = Rails.application.credentials.openai_api_key\n\n  # Defaults\n  config.default_provider = :anthropic\n  config.default_model = \"claude-sonnet-4\"\n\n  # Rails logger\n  config.logger = Rails.logger\n\n  # Template path (auto-configured to app/prompts)\nend\n</code></pre>"},{"location":"guides/rails-integration/#environment-specific","title":"Environment-Specific","text":"<pre><code>RobotLab.configure do |config|\n  config.anthropic_api_key = Rails.application.credentials.anthropic_api_key\n\n  case Rails.env\n  when \"development\"\n    config.default_model = \"claude-haiku-3\"  # Faster/cheaper\n    config.logger.level = :debug\n  when \"test\"\n    config.streaming_enabled = false\n  when \"production\"\n    config.default_model = \"claude-sonnet-4\"\n  end\nend\n</code></pre>"},{"location":"guides/rails-integration/#application-config","title":"Application Config","text":"config/application.rb<pre><code>module MyApp\n  class Application &lt; Rails::Application\n    config.robot_lab.default_model = \"claude-sonnet-4\"\n    config.robot_lab.default_provider = :anthropic\n  end\nend\n</code></pre>"},{"location":"guides/rails-integration/#creating-robots","title":"Creating Robots","text":""},{"location":"guides/rails-integration/#robot-generator","title":"Robot Generator","text":"<pre><code>rails generate robot_lab:robot Support\nrails generate robot_lab:robot Billing --description=\"Handles billing inquiries\"\nrails generate robot_lab:robot Router --routing\n</code></pre>"},{"location":"guides/rails-integration/#robot-class","title":"Robot Class","text":"app/robots/support_robot.rb<pre><code>class SupportRobot\n  def self.build\n    RobotLab.build do\n      name \"support\"\n      description \"Handles customer support inquiries\"\n      model \"claude-sonnet-4\"\n\n      template \"support/system_prompt\"\n\n      tool :lookup_order do\n        description \"Look up order by ID\"\n        parameter :order_id, type: :string, required: true\n        handler { |order_id:, **_| Order.find_by(id: order_id)&amp;.to_h }\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"guides/rails-integration/#using-in-controllers","title":"Using in Controllers","text":"app/controllers/chat_controller.rb<pre><code>class ChatController &lt; ApplicationController\n  def create\n    network = build_network\n    state = RobotLab.create_state(\n      message: params[:message],\n      data: { user_id: current_user.id }\n    )\n\n    result = network.run(state: state)\n\n    render json: {\n      response: result.last_result.output.first.content,\n      thread_id: state.thread_id\n    }\n  end\n\n  private\n\n  def build_network\n    RobotLab.create_network do\n      name \"customer_service\"\n      add_robot SupportRobot.build\n      add_robot BillingRobot.build\n\n      history history_adapter.to_config\n    end\n  end\n\n  def history_adapter\n    RobotLab::History::ActiveRecordAdapter.new(\n      thread_model: RobotLabThread,\n      result_model: RobotLabResult\n    )\n  end\nend\n</code></pre>"},{"location":"guides/rails-integration/#prompt-templates","title":"Prompt Templates","text":""},{"location":"guides/rails-integration/#template-location","title":"Template Location","text":"<pre><code>app/prompts/\n\u251c\u2500\u2500 support/\n\u2502   \u251c\u2500\u2500 system_prompt.erb\n\u2502   \u2514\u2500\u2500 greeting.erb\n\u2514\u2500\u2500 billing/\n    \u2514\u2500\u2500 system_prompt.erb\n</code></pre>"},{"location":"guides/rails-integration/#template-usage","title":"Template Usage","text":"<pre><code>robot = RobotLab.build do\n  name \"support\"\n  template \"support/system_prompt\", company: \"Acme Corp\"\nend\n</code></pre> app/prompts/support/system_prompt.erb<pre><code>You are a support agent for &lt;%= company %&gt;.\n\nYour responsibilities:\n- Answer product questions\n- Help with order issues\n- Provide friendly assistance\n</code></pre>"},{"location":"guides/rails-integration/#action-cable-integration","title":"Action Cable Integration","text":""},{"location":"guides/rails-integration/#channel","title":"Channel","text":"app/channels/chat_channel.rb<pre><code>class ChatChannel &lt; ApplicationCable::Channel\n  def subscribed\n    stream_from \"chat_#{params[:thread_id]}\"\n  end\n\n  def receive(data)\n    message = data[\"message\"]\n    thread_id = data[\"thread_id\"]\n\n    state = RobotLab.create_state(message: message)\n    state.thread_id = thread_id if thread_id\n\n    network.run(\n      state: state,\n      streaming: -&gt;(event) {\n        ActionCable.server.broadcast(\"chat_#{thread_id || state.thread_id}\", event)\n      }\n    )\n  end\n\n  private\n\n  def network\n    @network ||= ChatNetwork.build\n  end\nend\n</code></pre>"},{"location":"guides/rails-integration/#javascript-client","title":"JavaScript Client","text":"<pre><code>const channel = consumer.subscriptions.create(\n  { channel: \"ChatChannel\", thread_id: threadId },\n  {\n    received(data) {\n      if (data.event === \"delta\") {\n        appendToMessage(data.data.content);\n      }\n    }\n  }\n);\n\nchannel.send({ message: \"Hello!\", thread_id: threadId });\n</code></pre>"},{"location":"guides/rails-integration/#background-jobs","title":"Background Jobs","text":""},{"location":"guides/rails-integration/#async-processing","title":"Async Processing","text":"app/jobs/process_message_job.rb<pre><code>class ProcessMessageJob &lt; ApplicationJob\n  queue_as :default\n\n  def perform(thread_id:, message:, user_id:)\n    state = RobotLab.create_state(\n      message: message,\n      data: { user_id: user_id }\n    )\n    state.thread_id = thread_id\n\n    result = network.run(state: state)\n\n    # Notify user of completion\n    ActionCable.server.broadcast(\n      \"chat_#{thread_id}\",\n      { event: \"complete\", response: result.last_result.output.first.content }\n    )\n  end\n\n  private\n\n  def network\n    ChatNetwork.build\n  end\nend\n</code></pre>"},{"location":"guides/rails-integration/#enqueue-from-controller","title":"Enqueue from Controller","text":"<pre><code>ProcessMessageJob.perform_later(\n  thread_id: params[:thread_id],\n  message: params[:message],\n  user_id: current_user.id\n)\n\nrender json: { status: \"processing\" }\n</code></pre>"},{"location":"guides/rails-integration/#testing","title":"Testing","text":""},{"location":"guides/rails-integration/#test-configuration","title":"Test Configuration","text":"config/environments/test.rb<pre><code>Rails.application.configure do\n  config.robot_lab.streaming_enabled = false\nend\n</code></pre>"},{"location":"guides/rails-integration/#robot-tests","title":"Robot Tests","text":"test/robots/support_robot_test.rb<pre><code>require \"test_helper\"\n\nclass SupportRobotTest &lt; ActiveSupport::TestCase\n  test \"builds valid robot\" do\n    robot = SupportRobot.build\n    assert_equal \"support\", robot.name\n    assert_includes robot.tools.map(&amp;:name), \"lookup_order\"\n  end\nend\n</code></pre>"},{"location":"guides/rails-integration/#integration-tests","title":"Integration Tests","text":"test/integration/chat_test.rb<pre><code>require \"test_helper\"\n\nclass ChatTest &lt; ActionDispatch::IntegrationTest\n  test \"processes chat message\" do\n    VCR.use_cassette(\"chat_response\") do\n      post chat_path, params: { message: \"Hello\" }\n      assert_response :success\n\n      json = JSON.parse(response.body)\n      assert json[\"response\"].present?\n      assert json[\"thread_id\"].present?\n    end\n  end\nend\n</code></pre>"},{"location":"guides/rails-integration/#models","title":"Models","text":""},{"location":"guides/rails-integration/#thread-model","title":"Thread Model","text":"app/models/robot_lab_thread.rb<pre><code>class RobotLabThread &lt; ApplicationRecord\n  has_many :results, class_name: \"RobotLabResult\", foreign_key: :thread_id\n  belongs_to :user, optional: true\n\n  scope :recent, -&gt; { order(updated_at: :desc) }\n  scope :for_user, -&gt;(user) { where(user: user) }\nend\n</code></pre>"},{"location":"guides/rails-integration/#result-model","title":"Result Model","text":"app/models/robot_lab_result.rb<pre><code>class RobotLabResult &lt; ApplicationRecord\n  belongs_to :thread, class_name: \"RobotLabThread\"\n\n  def to_robot_result\n    RobotLab::RobotResult.new(\n      robot_name: robot_name,\n      output: deserialize_messages(output_data),\n      tool_calls: deserialize_messages(tool_calls_data),\n      stop_reason: stop_reason\n    )\n  end\n\n  private\n\n  def deserialize_messages(data)\n    return [] unless data\n    data.map { |h| RobotLab::Message.from_hash(h.symbolize_keys) }\n  end\nend\n</code></pre>"},{"location":"guides/rails-integration/#best-practices","title":"Best Practices","text":""},{"location":"guides/rails-integration/#1-use-service-objects","title":"1. Use Service Objects","text":"app/services/chat_service.rb<pre><code>class ChatService\n  def initialize(user:)\n    @user = user\n  end\n\n  def process(message, thread_id: nil)\n    state = build_state(message, thread_id)\n    result = network.run(state: state)\n\n    {\n      response: result.last_result.output.first.content,\n      thread_id: state.thread_id\n    }\n  end\n\n  private\n\n  def build_state(message, thread_id)\n    state = RobotLab.create_state(\n      message: message,\n      data: { user_id: @user.id }\n    )\n    state.thread_id = thread_id if thread_id\n    state\n  end\n\n  def network\n    @network ||= ChatNetwork.build\n  end\nend\n</code></pre>"},{"location":"guides/rails-integration/#2-handle-errors","title":"2. Handle Errors","text":"<pre><code>def create\n  result = ChatService.new(user: current_user).process(params[:message])\n  render json: result\nrescue RobotLab::Error =&gt; e\n  render json: { error: e.message }, status: :unprocessable_entity\nrescue StandardError =&gt; e\n  Rails.logger.error(\"Chat error: #{e.message}\")\n  render json: { error: \"An error occurred\" }, status: :internal_server_error\nend\n</code></pre>"},{"location":"guides/rails-integration/#3-rate-limiting","title":"3. Rate Limiting","text":"<pre><code>class ChatController &lt; ApplicationController\n  before_action :check_rate_limit\n\n  private\n\n  def check_rate_limit\n    key = \"chat_rate:#{current_user.id}\"\n    count = Rails.cache.increment(key, 1, expires_in: 1.minute)\n\n    if count &gt; 10\n      render json: { error: \"Rate limit exceeded\" }, status: :too_many_requests\n    end\n  end\nend\n</code></pre>"},{"location":"guides/rails-integration/#next-steps","title":"Next Steps","text":"<ul> <li>Building Robots - Robot patterns</li> <li>Creating Networks - Network configuration</li> <li>History Guide - Conversation persistence</li> </ul>"},{"location":"guides/streaming/","title":"Streaming Responses","text":"<p>Stream LLM responses in real-time for better user experience.</p>"},{"location":"guides/streaming/#basic-streaming","title":"Basic Streaming","text":"<p>Pass a callback to receive streaming events:</p> <pre><code>robot.run(\n  state: state,\n  network: network,\n  streaming: -&gt;(event) {\n    puts event.inspect\n  }\n)\n</code></pre>"},{"location":"guides/streaming/#event-types","title":"Event Types","text":""},{"location":"guides/streaming/#text-deltas","title":"Text Deltas","text":"<p>Receive text as it's generated:</p> <pre><code>streaming: -&gt;(event) {\n  if event[:event] == \"delta\"\n    print event[:data][:content]\n  end\n}\n</code></pre>"},{"location":"guides/streaming/#tool-calls","title":"Tool Calls","text":"<p>Know when tools are being called:</p> <pre><code>streaming: -&gt;(event) {\n  case event[:event]\n  when \"tool_call.start\"\n    puts \"\\nCalling: #{event[:data][:name]}\"\n  when \"tool_call.complete\"\n    puts \"Done: #{event[:data][:result]}\"\n  end\n}\n</code></pre>"},{"location":"guides/streaming/#lifecycle-events","title":"Lifecycle Events","text":"<p>Track execution lifecycle:</p> <pre><code>streaming: -&gt;(event) {\n  case event[:event]\n  when \"run.started\"\n    puts \"Starting run #{event[:data][:run_id]}\"\n  when \"run.completed\"\n    puts \"Completed!\"\n  when \"run.failed\"\n    puts \"Failed: #{event[:data][:error]}\"\n  end\n}\n</code></pre>"},{"location":"guides/streaming/#event-reference","title":"Event Reference","text":"Event Description Data <code>run.started</code> Network run began <code>run_id</code>, <code>network</code> <code>run.completed</code> Network run finished <code>run_id</code>, <code>robot_count</code> <code>run.failed</code> Error occurred <code>run_id</code>, <code>error</code> <code>delta</code> Text content chunk <code>content</code> <code>tool_call.start</code> Tool execution starting <code>name</code>, <code>input</code> <code>tool_call.complete</code> Tool execution done <code>name</code>, <code>result</code>"},{"location":"guides/streaming/#streaming-context","title":"Streaming Context","text":"<p>For advanced control, use <code>Streaming::Context</code>:</p> <pre><code>context = RobotLab::Streaming::Context.new(\n  run_id: SecureRandom.uuid,\n  message_id: SecureRandom.uuid,\n  scope: \"network\",\n  publish: -&gt;(event) { broadcast_to_client(event) }\n)\n</code></pre>"},{"location":"guides/streaming/#context-properties","title":"Context Properties","text":"<pre><code>context.run_id      # Unique run identifier\ncontext.message_id  # Unique message identifier\ncontext.scope       # \"network\" or \"robot\"\n</code></pre>"},{"location":"guides/streaming/#publishing-events","title":"Publishing Events","text":"<pre><code>context.publish_event(\n  event: \"custom.event\",\n  data: { key: \"value\" }\n)\n</code></pre>"},{"location":"guides/streaming/#web-integration","title":"Web Integration","text":""},{"location":"guides/streaming/#rails-action-cable","title":"Rails Action Cable","text":"<pre><code>class ChatChannel &lt; ApplicationCable::Channel\n  def receive(data)\n    state = RobotLab.create_state(message: data[\"message\"])\n\n    network.run(\n      state: state,\n      streaming: -&gt;(event) {\n        transmit(event)\n      }\n    )\n  end\nend\n</code></pre>"},{"location":"guides/streaming/#server-sent-events","title":"Server-Sent Events","text":"<pre><code>class StreamController &lt; ApplicationController\n  include ActionController::Live\n\n  def create\n    response.headers[\"Content-Type\"] = \"text/event-stream\"\n\n    state = RobotLab.create_state(message: params[:message])\n\n    network.run(\n      state: state,\n      streaming: -&gt;(event) {\n        response.stream.write(\"data: #{event.to_json}\\n\\n\")\n      }\n    )\n  ensure\n    response.stream.close\n  end\nend\n</code></pre>"},{"location":"guides/streaming/#websocket","title":"WebSocket","text":"<pre><code># Using Faye WebSocket\nws.on :message do |msg|\n  state = RobotLab.create_state(message: msg.data)\n\n  network.run(\n    state: state,\n    streaming: -&gt;(event) {\n      ws.send(event.to_json)\n    }\n  )\nend\n</code></pre>"},{"location":"guides/streaming/#event-filtering","title":"Event Filtering","text":""},{"location":"guides/streaming/#check-event-type","title":"Check Event Type","text":"<pre><code>streaming: -&gt;(event) {\n  return unless RobotLab::Streaming::Events.delta?(event)\n  print event[:data][:content]\n}\n</code></pre>"},{"location":"guides/streaming/#available-predicates","title":"Available Predicates","text":"<pre><code>Streaming::Events.lifecycle?(event)  # run.started, run.completed, etc.\nStreaming::Events.delta?(event)       # Text content\nStreaming::Events.valid?(event)       # Has required fields\n</code></pre>"},{"location":"guides/streaming/#buffering","title":"Buffering","text":"<p>Buffer content for batch processing:</p> <pre><code>buffer = []\n\nstreaming: -&gt;(event) {\n  if event[:event] == \"delta\"\n    buffer &lt;&lt; event[:data][:content]\n\n    # Flush every 10 chunks\n    if buffer.size &gt;= 10\n      process_batch(buffer.join)\n      buffer.clear\n    end\n  end\n}\n\n# Don't forget final flush\nprocess_batch(buffer.join) if buffer.any?\n</code></pre>"},{"location":"guides/streaming/#progress-tracking","title":"Progress Tracking","text":"<p>Track streaming progress:</p> <pre><code>class StreamProgress\n  def initialize\n    @chars = 0\n    @tools = 0\n  end\n\n  def handle(event)\n    case event[:event]\n    when \"delta\"\n      @chars += event[:data][:content].length\n      puts \"\\rReceived #{@chars} characters...\"\n    when \"tool_call.start\"\n      @tools += 1\n      puts \"\\nTool call ##{@tools}: #{event[:data][:name]}\"\n    end\n  end\nend\n\nprogress = StreamProgress.new\nnetwork.run(state: state, streaming: progress.method(:handle))\n</code></pre>"},{"location":"guides/streaming/#error-handling","title":"Error Handling","text":"<p>Handle streaming errors gracefully:</p> <pre><code>streaming: -&gt;(event) {\n  case event[:event]\n  when \"run.failed\"\n    log_error(event[:data][:error])\n    notify_user(\"An error occurred\")\n  when \"delta\"\n    begin\n      broadcast(event)\n    rescue BroadcastError =&gt; e\n      # Client disconnected, but continue processing\n      logger.warn \"Broadcast failed: #{e.message}\"\n    end\n  end\n}\n</code></pre>"},{"location":"guides/streaming/#disabling-streaming","title":"Disabling Streaming","text":"<p>Disable streaming when not needed:</p> <pre><code>RobotLab.configure do |config|\n  config.streaming_enabled = false\nend\n\n# Or per-run\nnetwork.run(state: state, streaming: nil)\n</code></pre>"},{"location":"guides/streaming/#best-practices","title":"Best Practices","text":""},{"location":"guides/streaming/#1-handle-all-event-types","title":"1. Handle All Event Types","text":"<pre><code>streaming: -&gt;(event) {\n  case event[:event]\n  when \"delta\" then handle_delta(event)\n  when \"tool_call.start\" then show_tool_indicator(event)\n  when \"tool_call.complete\" then hide_tool_indicator(event)\n  when \"run.completed\" then finalize_response\n  when \"run.failed\" then show_error(event)\n  end\n}\n</code></pre>"},{"location":"guides/streaming/#2-provide-user-feedback","title":"2. Provide User Feedback","text":"<pre><code>streaming: -&gt;(event) {\n  case event[:event]\n  when \"run.started\"\n    show_typing_indicator\n  when \"delta\"\n    update_message(event[:data][:content])\n  when \"tool_call.start\"\n    show_status(\"Looking up information...\")\n  when \"run.completed\"\n    hide_typing_indicator\n  end\n}\n</code></pre>"},{"location":"guides/streaming/#3-clean-up-resources","title":"3. Clean Up Resources","text":"<pre><code>begin\n  network.run(state: state, streaming: callback)\nensure\n  close_stream_connection\nend\n</code></pre>"},{"location":"guides/streaming/#next-steps","title":"Next Steps","text":"<ul> <li>Building Robots - Robot creation</li> <li>Creating Networks - Network patterns</li> <li>API Reference: Streaming - Complete API</li> </ul>"},{"location":"guides/using-tools/","title":"Using Tools","text":"<p>Tools give robots the ability to interact with external systems.</p>"},{"location":"guides/using-tools/#defining-tools","title":"Defining Tools","text":""},{"location":"guides/using-tools/#in-robot-builder","title":"In Robot Builder","text":"<pre><code>robot = RobotLab.build do\n  name \"assistant\"\n\n  tool :get_weather do\n    description \"Get current weather for a location\"\n    parameter :location, type: :string, required: true\n    handler { |location:, **_| WeatherService.current(location) }\n  end\nend\n</code></pre>"},{"location":"guides/using-tools/#standalone-tool","title":"Standalone Tool","text":"<pre><code>weather_tool = RobotLab::Tool.new(\n  name: \"get_weather\",\n  description: \"Get current weather for a location\",\n  parameters: {\n    location: {\n      type: \"string\",\n      description: \"City name\",\n      required: true\n    }\n  },\n  handler: -&gt;(location:, **_context) {\n    WeatherService.current(location)\n  }\n)\n</code></pre>"},{"location":"guides/using-tools/#parameter-types","title":"Parameter Types","text":""},{"location":"guides/using-tools/#string","title":"String","text":"<pre><code>parameter :name, type: :string, required: true\n</code></pre>"},{"location":"guides/using-tools/#integer","title":"Integer","text":"<pre><code>parameter :count, type: :integer, default: 10\n</code></pre>"},{"location":"guides/using-tools/#number-float","title":"Number (Float)","text":"<pre><code>parameter :price, type: :number\n</code></pre>"},{"location":"guides/using-tools/#boolean","title":"Boolean","text":"<pre><code>parameter :active, type: :boolean, default: true\n</code></pre>"},{"location":"guides/using-tools/#array","title":"Array","text":"<pre><code>parameter :tags, type: :array\n</code></pre>"},{"location":"guides/using-tools/#enum","title":"Enum","text":"<pre><code>parameter :status, type: :string, enum: %w[pending active completed]\n</code></pre>"},{"location":"guides/using-tools/#with-description","title":"With Description","text":"<pre><code>parameter :query,\n          type: :string,\n          required: true,\n          description: \"Search query (supports wildcards)\"\n</code></pre>"},{"location":"guides/using-tools/#handler-patterns","title":"Handler Patterns","text":""},{"location":"guides/using-tools/#simple-handler","title":"Simple Handler","text":"<pre><code>handler { |param:, **_| do_something(param) }\n</code></pre>"},{"location":"guides/using-tools/#with-context-access","title":"With Context Access","text":"<pre><code>handler do |param:, robot:, network:, state:|\n  user_id = state.data[:user_id]\n  result = perform_action(param, user_id)\n  state.memory.remember(\"last_action\", result[:id])\n  result\nend\n</code></pre>"},{"location":"guides/using-tools/#error-handling","title":"Error Handling","text":"<pre><code>handler do |id:, **_|\n  record = Record.find_by(id: id)\n  if record\n    { success: true, data: record.to_h }\n  else\n    { success: false, error: \"Record not found\" }\n  end\nrescue StandardError =&gt; e\n  { success: false, error: e.message }\nend\n</code></pre>"},{"location":"guides/using-tools/#async-operations","title":"Async Operations","text":"<pre><code>handler do |url:, **_|\n  # Long-running operation\n  response = HTTP.timeout(30).get(url)\n  { status: response.status, body: response.body.to_s[0..1000] }\nend\n</code></pre>"},{"location":"guides/using-tools/#tool-return-values","title":"Tool Return Values","text":""},{"location":"guides/using-tools/#structured-data","title":"Structured Data","text":"<pre><code>handler do |user_id:, **_|\n  user = User.find(user_id)\n  {\n    id: user.id,\n    name: user.name,\n    email: user.email,\n    created_at: user.created_at.iso8601\n  }\nend\n</code></pre>"},{"location":"guides/using-tools/#simple-values","title":"Simple Values","text":"<pre><code>handler { |**_| Time.now.to_s }\nhandler { |**_| 42 }\nhandler { |**_| true }\n</code></pre>"},{"location":"guides/using-tools/#lists","title":"Lists","text":"<pre><code>handler do |query:, **_|\n  results = Search.query(query)\n  results.map { |r| { id: r.id, title: r.title, score: r.score } }\nend\n</code></pre>"},{"location":"guides/using-tools/#tool-manifests","title":"Tool Manifests","text":"<p>Wrap existing tools with modified metadata:</p> <pre><code># Original tool\nbase_tool = RobotLab::Tool.new(\n  name: \"search\",\n  description: \"General search\",\n  handler: -&gt;(q:, **_) { Search.query(q) }\n)\n\n# Customized version\nproduct_search = RobotLab::ToolManifest.new(\n  tool: base_tool,\n  name: \"search_products\",\n  description: \"Search the product catalog\"\n)\n\ncode_search = RobotLab::ToolManifest.new(\n  tool: base_tool,\n  name: \"search_code\",\n  description: \"Search source code\"\n)\n</code></pre>"},{"location":"guides/using-tools/#tool-whitelisting","title":"Tool Whitelisting","text":""},{"location":"guides/using-tools/#at-robot-level","title":"At Robot Level","text":"<pre><code>robot = RobotLab.build do\n  tools %w[read_file list_directory]  # Only these tools\n  tools :inherit                       # Use network's tools\n  tools :none                          # No inherited tools\nend\n</code></pre>"},{"location":"guides/using-tools/#at-network-level","title":"At Network Level","text":"<pre><code>network = RobotLab.create_network do\n  tools %w[search create_issue]  # Global whitelist\nend\n</code></pre>"},{"location":"guides/using-tools/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<pre><code>Global (RobotLab.configure)\n  \u2514\u2500\u2500 Network (tools: [...])\n        \u2514\u2500\u2500 Robot (tools: :inherit | :none | [...])\n</code></pre>"},{"location":"guides/using-tools/#mcp-tools","title":"MCP Tools","text":"<p>Use tools from MCP servers:</p> <pre><code>network = RobotLab.create_network do\n  mcp [\n    {\n      name: \"github\",\n      transport: { type: \"stdio\", command: \"mcp-server-github\" }\n    }\n  ]\n\n  # MCP tools automatically available\n  # e.g., search_repositories, create_issue, etc.\nend\n</code></pre>"},{"location":"guides/using-tools/#filtering-mcp-tools","title":"Filtering MCP Tools","text":"<pre><code>robot = RobotLab.build do\n  mcp :inherit  # Use network's MCP servers\n  tools %w[search_repositories create_issue]  # Only these MCP tools\nend\n</code></pre>"},{"location":"guides/using-tools/#common-tool-patterns","title":"Common Tool Patterns","text":""},{"location":"guides/using-tools/#database-lookup","title":"Database Lookup","text":"<pre><code>tool :find_user do\n  description \"Find user by email or ID\"\n  parameter :identifier, type: :string, required: true\n  handler do |identifier:, **_|\n    user = User.find_by(id: identifier) || User.find_by(email: identifier)\n    user ? user.to_h : { error: \"User not found\" }\n  end\nend\n</code></pre>"},{"location":"guides/using-tools/#api-integration","title":"API Integration","text":"<pre><code>tool :get_stock_price do\n  description \"Get current stock price\"\n  parameter :symbol, type: :string, required: true\n  handler do |symbol:, **_|\n    response = HTTP.get(\"https://api.stocks.example/quote/#{symbol}\")\n    JSON.parse(response.body)\n  rescue HTTP::Error =&gt; e\n    { error: \"Failed to fetch stock price: #{e.message}\" }\n  end\nend\n</code></pre>"},{"location":"guides/using-tools/#file-operations","title":"File Operations","text":"<pre><code>tool :read_file do\n  description \"Read contents of a file\"\n  parameter :path, type: :string, required: true\n  handler do |path:, **_|\n    if File.exist?(path) &amp;&amp; File.readable?(path)\n      { content: File.read(path), size: File.size(path) }\n    else\n      { error: \"File not found or not readable\" }\n    end\n  end\nend\n</code></pre>"},{"location":"guides/using-tools/#state-modification","title":"State Modification","text":"<pre><code>tool :update_preference do\n  description \"Update user preference\"\n  parameter :key, type: :string, required: true\n  parameter :value, type: :string, required: true\n  handler do |key:, value:, state:, **_|\n    state.memory.remember(\"pref:#{key}\", value)\n    { success: true, key: key, value: value }\n  end\nend\n</code></pre>"},{"location":"guides/using-tools/#multi-step-operations","title":"Multi-Step Operations","text":"<pre><code>tool :process_order do\n  description \"Process a customer order\"\n  parameter :order_id, type: :string, required: true\n  handler do |order_id:, state:, **_|\n    order = Order.find(order_id)\n\n    # Validate\n    return { error: \"Invalid order\" } unless order.valid?\n\n    # Process\n    result = PaymentProcessor.charge(order)\n    return { error: result[:error] } unless result[:success]\n\n    # Update\n    order.update!(status: \"paid\")\n\n    # Store for later reference\n    state.memory.remember(\"processed_order\", order.id)\n\n    { success: true, order_id: order.id, amount: order.total }\n  end\nend\n</code></pre>"},{"location":"guides/using-tools/#best-practices","title":"Best Practices","text":""},{"location":"guides/using-tools/#1-clear-descriptions","title":"1. Clear Descriptions","text":"<pre><code># Good: Specific and actionable\ntool :search_orders do\n  description \"Search customer orders by date range, status, or customer email. Returns up to 50 matching orders.\"\nend\n\n# Bad: Vague\ntool :search do\n  description \"Searches stuff\"\nend\n</code></pre>"},{"location":"guides/using-tools/#2-validate-inputs","title":"2. Validate Inputs","text":"<pre><code>handler do |email:, **_|\n  unless email.match?(/\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i)\n    return { error: \"Invalid email format\" }\n  end\n  # ... rest of handler\nend\n</code></pre>"},{"location":"guides/using-tools/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<pre><code>handler do |id:, **_|\n  result = ExternalAPI.fetch(id)\n  { success: true, data: result }\nrescue ExternalAPI::NotFound\n  { success: false, error: \"Resource not found\", id: id }\nrescue ExternalAPI::RateLimited =&gt; e\n  { success: false, error: \"Rate limited\", retry_after: e.retry_after }\nrescue StandardError =&gt; e\n  { success: false, error: \"Unexpected error: #{e.message}\" }\nend\n</code></pre>"},{"location":"guides/using-tools/#4-return-structured-data","title":"4. Return Structured Data","text":"<pre><code># Good: Structured and consistent\nhandler do |**_|\n  {\n    success: true,\n    data: { id: 1, name: \"Item\" },\n    metadata: { fetched_at: Time.now.iso8601 }\n  }\nend\n\n# Bad: Unstructured\nhandler { |**_| \"Found item with id 1 named Item\" }\n</code></pre>"},{"location":"guides/using-tools/#next-steps","title":"Next Steps","text":"<ul> <li>MCP Integration - External tool servers</li> <li>Building Robots - Robot creation patterns</li> <li>API Reference: Tool - Complete API</li> </ul>"}]}